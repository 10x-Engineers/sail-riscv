(*Generated by Sail from riscv.*)
Require Import Sail2_instr_kinds.
Require Import Sail2_values.
Require Import Sail2_string.
Require Import Sail2_real.
Require Import Sail2_operators_mwords.
Require Import Sail2_prompt_monad.
Require Import Sail2_prompt.
Require Import Sail2_state.
Require Import riscv_types.
Require Import riscv_extras.
Import ListNotations.
Open Scope string.
Open Scope bool.
Section Content.

Definition is_none {a : Type} (opt : option a) 
: bool :=
   
   match opt with | Some (_) => false | None => true end.

Definition is_some {a : Type} (opt : option a) 
: bool :=
   
   match opt with | Some (_) => true | None => false end.

Definition eq_unit (_ : unit) (_ : unit) 
: {_bool : bool & ArithFact (_bool = true)} :=
   
   build_ex(true).

Definition neq_int (x : Z) (y : Z) 
: {_bool : bool & ArithFact (iff (_bool = true) (x <> y))} :=
   
   build_ex(negb (Z.eqb x y)).

Definition neq_bool (x : bool) (y : bool)  : bool :=  negb (Bool.eqb x y).

Definition __id (x : Z)  : {_retval : Z & ArithFact (_retval = x)} :=  build_ex(x).

Definition concat_str_bits {n : Z} (str : string) (x : mword n) 
: string :=
   
   String.append str (string_of_bits x).

Definition concat_str_dec (str : string) (x : Z)  : string :=  String.append str (dec_str x).



Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) `{ArithFact (len >= 0 /\ v0 >= 0)} 
: mword len :=
   
   if sumbool_of_bool ((Z.leb len (length_mword v))) then vector_truncate v len
   else zero_extend v len.

Definition sail_ones (n : Z) `{ArithFact (n >= 0)}  : mword n :=  not_vec (zeros n).

Definition slice_mask (n : Z) (i : Z) (l : Z) `{ArithFact (n >= 0)} 
: mword n :=
   
   if sumbool_of_bool ((Z.geb l n)) then shiftl (sail_ones n) i
   else
     let one : bits n := sail_mask n ((vec_of_bits [B1]  : mword 1)  : bits 1) in
     shiftl (sub_vec (shiftl one l) one) i.

Definition read_kind_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 11)} 
: read_kind :=
   
   let l__196 := arg_ in
   if sumbool_of_bool ((Z.eqb l__196 0)) then Read_plain
   else if sumbool_of_bool ((Z.eqb l__196 1)) then Read_reserve
   else if sumbool_of_bool ((Z.eqb l__196 2)) then Read_acquire
   else if sumbool_of_bool ((Z.eqb l__196 3)) then Read_exclusive
   else if sumbool_of_bool ((Z.eqb l__196 4)) then Read_exclusive_acquire
   else if sumbool_of_bool ((Z.eqb l__196 5)) then Read_stream
   else if sumbool_of_bool ((Z.eqb l__196 6)) then Read_RISCV_acquire
   else if sumbool_of_bool ((Z.eqb l__196 7)) then Read_RISCV_strong_acquire
   else if sumbool_of_bool ((Z.eqb l__196 8)) then Read_RISCV_reserved
   else if sumbool_of_bool ((Z.eqb l__196 9)) then Read_RISCV_reserved_acquire
   else if sumbool_of_bool ((Z.eqb l__196 10)) then Read_RISCV_reserved_strong_acquire
   else Read_X86_locked.

Definition num_of_read_kind (arg_ : read_kind) 
: {e : Z & ArithFact (0 <= e /\ e <= 11)} :=
   
   build_ex(match arg_ with
            | Read_plain => 0
            | Read_reserve => 1
            | Read_acquire => 2
            | Read_exclusive => 3
            | Read_exclusive_acquire => 4
            | Read_stream => 5
            | Read_RISCV_acquire => 6
            | Read_RISCV_strong_acquire => 7
            | Read_RISCV_reserved => 8
            | Read_RISCV_reserved_acquire => 9
            | Read_RISCV_reserved_strong_acquire => 10
            | Read_X86_locked => 11
            end).

Definition write_kind_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 10)} 
: write_kind :=
   
   let l__186 := arg_ in
   if sumbool_of_bool ((Z.eqb l__186 0)) then Write_plain
   else if sumbool_of_bool ((Z.eqb l__186 1)) then Write_conditional
   else if sumbool_of_bool ((Z.eqb l__186 2)) then Write_release
   else if sumbool_of_bool ((Z.eqb l__186 3)) then Write_exclusive
   else if sumbool_of_bool ((Z.eqb l__186 4)) then Write_exclusive_release
   else if sumbool_of_bool ((Z.eqb l__186 5)) then Write_RISCV_release
   else if sumbool_of_bool ((Z.eqb l__186 6)) then Write_RISCV_strong_release
   else if sumbool_of_bool ((Z.eqb l__186 7)) then Write_RISCV_conditional
   else if sumbool_of_bool ((Z.eqb l__186 8)) then Write_RISCV_conditional_release
   else if sumbool_of_bool ((Z.eqb l__186 9)) then Write_RISCV_conditional_strong_release
   else Write_X86_locked.

Definition num_of_write_kind (arg_ : write_kind) 
: {e : Z & ArithFact (0 <= e /\ e <= 10)} :=
   
   build_ex(match arg_ with
            | Write_plain => 0
            | Write_conditional => 1
            | Write_release => 2
            | Write_exclusive => 3
            | Write_exclusive_release => 4
            | Write_RISCV_release => 5
            | Write_RISCV_strong_release => 6
            | Write_RISCV_conditional => 7
            | Write_RISCV_conditional_release => 8
            | Write_RISCV_conditional_strong_release => 9
            | Write_X86_locked => 10
            end).

Definition a64_barrier_domain_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: a64_barrier_domain :=
   
   let l__183 := arg_ in
   if sumbool_of_bool ((Z.eqb l__183 0)) then A64_FullShare
   else if sumbool_of_bool ((Z.eqb l__183 1)) then A64_InnerShare
   else if sumbool_of_bool ((Z.eqb l__183 2)) then A64_OuterShare
   else A64_NonShare.

Definition num_of_a64_barrier_domain (arg_ : a64_barrier_domain) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with
            | A64_FullShare => 0
            | A64_InnerShare => 1
            | A64_OuterShare => 2
            | A64_NonShare => 3
            end).

Definition a64_barrier_type_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: a64_barrier_type :=
   
   let l__181 := arg_ in
   if sumbool_of_bool ((Z.eqb l__181 0)) then A64_barrier_all
   else if sumbool_of_bool ((Z.eqb l__181 1)) then A64_barrier_LD
   else A64_barrier_ST.

Definition num_of_a64_barrier_type (arg_ : a64_barrier_type) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | A64_barrier_all => 0 | A64_barrier_LD => 1 | A64_barrier_ST => 2 end).

Definition trans_kind_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: trans_kind :=
   
   let l__179 := arg_ in
   if sumbool_of_bool ((Z.eqb l__179 0)) then Transaction_start
   else if sumbool_of_bool ((Z.eqb l__179 1)) then Transaction_commit
   else Transaction_abort.

Definition num_of_trans_kind (arg_ : trans_kind) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with
            | Transaction_start => 0
            | Transaction_commit => 1
            | Transaction_abort => 2
            end).

Definition cache_op_kind_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 10)} 
: cache_op_kind :=
   
   let l__169 := arg_ in
   if sumbool_of_bool ((Z.eqb l__169 0)) then Cache_op_D_IVAC
   else if sumbool_of_bool ((Z.eqb l__169 1)) then Cache_op_D_ISW
   else if sumbool_of_bool ((Z.eqb l__169 2)) then Cache_op_D_CSW
   else if sumbool_of_bool ((Z.eqb l__169 3)) then Cache_op_D_CISW
   else if sumbool_of_bool ((Z.eqb l__169 4)) then Cache_op_D_ZVA
   else if sumbool_of_bool ((Z.eqb l__169 5)) then Cache_op_D_CVAC
   else if sumbool_of_bool ((Z.eqb l__169 6)) then Cache_op_D_CVAU
   else if sumbool_of_bool ((Z.eqb l__169 7)) then Cache_op_D_CIVAC
   else if sumbool_of_bool ((Z.eqb l__169 8)) then Cache_op_I_IALLUIS
   else if sumbool_of_bool ((Z.eqb l__169 9)) then Cache_op_I_IALLU
   else Cache_op_I_IVAU.

Definition num_of_cache_op_kind (arg_ : cache_op_kind) 
: {e : Z & ArithFact (0 <= e /\ e <= 10)} :=
   
   build_ex(match arg_ with
            | Cache_op_D_IVAC => 0
            | Cache_op_D_ISW => 1
            | Cache_op_D_CSW => 2
            | Cache_op_D_CISW => 3
            | Cache_op_D_ZVA => 4
            | Cache_op_D_CVAC => 5
            | Cache_op_D_CVAU => 6
            | Cache_op_D_CIVAC => 7
            | Cache_op_I_IALLUIS => 8
            | Cache_op_I_IALLU => 9
            | Cache_op_I_IVAU => 10
            end).

Definition neq_vec {n : Z} (x : mword n) (y : mword n)  : bool :=  negb (eq_vec x y).



Definition cast_unit_vec (b : bitU) 
: M (mword 1) :=
   
   (match b with
    | B0 => returnm ((vec_of_bits [B0]  : mword 1)  : mword 1)
    | B1 => returnm ((vec_of_bits [B1]  : mword 1)  : mword 1)
    | _ => exit tt  : M (mword 1)
    end)
    : M (mword 1).

Definition get_config_print_instr '(tt : unit)  : bool :=  false.

Definition get_config_print_reg '(tt : unit)  : bool :=  false.

Definition get_config_print_mem '(tt : unit)  : bool :=  false.

Definition get_config_print_platform '(tt : unit)  : bool :=  false.

Definition EXTS {n : Z} (m : Z) (v : mword n) `{ArithFact (m >= n)}  : mword m :=  sign_extend v m.

Definition EXTZ {n : Z} (m : Z) (v : mword n) `{ArithFact (m >= n)}  : mword m :=  zero_extend v m.

Definition zeros_implicit (n : Z) `{ArithFact (n >= 0)}  : mword n :=  zeros n.

Definition ones (n : Z) `{ArithFact (n >= 0)}  : mword n :=  sail_ones n.

Definition bool_to_bits (x : bool) 
: mword 1 :=
   
   if sumbool_of_bool (x) then (vec_of_bits [B1]  : mword 1)
   else (vec_of_bits [B0]  : mword 1).

Definition bit_to_bool (b : bitU) 
: M (bool) :=
   
   (match b with
    | B1 => returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
    | B0 => returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))}))
    | _ => exit tt  : M (bool)
    end)
    : M (bool).

Definition to_bits (l : Z) (n : Z) `{ArithFact (l >= 0)}  : mword l :=  get_slice_int l n 0.

Definition zopz0zI_s {n : Z} (x : mword n) (y : mword n) `{ArithFact (n > 0)} 
: bool :=
   
   Z.ltb (projT1 (sint x)) (projT1 (sint y)).

Definition zopz0zKzJ_s {n : Z} (x : mword n) (y : mword n) `{ArithFact (n > 0)} 
: bool :=
   
   Z.geb (projT1 (sint x)) (projT1 (sint y)).

Definition zopz0zI_u {n : Z} (x : mword n) (y : mword n) 
: bool :=
   
   Z.ltb (projT1 (uint x)) (projT1 (uint y)).

Definition zopz0zKzJ_u {n : Z} (x : mword n) (y : mword n) 
: bool :=
   
   Z.geb (projT1 (uint x)) (projT1 (uint y)).

Definition zopz0zIzJ_u {n : Z} (x : mword n) (y : mword n) 
: bool :=
   
   Z.leb (projT1 (uint x)) (projT1 (uint y)).

Definition shift_right_arith64 (v : mword 64) (shift : mword 6) 
: mword 64 :=
   
   let v128 : bits 128 := EXTS 128 v in
   subrange_vec_dec (shift_bits_right v128 shift) 63 0.

Definition shift_right_arith32 (v : mword 32) (shift : mword 5) 
: mword 32 :=
   
   let v64 : bits 64 := EXTS 64 v in
   subrange_vec_dec (shift_bits_right v64 shift) 31 0.

Fixpoint _rec_n_leading_spaces (s : string) (_reclimit : Z)  (_acc : Acc (Zwf 0) _reclimit)
{struct _acc} : M ({n : Z & ArithFact (n >= 0)}) :=
   
   assert_exp' (Z.geb _reclimit 0) "recursion limit reached" >>= fun _ =>
   let p0_ := s in
   (if ((generic_eq p0_ "")) then returnm (build_ex (0  : Z))
    else
      let p0_ := string_take s 1 in
      (if ((generic_eq p0_ " ")) then
         (_rec_n_leading_spaces (string_drop s 1) (Z.sub _reclimit 1) (_limit_reduces _acc)) >>= fun '(existT _ w__0 _ : {n : Z & ArithFact (n >=
           0)}) =>
         returnm (build_ex
         (projT1
         (build_ex
         (Z.add 1 w__0)
          : {_atom : Z & ArithFact (exists ex98922_ , _atom = (1 + ex98922_) /\ 0 <= ex98922_)})))
       else returnm (build_ex (0  : Z)))
       : M ({n : Z & ArithFact (n >= 0)}))
    : M ({n : Z & ArithFact (n >= 0)}).

Definition n_leading_spaces (s : string) 
: M ({n : Z & ArithFact (n >= 0)}) :=
   
   (_rec_n_leading_spaces s ((projT1 (string_length s))  : Z) (Zwf_guarded _))
    : M ({n : Z & ArithFact (n >= 0)}).

Definition spc_forwards '(tt : unit)  : string :=  " ".

Definition spc_backwards (s : string)  : unit :=  tt.

Definition spc_matches_prefix (s : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   (n_leading_spaces s) >>= fun '(existT _ n _) =>
   let l__168 := n in
   returnm ((if sumbool_of_bool ((Z.eqb l__168 0)) then None
             else Some ((tt, build_ex n)))
    : option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition opt_spc_forwards '(tt : unit)  : string :=  "".

Definition opt_spc_backwards (s : string)  : unit :=  tt.

Definition opt_spc_matches_prefix (s : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   (n_leading_spaces s) >>= fun '(existT _ w__0 _ : {n : Z & ArithFact (n >= 0)}) =>
   returnm ((Some
               ((tt, build_ex
               w__0)))
    : option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition def_spc_forwards '(tt : unit)  : string :=  " ".

Definition def_spc_backwards (s : string)  : unit :=  tt.

Definition def_spc_matches_prefix (s : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   (opt_spc_matches_prefix s)
    : M (option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition hex_bits_1_forwards_matches (bv : mword 1)  : bool :=  true.

Definition hex_bits_1_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_1_matches_prefix s) with
           | Some ((g__258, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_1_backwards (s : string) 
: M (mword 1) :=
   
   (match (hex_bits_1_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 1)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 49:2 - 51:3" >>= fun _ =>
          exit tt)
        : M (mword 1)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 49:2 - 51:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 1).

Definition hex_bits_2_forwards_matches (bv : mword 2)  : bool :=  true.

Definition hex_bits_2_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_2_matches_prefix s) with
           | Some ((g__257, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_2_backwards (s : string) 
: M (mword 2) :=
   
   (match (hex_bits_2_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 2)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 68:2 - 70:3" >>= fun _ =>
          exit tt)
        : M (mword 2)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 68:2 - 70:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 2).

Definition hex_bits_3_forwards_matches (bv : mword 3)  : bool :=  true.

Definition hex_bits_3_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_3_matches_prefix s) with
           | Some ((g__256, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_3_backwards (s : string) 
: M (mword 3) :=
   
   (match (hex_bits_3_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 3)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 87:2 - 89:3" >>= fun _ =>
          exit tt)
        : M (mword 3)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 87:2 - 89:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 3).

Definition hex_bits_4_forwards_matches (bv : mword 4)  : bool :=  true.

Definition hex_bits_4_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_4_matches_prefix s) with
           | Some ((g__255, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_4_backwards (s : string) 
: M (mword 4) :=
   
   (match (hex_bits_4_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 4)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 106:2 - 108:3" >>= fun _ =>
          exit tt)
        : M (mword 4)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 106:2 - 108:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 4).

Definition hex_bits_5_forwards_matches (bv : mword 5)  : bool :=  true.

Definition hex_bits_5_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_5_matches_prefix s) with
           | Some ((g__254, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_5_backwards (s : string) 
: M (mword 5) :=
   
   (match (hex_bits_5_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 5)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 125:2 - 127:3" >>= fun _ =>
          exit tt)
        : M (mword 5)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 125:2 - 127:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 5).

Definition hex_bits_6_forwards_matches (bv : mword 6)  : bool :=  true.

Definition hex_bits_6_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_6_matches_prefix s) with
           | Some ((g__253, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_6_backwards (s : string) 
: M (mword 6) :=
   
   (match (hex_bits_6_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 6)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 144:2 - 146:3" >>= fun _ =>
          exit tt)
        : M (mword 6)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 144:2 - 146:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 6).

Definition hex_bits_7_forwards_matches (bv : mword 7)  : bool :=  true.

Definition hex_bits_7_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_7_matches_prefix s) with
           | Some ((g__252, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_7_backwards (s : string) 
: M (mword 7) :=
   
   (match (hex_bits_7_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 7)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 163:2 - 165:3" >>= fun _ =>
          exit tt)
        : M (mword 7)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 163:2 - 165:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 7).

Definition hex_bits_8_forwards_matches (bv : mword 8)  : bool :=  true.

Definition hex_bits_8_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_8_matches_prefix s) with
           | Some ((g__251, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_8_backwards (s : string) 
: M (mword 8) :=
   
   (match (hex_bits_8_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 8)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 182:2 - 184:3" >>= fun _ =>
          exit tt)
        : M (mword 8)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 182:2 - 184:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 8).

Definition hex_bits_9_forwards_matches (bv : mword 9)  : bool :=  true.

Definition hex_bits_9_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_9_matches_prefix s) with
           | Some ((g__250, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_9_backwards (s : string) 
: M (mword 9) :=
   
   (match (hex_bits_9_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 9)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 201:2 - 203:3" >>= fun _ =>
          exit tt)
        : M (mword 9)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 201:2 - 203:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 9).

Definition hex_bits_10_forwards_matches (bv : mword 10)  : bool :=  true.

Definition hex_bits_10_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_10_matches_prefix s) with
           | Some ((g__249, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_10_backwards (s : string) 
: M (mword 10) :=
   
   (match (hex_bits_10_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 10)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 220:2 - 222:3" >>= fun _ =>
          exit tt)
        : M (mword 10)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 220:2 - 222:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 10).

Definition hex_bits_11_forwards_matches (bv : mword 11)  : bool :=  true.

Definition hex_bits_11_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_11_matches_prefix s) with
           | Some ((g__248, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_11_backwards (s : string) 
: M (mword 11) :=
   
   (match (hex_bits_11_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 11)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 239:2 - 241:3" >>= fun _ =>
          exit tt)
        : M (mword 11)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 239:2 - 241:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 11).

Definition hex_bits_12_forwards_matches (bv : mword 12)  : bool :=  true.

Definition hex_bits_12_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_12_matches_prefix s) with
           | Some ((g__247, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_12_backwards (s : string) 
: M (mword 12) :=
   
   (match (hex_bits_12_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 12)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 258:2 - 260:3" >>= fun _ =>
          exit tt)
        : M (mword 12)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 258:2 - 260:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 12).

Definition hex_bits_13_forwards_matches (bv : mword 13)  : bool :=  true.

Definition hex_bits_13_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_13_matches_prefix s) with
           | Some ((g__246, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_13_backwards (s : string) 
: M (mword 13) :=
   
   (match (hex_bits_13_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 13)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 277:2 - 279:3" >>= fun _ =>
          exit tt)
        : M (mword 13)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 277:2 - 279:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 13).

Definition hex_bits_14_forwards_matches (bv : mword 14)  : bool :=  true.

Definition hex_bits_14_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_14_matches_prefix s) with
           | Some ((g__245, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_14_backwards (s : string) 
: M (mword 14) :=
   
   (match (hex_bits_14_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 14)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 296:2 - 298:3" >>= fun _ =>
          exit tt)
        : M (mword 14)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 296:2 - 298:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 14).

Definition hex_bits_15_forwards_matches (bv : mword 15)  : bool :=  true.

Definition hex_bits_15_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_15_matches_prefix s) with
           | Some ((g__244, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_15_backwards (s : string) 
: M (mword 15) :=
   
   (match (hex_bits_15_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 15)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 315:2 - 317:3" >>= fun _ =>
          exit tt)
        : M (mword 15)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 315:2 - 317:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 15).

Definition hex_bits_16_forwards_matches (bv : mword 16)  : bool :=  true.

Definition hex_bits_16_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_16_matches_prefix s) with
           | Some ((g__243, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_16_backwards (s : string) 
: M (mword 16) :=
   
   (match (hex_bits_16_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 16)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 334:2 - 336:3" >>= fun _ =>
          exit tt)
        : M (mword 16)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 334:2 - 336:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 16).

Definition hex_bits_17_forwards_matches (bv : mword 17)  : bool :=  true.

Definition hex_bits_17_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_17_matches_prefix s) with
           | Some ((g__242, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_17_backwards (s : string) 
: M (mword 17) :=
   
   (match (hex_bits_17_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 17)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 353:2 - 355:3" >>= fun _ =>
          exit tt)
        : M (mword 17)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 353:2 - 355:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 17).

Definition hex_bits_18_forwards_matches (bv : mword 18)  : bool :=  true.

Definition hex_bits_18_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_18_matches_prefix s) with
           | Some ((g__241, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_18_backwards (s : string) 
: M (mword 18) :=
   
   (match (hex_bits_18_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 18)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 372:2 - 374:3" >>= fun _ =>
          exit tt)
        : M (mword 18)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 372:2 - 374:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 18).

Definition hex_bits_19_forwards_matches (bv : mword 19)  : bool :=  true.

Definition hex_bits_19_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_19_matches_prefix s) with
           | Some ((g__240, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_19_backwards (s : string) 
: M (mword 19) :=
   
   (match (hex_bits_19_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 19)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 391:2 - 393:3" >>= fun _ =>
          exit tt)
        : M (mword 19)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 391:2 - 393:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 19).

Definition hex_bits_20_forwards_matches (bv : mword 20)  : bool :=  true.

Definition hex_bits_20_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_20_matches_prefix s) with
           | Some ((g__239, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_20_backwards (s : string) 
: M (mword 20) :=
   
   (match (hex_bits_20_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 20)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 410:2 - 412:3" >>= fun _ =>
          exit tt)
        : M (mword 20)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 410:2 - 412:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 20).

Definition hex_bits_21_forwards_matches (bv : mword 21)  : bool :=  true.

Definition hex_bits_21_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_21_matches_prefix s) with
           | Some ((g__238, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_21_backwards (s : string) 
: M (mword 21) :=
   
   (match (hex_bits_21_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 21)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 429:2 - 431:3" >>= fun _ =>
          exit tt)
        : M (mword 21)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 429:2 - 431:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 21).

Definition hex_bits_22_forwards_matches (bv : mword 22)  : bool :=  true.

Definition hex_bits_22_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_22_matches_prefix s) with
           | Some ((g__237, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_22_backwards (s : string) 
: M (mword 22) :=
   
   (match (hex_bits_22_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 22)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 448:2 - 450:3" >>= fun _ =>
          exit tt)
        : M (mword 22)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 448:2 - 450:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 22).

Definition hex_bits_23_forwards_matches (bv : mword 23)  : bool :=  true.

Definition hex_bits_23_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_23_matches_prefix s) with
           | Some ((g__236, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_23_backwards (s : string) 
: M (mword 23) :=
   
   (match (hex_bits_23_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 23)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 467:2 - 469:3" >>= fun _ =>
          exit tt)
        : M (mword 23)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 467:2 - 469:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 23).

Definition hex_bits_24_forwards_matches (bv : mword 24)  : bool :=  true.

Definition hex_bits_24_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_24_matches_prefix s) with
           | Some ((g__235, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_24_backwards (s : string) 
: M (mword 24) :=
   
   (match (hex_bits_24_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 24)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 486:2 - 488:3" >>= fun _ =>
          exit tt)
        : M (mword 24)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 486:2 - 488:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 24).

Definition hex_bits_25_forwards_matches (bv : mword 25)  : bool :=  true.

Definition hex_bits_25_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_25_matches_prefix s) with
           | Some ((g__234, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_25_backwards (s : string) 
: M (mword 25) :=
   
   (match (hex_bits_25_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 25)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 505:2 - 507:3" >>= fun _ =>
          exit tt)
        : M (mword 25)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 505:2 - 507:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 25).

Definition hex_bits_26_forwards_matches (bv : mword 26)  : bool :=  true.

Definition hex_bits_26_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_26_matches_prefix s) with
           | Some ((g__233, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_26_backwards (s : string) 
: M (mword 26) :=
   
   (match (hex_bits_26_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 26)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 524:2 - 526:3" >>= fun _ =>
          exit tt)
        : M (mword 26)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 524:2 - 526:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 26).

Definition hex_bits_27_forwards_matches (bv : mword 27)  : bool :=  true.

Definition hex_bits_27_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_27_matches_prefix s) with
           | Some ((g__232, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_27_backwards (s : string) 
: M (mword 27) :=
   
   (match (hex_bits_27_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 27)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 543:2 - 545:3" >>= fun _ =>
          exit tt)
        : M (mword 27)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 543:2 - 545:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 27).

Definition hex_bits_28_forwards_matches (bv : mword 28)  : bool :=  true.

Definition hex_bits_28_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_28_matches_prefix s) with
           | Some ((g__231, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_28_backwards (s : string) 
: M (mword 28) :=
   
   (match (hex_bits_28_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 28)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 562:2 - 564:3" >>= fun _ =>
          exit tt)
        : M (mword 28)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 562:2 - 564:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 28).

Definition hex_bits_29_forwards_matches (bv : mword 29)  : bool :=  true.

Definition hex_bits_29_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_29_matches_prefix s) with
           | Some ((g__230, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_29_backwards (s : string) 
: M (mword 29) :=
   
   (match (hex_bits_29_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 29)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 581:2 - 583:3" >>= fun _ =>
          exit tt)
        : M (mword 29)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 581:2 - 583:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 29).

Definition hex_bits_30_forwards_matches (bv : mword 30)  : bool :=  true.

Definition hex_bits_30_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_30_matches_prefix s) with
           | Some ((g__229, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_30_backwards (s : string) 
: M (mword 30) :=
   
   (match (hex_bits_30_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 30)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 600:2 - 602:3" >>= fun _ =>
          exit tt)
        : M (mword 30)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 600:2 - 602:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 30).

Definition hex_bits_31_forwards_matches (bv : mword 31)  : bool :=  true.

Definition hex_bits_31_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_31_matches_prefix s) with
           | Some ((g__228, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_31_backwards (s : string) 
: M (mword 31) :=
   
   (match (hex_bits_31_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 31)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 619:2 - 621:3" >>= fun _ =>
          exit tt)
        : M (mword 31)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 619:2 - 621:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 31).

Definition hex_bits_32_forwards_matches (bv : mword 32)  : bool :=  true.

Definition hex_bits_32_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_32_matches_prefix s) with
           | Some ((g__227, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_32_backwards (s : string) 
: M (mword 32) :=
   
   (match (hex_bits_32_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 32)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 638:2 - 640:3" >>= fun _ =>
          exit tt)
        : M (mword 32)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 638:2 - 640:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 32).

Definition hex_bits_33_forwards_matches (bv : mword 33)  : bool :=  true.

Definition hex_bits_33_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_33_matches_prefix s) with
           | Some ((g__226, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_33_backwards (s : string) 
: M (mword 33) :=
   
   (match (hex_bits_33_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 33)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 657:2 - 659:3" >>= fun _ =>
          exit tt)
        : M (mword 33)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 657:2 - 659:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 33).

Definition hex_bits_48_forwards_matches (bv : mword 48)  : bool :=  true.

Definition hex_bits_48_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_48_matches_prefix s) with
           | Some ((g__225, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_48_backwards (s : string) 
: M (mword 48) :=
   
   (match (hex_bits_48_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 48)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 676:2 - 678:3" >>= fun _ =>
          exit tt)
        : M (mword 48)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 676:2 - 678:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 48).

Definition hex_bits_64_forwards_matches (bv : mword 64)  : bool :=  true.

Definition hex_bits_64_backwards_matches (s : string) 
: bool :=
   
   match s with
   | s =>
      if ((match (hex_bits_64_matches_prefix s) with
           | Some ((g__224, existT _ n _)) =>
              if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then true else false
           | _ => false
           end)) then
        true
      else false
   end.

Definition hex_bits_64_backwards (s : string) 
: M (mword 64) :=
   
   (match (hex_bits_64_matches_prefix s) with
    | Some ((bv, existT _ n _)) =>
       (if sumbool_of_bool ((Z.eqb n (projT1 (string_length s)))) then returnm (bv  : mword 64)
        else
          assert_exp' false "Pattern match failure at model/prelude_mapping.sail 695:2 - 697:3" >>= fun _ =>
          exit tt)
        : M (mword 64)
    | _ =>
       assert_exp' false "Pattern match failure at model/prelude_mapping.sail 695:2 - 697:3" >>= fun _ =>
       exit tt
    end)
    : M (mword 64).

Definition default_meta : mem_meta := tt.
Hint Unfold default_meta : sail.
Definition __WriteRAM_Meta (addr : mword 64) (width : Z) (meta : unit) 
: M (unit) :=
   
   returnm (tt
    : unit).

Definition __ReadRAM_Meta (addr : mword 64) (width : Z)  : M (unit) :=  returnm (tt  : unit).

Definition write_ram
(wk : write_kind) (addr : mword 64) (width : Z) (data : mword (8 * width)) (meta : unit)
`{ArithFact (0 < width /\ width <= 16)} 
: M (bool) :=
   
   (write_mem wk 64 addr width data) >>= fun ret : bool =>
   (if sumbool_of_bool (ret) then (__WriteRAM_Meta addr width meta)  : M (unit)
    else returnm (tt  : unit)) >>
   returnm (ret
    : bool).

Definition write_ram_ea (wk : write_kind) (addr : mword 64) (width : Z)
`{ArithFact (0 < width /\ width <= 16)} 
: M (unit) :=
   
   (write_mem_ea wk 64 addr width)
    : M (unit).

Definition read_ram (rk : read_kind) (addr : mword 64) (width : Z)
`{ArithFact (0 < width /\ width <= 16)} 
: M (mword (8 * width)) :=
   
   (read_mem rk 64 addr width)
    : M (mword (8 * width)).

Axiom __TraceMemoryWrite : forall {m : Z} (n : Z) (_ : mword m) (_ : mword (8 * n)) , unit.

Axiom __TraceMemoryRead : forall {m : Z} (n : Z) (_ : mword m) (_ : mword (8 * n)) , unit.

Definition xlen_val := 64.
Hint Unfold xlen_val : sail.
Definition xlen_max_unsigned := Z.sub (projT1 (pow2 64)) 1.
Hint Unfold xlen_max_unsigned : sail.
Definition xlen_max_signed := Z.sub (projT1 (pow2 (Z.sub 64 1))) 1.
Hint Unfold xlen_max_signed : sail.
Definition xlen_min_signed := Z.sub 0 (projT1 (pow2 (Z.sub 64 1))).
Hint Unfold xlen_min_signed : sail.
Definition regidx_to_regno (b : mword 5) 
: {n : Z & ArithFact (0 <= n /\ n < 32)} :=
   
   build_ex(let 'r := projT1 (uint b) in
   r).

Definition creg2reg_idx (creg : mword 3) 
: mword 5 :=
   
   concat_vec (vec_of_bits [B0;B1]  : mword 2) creg.

Definition zreg : regidx := (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5).
Hint Unfold zreg : sail.
Definition ra : regidx := (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5).
Hint Unfold ra : sail.
Definition sp : regidx := (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5).
Hint Unfold sp : sail.
Definition Architecture_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: Architecture :=
   
   let l__166 := arg_ in
   if sumbool_of_bool ((Z.eqb l__166 0)) then RV32
   else if sumbool_of_bool ((Z.eqb l__166 1)) then RV64
   else RV128.

Definition num_of_Architecture (arg_ : Architecture) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | RV32 => 0 | RV64 => 1 | RV128 => 2 end).

Definition architecture (a : mword 2) 
: option Architecture :=
   
   let b__0 := a in
   if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then Some (RV32)
   else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then Some (RV64)
   else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then Some (RV128)
   else None.

Definition arch_to_bits (a : Architecture) 
: mword 2 :=
   
   match a with
   | RV32 => (vec_of_bits [B0;B1]  : mword 2)
   | RV64 => (vec_of_bits [B1;B0]  : mword 2)
   | RV128 => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition Privilege_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: Privilege :=
   
   let l__164 := arg_ in
   if sumbool_of_bool ((Z.eqb l__164 0)) then User
   else if sumbool_of_bool ((Z.eqb l__164 1)) then Supervisor
   else Machine.

Definition num_of_Privilege (arg_ : Privilege) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | User => 0 | Supervisor => 1 | Machine => 2 end).

Definition privLevel_to_bits (p : Privilege) 
: mword 2 :=
   
   match p with
   | User => (vec_of_bits [B0;B0]  : mword 2)
   | Supervisor => (vec_of_bits [B0;B1]  : mword 2)
   | Machine => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition privLevel_of_bits (p : mword 2) 
: M (Privilege) :=
   
   let b__0 := p in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then returnm (User  : Privilege)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then returnm (Supervisor  : Privilege)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then returnm (Machine  : Privilege)
    else
      assert_exp' false "Pattern match failure at model/riscv_types.sail 78:2 - 82:3" >>= fun _ =>
      exit tt)
    : M (Privilege).

Definition privLevel_to_str (p : Privilege) 
: string :=
   
   match p with | User => "U" | Supervisor => "S" | Machine => "M" end.

Definition Retired_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 1)} 
: Retired :=
   
   let l__163 := arg_ in
   if sumbool_of_bool ((Z.eqb l__163 0)) then RETIRE_SUCCESS
   else RETIRE_FAIL.

Definition num_of_Retired (arg_ : Retired) 
: {e : Z & ArithFact (0 <= e /\ e <= 1)} :=
   
   build_ex(match arg_ with | RETIRE_SUCCESS => 0 | RETIRE_FAIL => 1 end).

Definition AccessType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: AccessType :=
   
   let l__160 := arg_ in
   if sumbool_of_bool ((Z.eqb l__160 0)) then Read
   else if sumbool_of_bool ((Z.eqb l__160 1)) then Write
   else if sumbool_of_bool ((Z.eqb l__160 2)) then ReadWrite
   else Execute.

Definition num_of_AccessType (arg_ : AccessType) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | Read => 0 | Write => 1 | ReadWrite => 2 | Execute => 3 end).

Definition accessType_to_str (a : AccessType) 
: string :=
   
   match a with | Read => "R" | Write => "W" | ReadWrite => "RW" | Execute => "X" end.

Definition word_width_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: word_width :=
   
   let l__157 := arg_ in
   if sumbool_of_bool ((Z.eqb l__157 0)) then BYTE
   else if sumbool_of_bool ((Z.eqb l__157 1)) then HALF
   else if sumbool_of_bool ((Z.eqb l__157 2)) then WORD
   else DOUBLE.

Definition num_of_word_width (arg_ : word_width) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | BYTE => 0 | HALF => 1 | WORD => 2 | DOUBLE => 3 end).

Definition InterruptType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 8)} 
: InterruptType :=
   
   let l__149 := arg_ in
   if sumbool_of_bool ((Z.eqb l__149 0)) then I_U_Software
   else if sumbool_of_bool ((Z.eqb l__149 1)) then I_S_Software
   else if sumbool_of_bool ((Z.eqb l__149 2)) then I_M_Software
   else if sumbool_of_bool ((Z.eqb l__149 3)) then I_U_Timer
   else if sumbool_of_bool ((Z.eqb l__149 4)) then I_S_Timer
   else if sumbool_of_bool ((Z.eqb l__149 5)) then I_M_Timer
   else if sumbool_of_bool ((Z.eqb l__149 6)) then I_U_External
   else if sumbool_of_bool ((Z.eqb l__149 7)) then I_S_External
   else I_M_External.

Definition num_of_InterruptType (arg_ : InterruptType) 
: {e : Z & ArithFact (0 <= e /\ e <= 8)} :=
   
   build_ex(match arg_ with
            | I_U_Software => 0
            | I_S_Software => 1
            | I_M_Software => 2
            | I_U_Timer => 3
            | I_S_Timer => 4
            | I_M_Timer => 5
            | I_U_External => 6
            | I_S_External => 7
            | I_M_External => 8
            end).

Definition interruptType_to_bits (i : InterruptType) 
: mword 8 :=
   
   match i with
   | I_U_Software => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8)
   | I_S_Software => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1]  : mword 8)
   | I_M_Software => (vec_of_bits [B0;B0;B0;B0;B0;B0;B1;B1]  : mword 8)
   | I_U_Timer => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0]  : mword 8)
   | I_S_Timer => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B1]  : mword 8)
   | I_M_Timer => (vec_of_bits [B0;B0;B0;B0;B0;B1;B1;B1]  : mword 8)
   | I_U_External => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B0]  : mword 8)
   | I_S_External => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B1]  : mword 8)
   | I_M_External => (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B1]  : mword 8)
   end.

Definition ExceptionType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 16)} 
: ExceptionType :=
   
   let l__133 := arg_ in
   if sumbool_of_bool ((Z.eqb l__133 0)) then E_Fetch_Addr_Align
   else if sumbool_of_bool ((Z.eqb l__133 1)) then E_Fetch_Access_Fault
   else if sumbool_of_bool ((Z.eqb l__133 2)) then E_Illegal_Instr
   else if sumbool_of_bool ((Z.eqb l__133 3)) then E_Breakpoint
   else if sumbool_of_bool ((Z.eqb l__133 4)) then E_Load_Addr_Align
   else if sumbool_of_bool ((Z.eqb l__133 5)) then E_Load_Access_Fault
   else if sumbool_of_bool ((Z.eqb l__133 6)) then E_SAMO_Addr_Align
   else if sumbool_of_bool ((Z.eqb l__133 7)) then E_SAMO_Access_Fault
   else if sumbool_of_bool ((Z.eqb l__133 8)) then E_U_EnvCall
   else if sumbool_of_bool ((Z.eqb l__133 9)) then E_S_EnvCall
   else if sumbool_of_bool ((Z.eqb l__133 10)) then E_Reserved_10
   else if sumbool_of_bool ((Z.eqb l__133 11)) then E_M_EnvCall
   else if sumbool_of_bool ((Z.eqb l__133 12)) then E_Fetch_Page_Fault
   else if sumbool_of_bool ((Z.eqb l__133 13)) then E_Load_Page_Fault
   else if sumbool_of_bool ((Z.eqb l__133 14)) then E_Reserved_14
   else if sumbool_of_bool ((Z.eqb l__133 15)) then E_SAMO_Page_Fault
   else E_CHERI.

Definition num_of_ExceptionType (arg_ : ExceptionType) 
: {e : Z & ArithFact (0 <= e /\ e <= 16)} :=
   
   build_ex(match arg_ with
            | E_Fetch_Addr_Align => 0
            | E_Fetch_Access_Fault => 1
            | E_Illegal_Instr => 2
            | E_Breakpoint => 3
            | E_Load_Addr_Align => 4
            | E_Load_Access_Fault => 5
            | E_SAMO_Addr_Align => 6
            | E_SAMO_Access_Fault => 7
            | E_U_EnvCall => 8
            | E_S_EnvCall => 9
            | E_Reserved_10 => 10
            | E_M_EnvCall => 11
            | E_Fetch_Page_Fault => 12
            | E_Load_Page_Fault => 13
            | E_Reserved_14 => 14
            | E_SAMO_Page_Fault => 15
            | E_CHERI => 16
            end).

Definition exceptionType_to_bits (e : ExceptionType) 
: mword 8 :=
   
   match e with
   | E_Fetch_Addr_Align => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8)
   | E_Fetch_Access_Fault => (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1]  : mword 8)
   | E_Illegal_Instr => (vec_of_bits [B0;B0;B0;B0;B0;B0;B1;B0]  : mword 8)
   | E_Breakpoint => (vec_of_bits [B0;B0;B0;B0;B0;B0;B1;B1]  : mword 8)
   | E_Load_Addr_Align => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0]  : mword 8)
   | E_Load_Access_Fault => (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B1]  : mword 8)
   | E_SAMO_Addr_Align => (vec_of_bits [B0;B0;B0;B0;B0;B1;B1;B0]  : mword 8)
   | E_SAMO_Access_Fault => (vec_of_bits [B0;B0;B0;B0;B0;B1;B1;B1]  : mword 8)
   | E_U_EnvCall => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B0]  : mword 8)
   | E_S_EnvCall => (vec_of_bits [B0;B0;B0;B0;B1;B0;B0;B1]  : mword 8)
   | E_Reserved_10 => (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B0]  : mword 8)
   | E_M_EnvCall => (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B1]  : mword 8)
   | E_Fetch_Page_Fault => (vec_of_bits [B0;B0;B0;B0;B1;B1;B0;B0]  : mword 8)
   | E_Load_Page_Fault => (vec_of_bits [B0;B0;B0;B0;B1;B1;B0;B1]  : mword 8)
   | E_Reserved_14 => (vec_of_bits [B0;B0;B0;B0;B1;B1;B1;B0]  : mword 8)
   | E_SAMO_Page_Fault => (vec_of_bits [B0;B0;B0;B0;B1;B1;B1;B1]  : mword 8)
   | E_CHERI => (vec_of_bits [B0;B0;B1;B0;B0;B0;B0;B0]  : mword 8)
   end.

Definition exceptionType_to_str (e : ExceptionType) 
: string :=
   
   match e with
   | E_Fetch_Addr_Align => "misaligned-fetch"
   | E_Fetch_Access_Fault => "fetch-access-fault"
   | E_Illegal_Instr => "illegal-instruction"
   | E_Breakpoint => "breakpoint"
   | E_Load_Addr_Align => "misaligned-load"
   | E_Load_Access_Fault => "load-access-fault"
   | E_SAMO_Addr_Align => "misaliged-store/amo"
   | E_SAMO_Access_Fault => "store/amo-access-fault"
   | E_U_EnvCall => "u-call"
   | E_S_EnvCall => "s-call"
   | E_Reserved_10 => "reserved-0"
   | E_M_EnvCall => "m-call"
   | E_Fetch_Page_Fault => "fetch-page-fault"
   | E_Load_Page_Fault => "load-page-fault"
   | E_Reserved_14 => "reserved-1"
   | E_SAMO_Page_Fault => "store/amo-page-fault"
   | E_CHERI => "CHERI"
   end.

Definition not_implemented {a : Type} (message : string) 
: M (a) :=
   
   throw (Error_not_implemented
            (message)).

Definition internal_error {a : Type} (s : string) 
: M (a) :=
   
   assert_exp' false s >>= fun _ => exit tt.

Definition TrapVectorMode_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: TrapVectorMode :=
   
   let l__131 := arg_ in
   if sumbool_of_bool ((Z.eqb l__131 0)) then TV_Direct
   else if sumbool_of_bool ((Z.eqb l__131 1)) then TV_Vector
   else TV_Reserved.

Definition num_of_TrapVectorMode (arg_ : TrapVectorMode) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | TV_Direct => 0 | TV_Vector => 1 | TV_Reserved => 2 end).

Definition trapVectorMode_of_bits (m : mword 2) 
: TrapVectorMode :=
   
   let b__0 := m in
   if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then TV_Direct
   else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then TV_Vector
   else TV_Reserved.

Definition ExtStatus_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: ExtStatus :=
   
   let l__128 := arg_ in
   if sumbool_of_bool ((Z.eqb l__128 0)) then Off
   else if sumbool_of_bool ((Z.eqb l__128 1)) then Initial
   else if sumbool_of_bool ((Z.eqb l__128 2)) then Clean
   else Dirty.

Definition num_of_ExtStatus (arg_ : ExtStatus) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | Off => 0 | Initial => 1 | Clean => 2 | Dirty => 3 end).

Definition extStatus_to_bits (e : ExtStatus) 
: mword 2 :=
   
   match e with
   | Off => (vec_of_bits [B0;B0]  : mword 2)
   | Initial => (vec_of_bits [B0;B1]  : mword 2)
   | Clean => (vec_of_bits [B1;B0]  : mword 2)
   | Dirty => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition extStatus_of_bits (e : mword 2) 
: M (ExtStatus) :=
   
   let b__0 := e in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then returnm (Off  : ExtStatus)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then returnm (Initial  : ExtStatus)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then returnm (Clean  : ExtStatus)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then returnm (Dirty  : ExtStatus)
    else
      assert_exp' false "Pattern match failure at model/riscv_types.sail 264:2 - 269:3" >>= fun _ =>
      exit tt)
    : M (ExtStatus).

Definition SATPMode_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: SATPMode :=
   
   let l__125 := arg_ in
   if sumbool_of_bool ((Z.eqb l__125 0)) then Sbare
   else if sumbool_of_bool ((Z.eqb l__125 1)) then Sv32
   else if sumbool_of_bool ((Z.eqb l__125 2)) then Sv39
   else Sv48.

Definition num_of_SATPMode (arg_ : SATPMode) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | Sbare => 0 | Sv32 => 1 | Sv39 => 2 | Sv48 => 3 end).

Definition satp64Mode_of_bits (a : Architecture) (m : mword 4) 
: option SATPMode :=
   
   match (a, m) with
   | (g__223, b__0) =>
      if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0]  : mword 4))) then Some (Sbare)
      else
        match (g__223, b__0) with
        | (RV32, b__0) =>
           if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1]  : mword 4))) then Some (Sv32)
           else match (RV32, b__0) with | (_, _) => None end
        | (RV64, b__0) =>
           if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0]  : mword 4))) then Some (Sv39)
           else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B1]  : mword 4))) then Some (Sv48)
           else match (RV64, b__0) with | (_, _) => None end
        | (_, _) => None
        end
   end.

Definition uop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 1)} 
: uop :=
   
   let l__124 := arg_ in
   if sumbool_of_bool ((Z.eqb l__124 0)) then RISCV_LUI
   else RISCV_AUIPC.

Definition num_of_uop (arg_ : uop) 
: {e : Z & ArithFact (0 <= e /\ e <= 1)} :=
   
   build_ex(match arg_ with | RISCV_LUI => 0 | RISCV_AUIPC => 1 end).

Definition bop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 5)} 
: bop :=
   
   let l__119 := arg_ in
   if sumbool_of_bool ((Z.eqb l__119 0)) then RISCV_BEQ
   else if sumbool_of_bool ((Z.eqb l__119 1)) then RISCV_BNE
   else if sumbool_of_bool ((Z.eqb l__119 2)) then RISCV_BLT
   else if sumbool_of_bool ((Z.eqb l__119 3)) then RISCV_BGE
   else if sumbool_of_bool ((Z.eqb l__119 4)) then RISCV_BLTU
   else RISCV_BGEU.

Definition num_of_bop (arg_ : bop) 
: {e : Z & ArithFact (0 <= e /\ e <= 5)} :=
   
   build_ex(match arg_ with
            | RISCV_BEQ => 0
            | RISCV_BNE => 1
            | RISCV_BLT => 2
            | RISCV_BGE => 3
            | RISCV_BLTU => 4
            | RISCV_BGEU => 5
            end).

Definition iop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 5)} 
: iop :=
   
   let l__114 := arg_ in
   if sumbool_of_bool ((Z.eqb l__114 0)) then RISCV_ADDI
   else if sumbool_of_bool ((Z.eqb l__114 1)) then RISCV_SLTI
   else if sumbool_of_bool ((Z.eqb l__114 2)) then RISCV_SLTIU
   else if sumbool_of_bool ((Z.eqb l__114 3)) then RISCV_XORI
   else if sumbool_of_bool ((Z.eqb l__114 4)) then RISCV_ORI
   else RISCV_ANDI.

Definition num_of_iop (arg_ : iop) 
: {e : Z & ArithFact (0 <= e /\ e <= 5)} :=
   
   build_ex(match arg_ with
            | RISCV_ADDI => 0
            | RISCV_SLTI => 1
            | RISCV_SLTIU => 2
            | RISCV_XORI => 3
            | RISCV_ORI => 4
            | RISCV_ANDI => 5
            end).

Definition sop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: sop :=
   
   let l__112 := arg_ in
   if sumbool_of_bool ((Z.eqb l__112 0)) then RISCV_SLLI
   else if sumbool_of_bool ((Z.eqb l__112 1)) then RISCV_SRLI
   else RISCV_SRAI.

Definition num_of_sop (arg_ : sop) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | RISCV_SLLI => 0 | RISCV_SRLI => 1 | RISCV_SRAI => 2 end).

Definition rop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 9)} 
: rop :=
   
   let l__103 := arg_ in
   if sumbool_of_bool ((Z.eqb l__103 0)) then RISCV_ADD
   else if sumbool_of_bool ((Z.eqb l__103 1)) then RISCV_SUB
   else if sumbool_of_bool ((Z.eqb l__103 2)) then RISCV_SLL
   else if sumbool_of_bool ((Z.eqb l__103 3)) then RISCV_SLT
   else if sumbool_of_bool ((Z.eqb l__103 4)) then RISCV_SLTU
   else if sumbool_of_bool ((Z.eqb l__103 5)) then RISCV_XOR
   else if sumbool_of_bool ((Z.eqb l__103 6)) then RISCV_SRL
   else if sumbool_of_bool ((Z.eqb l__103 7)) then RISCV_SRA
   else if sumbool_of_bool ((Z.eqb l__103 8)) then RISCV_OR
   else RISCV_AND.

Definition num_of_rop (arg_ : rop) 
: {e : Z & ArithFact (0 <= e /\ e <= 9)} :=
   
   build_ex(match arg_ with
            | RISCV_ADD => 0
            | RISCV_SUB => 1
            | RISCV_SLL => 2
            | RISCV_SLT => 3
            | RISCV_SLTU => 4
            | RISCV_XOR => 5
            | RISCV_SRL => 6
            | RISCV_SRA => 7
            | RISCV_OR => 8
            | RISCV_AND => 9
            end).

Definition ropw_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 4)} 
: ropw :=
   
   let l__99 := arg_ in
   if sumbool_of_bool ((Z.eqb l__99 0)) then RISCV_ADDW
   else if sumbool_of_bool ((Z.eqb l__99 1)) then RISCV_SUBW
   else if sumbool_of_bool ((Z.eqb l__99 2)) then RISCV_SLLW
   else if sumbool_of_bool ((Z.eqb l__99 3)) then RISCV_SRLW
   else RISCV_SRAW.

Definition num_of_ropw (arg_ : ropw) 
: {e : Z & ArithFact (0 <= e /\ e <= 4)} :=
   
   build_ex(match arg_ with
            | RISCV_ADDW => 0
            | RISCV_SUBW => 1
            | RISCV_SLLW => 2
            | RISCV_SRLW => 3
            | RISCV_SRAW => 4
            end).

Definition sopw_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: sopw :=
   
   let l__97 := arg_ in
   if sumbool_of_bool ((Z.eqb l__97 0)) then RISCV_SLLIW
   else if sumbool_of_bool ((Z.eqb l__97 1)) then RISCV_SRLIW
   else RISCV_SRAIW.

Definition num_of_sopw (arg_ : sopw) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | RISCV_SLLIW => 0 | RISCV_SRLIW => 1 | RISCV_SRAIW => 2 end).

Definition amoop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 8)} 
: amoop :=
   
   let l__89 := arg_ in
   if sumbool_of_bool ((Z.eqb l__89 0)) then AMOSWAP
   else if sumbool_of_bool ((Z.eqb l__89 1)) then AMOADD
   else if sumbool_of_bool ((Z.eqb l__89 2)) then AMOXOR
   else if sumbool_of_bool ((Z.eqb l__89 3)) then AMOAND
   else if sumbool_of_bool ((Z.eqb l__89 4)) then AMOOR
   else if sumbool_of_bool ((Z.eqb l__89 5)) then AMOMIN
   else if sumbool_of_bool ((Z.eqb l__89 6)) then AMOMAX
   else if sumbool_of_bool ((Z.eqb l__89 7)) then AMOMINU
   else AMOMAXU.

Definition num_of_amoop (arg_ : amoop) 
: {e : Z & ArithFact (0 <= e /\ e <= 8)} :=
   
   build_ex(match arg_ with
            | AMOSWAP => 0
            | AMOADD => 1
            | AMOXOR => 2
            | AMOAND => 3
            | AMOOR => 4
            | AMOMIN => 5
            | AMOMAX => 6
            | AMOMINU => 7
            | AMOMAXU => 8
            end).

Definition csrop_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: csrop :=
   
   let l__87 := arg_ in
   if sumbool_of_bool ((Z.eqb l__87 0)) then CSRRW
   else if sumbool_of_bool ((Z.eqb l__87 1)) then CSRRS
   else CSRRC.

Definition num_of_csrop (arg_ : csrop) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | CSRRW => 0 | CSRRS => 1 | CSRRC => 2 end).

Definition sep_forwards (arg_ : unit) 
: string :=
   
   match arg_ with
   | tt =>
      string_append (opt_spc_forwards tt)
        (string_append "," (string_append (def_spc_forwards tt) ""))
   end.

Definition _s0_ (_s1_ : string) 
: M (option unit) :=
   
   (match _s1_ with
    | _s2_ =>
       (opt_spc_matches_prefix _s2_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
       (match w__0 with
        | Some ((tt, existT _ _s3_ _)) =>
           let _s4_ := string_drop _s2_ _s3_ in
           (if ((string_startswith _s4_ ",")) then
              (match (string_drop _s4_ (projT1 (string_length ","))) with
               | _s5_ =>
                  (def_spc_matches_prefix _s5_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((tt, existT _ _s6_ _)) =>
                               let p0_ := string_drop _s5_ _s6_ in
                               if ((generic_eq p0_ "")) then Some (tt)
                               else None
                            | _ => None
                            end)
                   : option unit)
               end)
               : M (option unit)
            else returnm (None  : option unit))
            : M (option unit)
        | _ => returnm (None  : option unit)
        end)
        : M (option unit)
    end)
    : M (option unit).

Definition sep_backwards (arg_ : string) 
: M (unit) :=
   
   let _s7_ := arg_ in
   (_s0_ _s7_) >>= fun w__0 : option unit =>
   (if ((match w__0 with | Some (tt) => true | _ => false end)) then
      (_s0_ _s7_) >>= fun w__1 : option unit =>
      (match w__1 with | Some (tt) => returnm (tt  : unit) | _ => exit tt  : M (unit) end)
       : M (unit)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (unit).

Definition sep_forwards_matches (arg_ : unit)  : bool :=  match arg_ with | tt => true end.

Definition _s8_ (_s9_ : string) 
: M (option unit) :=
   
   (match _s9_ with
    | _s10_ =>
       (opt_spc_matches_prefix _s10_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
       (match w__0 with
        | Some ((tt, existT _ _s11_ _)) =>
           let _s12_ := string_drop _s10_ _s11_ in
           (if ((string_startswith _s12_ ",")) then
              (match (string_drop _s12_ (projT1 (string_length ","))) with
               | _s13_ =>
                  (def_spc_matches_prefix _s13_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((tt, existT _ _s14_ _)) =>
                               let p0_ := string_drop _s13_ _s14_ in
                               if ((generic_eq p0_ "")) then Some (tt)
                               else None
                            | _ => None
                            end)
                   : option unit)
               end)
               : M (option unit)
            else returnm (None  : option unit))
            : M (option unit)
        | _ => returnm (None  : option unit)
        end)
        : M (option unit)
    end)
    : M (option unit).

Definition sep_backwards_matches (arg_ : string) 
: M (bool) :=
   
   let _s15_ := arg_ in
   (_s8_ _s15_) >>= fun w__0 : option unit =>
   (if ((match w__0 with | Some (tt) => true | _ => false end)) then
      (_s8_ _s15_) >>= fun w__1 : option unit =>
      (match w__1 with
       | Some (tt) => returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
       | _ => exit tt  : M (bool)
       end)
       : M (bool)
    else returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))})))
    : M (bool).

Definition _s16_ (_s17_ : string) 
: M (option string) :=
   
   (match _s17_ with
    | _s18_ =>
       (opt_spc_matches_prefix _s18_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
       (match w__0 with
        | Some ((tt, existT _ _s19_ _)) =>
           let _s20_ := string_drop _s18_ _s19_ in
           (if ((string_startswith _s20_ ",")) then
              (match (string_drop _s20_ (projT1 (string_length ","))) with
               | _s21_ =>
                  (def_spc_matches_prefix _s21_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((tt, existT _ _s22_ _)) =>
                               match (string_drop _s21_ _s22_) with | s_ => Some (s_) end
                            | _ => None
                            end)
                   : option string)
               end)
               : M (option string)
            else returnm (None  : option string))
            : M (option string)
        | _ => returnm (None  : option string)
        end)
        : M (option string)
    end)
    : M (option string).

Definition sep_matches_prefix (arg_ : string) 
: M (option ((unit * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s23_ := arg_ in
   (_s16_ _s23_) >>= fun w__0 : option string =>
   (if ((match w__0 with | Some (s_) => true | _ => false end)) then
      (_s16_ _s23_) >>= fun w__1 : option string =>
      (match w__1 with
       | Some (s_) =>
          returnm ((Some
                      ((tt, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((unit * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((unit * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((unit * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((unit * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((unit * {n : Z & ArithFact (n >= 0)}))).

Definition bool_bits_forwards (arg_ : bool) 
: mword 1 :=
   
   match arg_ with
   | true => (vec_of_bits [B1]  : mword 1)
   | false => (vec_of_bits [B0]  : mword 1)
   end.

Definition bool_bits_backwards (arg_ : mword 1) 
: M (bool) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bool).

Definition bool_bits_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition bool_bits_backwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else false.

Definition bool_not_bits_forwards (arg_ : bool) 
: mword 1 :=
   
   match arg_ with
   | true => (vec_of_bits [B0]  : mword 1)
   | false => (vec_of_bits [B1]  : mword 1)
   end.

Definition bool_not_bits_backwards (arg_ : mword 1) 
: M (bool) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bool).

Definition bool_not_bits_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition bool_not_bits_backwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else false.

Definition size_bits_forwards (arg_ : word_width) 
: mword 2 :=
   
   match arg_ with
   | BYTE => (vec_of_bits [B0;B0]  : mword 2)
   | HALF => (vec_of_bits [B0;B1]  : mword 2)
   | WORD => (vec_of_bits [B1;B0]  : mword 2)
   | DOUBLE => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition size_bits_backwards (arg_ : mword 2) 
: M (word_width) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then returnm (BYTE  : word_width)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then returnm (HALF  : word_width)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then returnm (WORD  : word_width)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then returnm (DOUBLE  : word_width)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (word_width).

Definition size_bits_forwards_matches (arg_ : word_width) 
: bool :=
   
   match arg_ with | BYTE => true | HALF => true | WORD => true | DOUBLE => true end.

Definition size_bits_backwards_matches (arg_ : mword 2) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then true
   else false.

Definition size_mnemonic_forwards (arg_ : word_width) 
: string :=
   
   match arg_ with | BYTE => "b" | HALF => "h" | WORD => "w" | DOUBLE => "d" end.

Definition size_mnemonic_backwards (arg_ : string) 
: M (word_width) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "b")) then returnm (BYTE  : word_width)
    else if ((generic_eq p0_ "h")) then returnm (HALF  : word_width)
    else if ((generic_eq p0_ "w")) then returnm (WORD  : word_width)
    else if ((generic_eq p0_ "d")) then returnm (DOUBLE  : word_width)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (word_width).

Definition size_mnemonic_forwards_matches (arg_ : word_width) 
: bool :=
   
   match arg_ with | BYTE => true | HALF => true | WORD => true | DOUBLE => true end.

Definition size_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "b")) then true
   else if ((generic_eq p0_ "h")) then true
   else if ((generic_eq p0_ "w")) then true
   else if ((generic_eq p0_ "d")) then true
   else false.

Definition _s36_ (_s37_ : string) 
: option string :=
   
   let _s38_ := _s37_ in
   if ((string_startswith _s38_ "d")) then
     match (string_drop _s38_ (projT1 (string_length "d"))) with | s_ => Some (s_) end
   else None.

Definition _s32_ (_s33_ : string) 
: option string :=
   
   let _s34_ := _s33_ in
   if ((string_startswith _s34_ "w")) then
     match (string_drop _s34_ (projT1 (string_length "w"))) with | s_ => Some (s_) end
   else None.

Definition _s28_ (_s29_ : string) 
: option string :=
   
   let _s30_ := _s29_ in
   if ((string_startswith _s30_ "h")) then
     match (string_drop _s30_ (projT1 (string_length "h"))) with | s_ => Some (s_) end
   else None.

Definition _s24_ (_s25_ : string) 
: option string :=
   
   let _s26_ := _s25_ in
   if ((string_startswith _s26_ "b")) then
     match (string_drop _s26_ (projT1 (string_length "b"))) with | s_ => Some (s_) end
   else None.

Definition size_mnemonic_matches_prefix (arg_ : string) 
: M (option ((word_width * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s27_ := arg_ in
   (if ((match (_s24_ _s27_) with | Some (s_) => true | _ => false end)) then
      (match (_s24_ _s27_) with
       | Some (s_) =>
          returnm ((Some
                      ((BYTE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s28_ _s27_) with | Some (s_) => true | _ => false end)) then
      (match (_s28_ _s27_) with
       | Some (s_) =>
          returnm ((Some
                      ((HALF, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s32_ _s27_) with | Some (s_) => true | _ => false end)) then
      (match (_s32_ _s27_) with
       | Some (s_) =>
          returnm ((Some
                      ((WORD, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s36_ _s27_) with | Some (s_) => true | _ => false end)) then
      (match (_s36_ _s27_) with
       | Some (s_) =>
          returnm ((Some
                      ((DOUBLE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((word_width * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((word_width * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((word_width * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((word_width * {n : Z & ArithFact (n >= 0)}))).

Definition word_width_bytes (width : word_width) 
: {s : Z & ArithFact (s = 1 \/ s = 2 \/ s = 4 \/ s = 8)} :=
   
   build_ex(match width with | BYTE => 1 | HALF => 2 | WORD => 4 | DOUBLE => 8 end).

Definition zero_reg : regtype := EXTZ 64 (vec_of_bits [B0;B0;B0;B0]  : mword 4).
Hint Unfold zero_reg : sail.
Definition RegStr (r : mword 64)  : string :=  string_of_bits r.

Definition regval_from_reg (r : mword 64)  : mword 64 :=  r.

Definition regval_into_reg (v : mword 64)  : mword 64 :=  v.

Definition rX (r : Z) `{ArithFact (0 <= r /\ r < 32)} 
: M (mword 64) :=
   
   let l__55 := r in
   (if sumbool_of_bool ((Z.eqb l__55 0)) then returnm (zero_reg  : mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 1)) then
      ((read_reg x1_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 2)) then
      ((read_reg x2_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 3)) then
      ((read_reg x3_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 4)) then
      ((read_reg x4_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 5)) then
      ((read_reg x5_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 6)) then
      ((read_reg x6_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 7)) then
      ((read_reg x7_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 8)) then
      ((read_reg x8_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 9)) then
      ((read_reg x9_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 10)) then
      ((read_reg x10_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 11)) then
      ((read_reg x11_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 12)) then
      ((read_reg x12_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 13)) then
      ((read_reg x13_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 14)) then
      ((read_reg x14_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 15)) then
      ((read_reg x15_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 16)) then
      ((read_reg x16_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 17)) then
      ((read_reg x17_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 18)) then
      ((read_reg x18_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 19)) then
      ((read_reg x19_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 20)) then
      ((read_reg x20_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 21)) then
      ((read_reg x21_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 22)) then
      ((read_reg x22_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 23)) then
      ((read_reg x23_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 24)) then
      ((read_reg x24_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 25)) then
      ((read_reg x25_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 26)) then
      ((read_reg x26_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 27)) then
      ((read_reg x27_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 28)) then
      ((read_reg x28_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 29)) then
      ((read_reg x29_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 30)) then
      ((read_reg x30_ref)  : M (mword 64))
       : M (mword 64)
    else if sumbool_of_bool ((Z.eqb l__55 31)) then
      ((read_reg x31_ref)  : M (mword 64))
       : M (mword 64)
    else assert_exp' false "invalid register number" >>= fun _ => exit tt) >>= fun v : regtype =>
   returnm ((regval_from_reg v)
    : mword 64).

Definition rvfi_wX (r : Z) (v : mword 64) `{ArithFact (0 <= r /\ r < 32)}  : unit :=  tt.

Definition wX (r : Z) (in_v : mword 64) `{ArithFact (0 <= r /\ r < 32)} 
: M (unit) :=
   
   let v := regval_into_reg in_v in
   let l__23 := r in
   (if sumbool_of_bool ((Z.eqb l__23 0)) then returnm (tt  : unit)
    else if sumbool_of_bool ((Z.eqb l__23 1)) then write_reg x1_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 2)) then write_reg x2_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 3)) then write_reg x3_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 4)) then write_reg x4_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 5)) then write_reg x5_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 6)) then write_reg x6_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 7)) then write_reg x7_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 8)) then write_reg x8_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 9)) then write_reg x9_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 10)) then write_reg x10_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 11)) then write_reg x11_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 12)) then write_reg x12_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 13)) then write_reg x13_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 14)) then write_reg x14_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 15)) then write_reg x15_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 16)) then write_reg x16_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 17)) then write_reg x17_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 18)) then write_reg x18_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 19)) then write_reg x19_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 20)) then write_reg x20_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 21)) then write_reg x21_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 22)) then write_reg x22_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 23)) then write_reg x23_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 24)) then write_reg x24_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 25)) then write_reg x25_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 26)) then write_reg x26_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 27)) then write_reg x27_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 28)) then write_reg x28_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 29)) then write_reg x29_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 30)) then write_reg x30_ref v  : M (unit)
    else if sumbool_of_bool ((Z.eqb l__23 31)) then write_reg x31_ref v  : M (unit)
    else assert_exp' false "invalid register number" >>= fun _ => exit tt) >>
   returnm ((if sumbool_of_bool ((projT1 (neq_int r 0))) then
               let '_ := (rvfi_wX r in_v)  : unit in
               if ((get_config_print_reg tt)) then
                 print_endline
                   (String.append "x"
                      (String.append (string_of_int r) (String.append " <- " (RegStr v))))
               else tt
             else tt)
    : unit).

Definition reg_name_abi (r : mword 5) 
: M (string) :=
   
   let b__0 := r in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))) then returnm ("zero"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))) then returnm ("ra"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5))) then returnm ("sp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5))) then returnm ("gp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))) then returnm ("tp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5))) then returnm ("t0"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5))) then returnm ("t1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5))) then returnm ("t2"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))) then returnm ("fp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5))) then returnm ("s1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5))) then returnm ("a0"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5))) then returnm ("a1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))) then returnm ("a2"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B1]  : mword 5))) then returnm ("a3"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B0]  : mword 5))) then returnm ("a4"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5))) then returnm ("a5"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))) then returnm ("a6"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5))) then returnm ("a7"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5))) then returnm ("s2"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5))) then returnm ("s3"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))) then returnm ("s4"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5))) then returnm ("s5"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5))) then returnm ("s6"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5))) then returnm ("s7"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))) then returnm ("s8"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5))) then returnm ("s9"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5))) then returnm ("s10"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5))) then returnm ("s11"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))) then returnm ("t3"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5))) then returnm ("t4"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0]  : mword 5))) then returnm ("t5"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B1]  : mword 5))) then returnm ("t6"  : string)
    else
      assert_exp' false "Pattern match failure at model/riscv_regs.sail 149:2 - 182:3" >>= fun _ =>
      exit tt)
    : M (string).

Definition reg_name_forwards (arg_ : mword 5) 
: M (string) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))) then returnm ("zero"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))) then returnm ("ra"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5))) then returnm ("sp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5))) then returnm ("gp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))) then returnm ("tp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5))) then returnm ("t0"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5))) then returnm ("t1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5))) then returnm ("t2"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))) then returnm ("fp"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5))) then returnm ("s1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5))) then returnm ("a0"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5))) then returnm ("a1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))) then returnm ("a2"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B1]  : mword 5))) then returnm ("a3"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B0]  : mword 5))) then returnm ("a4"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5))) then returnm ("a5"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))) then returnm ("a6"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5))) then returnm ("a7"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5))) then returnm ("s2"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5))) then returnm ("s3"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))) then returnm ("s4"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5))) then returnm ("s5"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5))) then returnm ("s6"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5))) then returnm ("s7"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))) then returnm ("s8"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5))) then returnm ("s9"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5))) then returnm ("s10"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5))) then returnm ("s11"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))) then returnm ("t3"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5))) then returnm ("t4"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0]  : mword 5))) then returnm ("t5"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B1]  : mword 5))) then returnm ("t6"  : string)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (string).

Definition reg_name_backwards (arg_ : string) 
: M (mword 5) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "zero")) then returnm ((vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)  : mword 5)
    else if ((generic_eq p0_ "ra")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "sp")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "gp")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "tp")) then
      returnm ((vec_of_bits [B0;B0;B1;B0;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "t0")) then
      returnm ((vec_of_bits [B0;B0;B1;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "t1")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "t2")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "fp")) then
      returnm ((vec_of_bits [B0;B1;B0;B0;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s1")) then
      returnm ((vec_of_bits [B0;B1;B0;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a0")) then
      returnm ((vec_of_bits [B0;B1;B0;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a1")) then
      returnm ((vec_of_bits [B0;B1;B0;B1;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a2")) then
      returnm ((vec_of_bits [B0;B1;B1;B0;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a3")) then
      returnm ((vec_of_bits [B0;B1;B1;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a4")) then
      returnm ((vec_of_bits [B0;B1;B1;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a5")) then
      returnm ((vec_of_bits [B0;B1;B1;B1;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a6")) then
      returnm ((vec_of_bits [B1;B0;B0;B0;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "a7")) then
      returnm ((vec_of_bits [B1;B0;B0;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s2")) then
      returnm ((vec_of_bits [B1;B0;B0;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s3")) then
      returnm ((vec_of_bits [B1;B0;B0;B1;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s4")) then
      returnm ((vec_of_bits [B1;B0;B1;B0;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s5")) then
      returnm ((vec_of_bits [B1;B0;B1;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s6")) then
      returnm ((vec_of_bits [B1;B0;B1;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s7")) then
      returnm ((vec_of_bits [B1;B0;B1;B1;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s8")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s9")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s10")) then
      returnm ((vec_of_bits [B1;B1;B0;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "s11")) then
      returnm ((vec_of_bits [B1;B1;B0;B1;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "t3")) then
      returnm ((vec_of_bits [B1;B1;B1;B0;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "t4")) then
      returnm ((vec_of_bits [B1;B1;B1;B0;B1]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "t5")) then
      returnm ((vec_of_bits [B1;B1;B1;B1;B0]  : mword 5)
       : mword 5)
    else if ((generic_eq p0_ "t6")) then
      returnm ((vec_of_bits [B1;B1;B1;B1;B1]  : mword 5)
       : mword 5)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 5).

Definition reg_name_forwards_matches (arg_ : mword 5) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B1;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B1;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B1;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B1]  : mword 5))) then true
   else false.

Definition reg_name_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "zero")) then true
   else if ((generic_eq p0_ "ra")) then true
   else if ((generic_eq p0_ "sp")) then true
   else if ((generic_eq p0_ "gp")) then true
   else if ((generic_eq p0_ "tp")) then true
   else if ((generic_eq p0_ "t0")) then true
   else if ((generic_eq p0_ "t1")) then true
   else if ((generic_eq p0_ "t2")) then true
   else if ((generic_eq p0_ "fp")) then true
   else if ((generic_eq p0_ "s1")) then true
   else if ((generic_eq p0_ "a0")) then true
   else if ((generic_eq p0_ "a1")) then true
   else if ((generic_eq p0_ "a2")) then true
   else if ((generic_eq p0_ "a3")) then true
   else if ((generic_eq p0_ "a4")) then true
   else if ((generic_eq p0_ "a5")) then true
   else if ((generic_eq p0_ "a6")) then true
   else if ((generic_eq p0_ "a7")) then true
   else if ((generic_eq p0_ "s2")) then true
   else if ((generic_eq p0_ "s3")) then true
   else if ((generic_eq p0_ "s4")) then true
   else if ((generic_eq p0_ "s5")) then true
   else if ((generic_eq p0_ "s6")) then true
   else if ((generic_eq p0_ "s7")) then true
   else if ((generic_eq p0_ "s8")) then true
   else if ((generic_eq p0_ "s9")) then true
   else if ((generic_eq p0_ "s10")) then true
   else if ((generic_eq p0_ "s11")) then true
   else if ((generic_eq p0_ "t3")) then true
   else if ((generic_eq p0_ "t4")) then true
   else if ((generic_eq p0_ "t5")) then true
   else if ((generic_eq p0_ "t6")) then true
   else false.

Definition _s164_ (_s165_ : string) 
: option string :=
   
   let _s166_ := _s165_ in
   if ((string_startswith _s166_ "t6")) then
     match (string_drop _s166_ (projT1 (string_length "t6"))) with | s_ => Some (s_) end
   else None.

Definition _s160_ (_s161_ : string) 
: option string :=
   
   let _s162_ := _s161_ in
   if ((string_startswith _s162_ "t5")) then
     match (string_drop _s162_ (projT1 (string_length "t5"))) with | s_ => Some (s_) end
   else None.

Definition _s156_ (_s157_ : string) 
: option string :=
   
   let _s158_ := _s157_ in
   if ((string_startswith _s158_ "t4")) then
     match (string_drop _s158_ (projT1 (string_length "t4"))) with | s_ => Some (s_) end
   else None.

Definition _s152_ (_s153_ : string) 
: option string :=
   
   let _s154_ := _s153_ in
   if ((string_startswith _s154_ "t3")) then
     match (string_drop _s154_ (projT1 (string_length "t3"))) with | s_ => Some (s_) end
   else None.

Definition _s148_ (_s149_ : string) 
: option string :=
   
   let _s150_ := _s149_ in
   if ((string_startswith _s150_ "s11")) then
     match (string_drop _s150_ (projT1 (string_length "s11"))) with | s_ => Some (s_) end
   else None.

Definition _s144_ (_s145_ : string) 
: option string :=
   
   let _s146_ := _s145_ in
   if ((string_startswith _s146_ "s10")) then
     match (string_drop _s146_ (projT1 (string_length "s10"))) with | s_ => Some (s_) end
   else None.

Definition _s140_ (_s141_ : string) 
: option string :=
   
   let _s142_ := _s141_ in
   if ((string_startswith _s142_ "s9")) then
     match (string_drop _s142_ (projT1 (string_length "s9"))) with | s_ => Some (s_) end
   else None.

Definition _s136_ (_s137_ : string) 
: option string :=
   
   let _s138_ := _s137_ in
   if ((string_startswith _s138_ "s8")) then
     match (string_drop _s138_ (projT1 (string_length "s8"))) with | s_ => Some (s_) end
   else None.

Definition _s132_ (_s133_ : string) 
: option string :=
   
   let _s134_ := _s133_ in
   if ((string_startswith _s134_ "s7")) then
     match (string_drop _s134_ (projT1 (string_length "s7"))) with | s_ => Some (s_) end
   else None.

Definition _s128_ (_s129_ : string) 
: option string :=
   
   let _s130_ := _s129_ in
   if ((string_startswith _s130_ "s6")) then
     match (string_drop _s130_ (projT1 (string_length "s6"))) with | s_ => Some (s_) end
   else None.

Definition _s124_ (_s125_ : string) 
: option string :=
   
   let _s126_ := _s125_ in
   if ((string_startswith _s126_ "s5")) then
     match (string_drop _s126_ (projT1 (string_length "s5"))) with | s_ => Some (s_) end
   else None.

Definition _s120_ (_s121_ : string) 
: option string :=
   
   let _s122_ := _s121_ in
   if ((string_startswith _s122_ "s4")) then
     match (string_drop _s122_ (projT1 (string_length "s4"))) with | s_ => Some (s_) end
   else None.

Definition _s116_ (_s117_ : string) 
: option string :=
   
   let _s118_ := _s117_ in
   if ((string_startswith _s118_ "s3")) then
     match (string_drop _s118_ (projT1 (string_length "s3"))) with | s_ => Some (s_) end
   else None.

Definition _s112_ (_s113_ : string) 
: option string :=
   
   let _s114_ := _s113_ in
   if ((string_startswith _s114_ "s2")) then
     match (string_drop _s114_ (projT1 (string_length "s2"))) with | s_ => Some (s_) end
   else None.

Definition _s108_ (_s109_ : string) 
: option string :=
   
   let _s110_ := _s109_ in
   if ((string_startswith _s110_ "a7")) then
     match (string_drop _s110_ (projT1 (string_length "a7"))) with | s_ => Some (s_) end
   else None.

Definition _s104_ (_s105_ : string) 
: option string :=
   
   let _s106_ := _s105_ in
   if ((string_startswith _s106_ "a6")) then
     match (string_drop _s106_ (projT1 (string_length "a6"))) with | s_ => Some (s_) end
   else None.

Definition _s100_ (_s101_ : string) 
: option string :=
   
   let _s102_ := _s101_ in
   if ((string_startswith _s102_ "a5")) then
     match (string_drop _s102_ (projT1 (string_length "a5"))) with | s_ => Some (s_) end
   else None.

Definition _s96_ (_s97_ : string) 
: option string :=
   
   let _s98_ := _s97_ in
   if ((string_startswith _s98_ "a4")) then
     match (string_drop _s98_ (projT1 (string_length "a4"))) with | s_ => Some (s_) end
   else None.

Definition _s92_ (_s93_ : string) 
: option string :=
   
   let _s94_ := _s93_ in
   if ((string_startswith _s94_ "a3")) then
     match (string_drop _s94_ (projT1 (string_length "a3"))) with | s_ => Some (s_) end
   else None.

Definition _s88_ (_s89_ : string) 
: option string :=
   
   let _s90_ := _s89_ in
   if ((string_startswith _s90_ "a2")) then
     match (string_drop _s90_ (projT1 (string_length "a2"))) with | s_ => Some (s_) end
   else None.

Definition _s84_ (_s85_ : string) 
: option string :=
   
   let _s86_ := _s85_ in
   if ((string_startswith _s86_ "a1")) then
     match (string_drop _s86_ (projT1 (string_length "a1"))) with | s_ => Some (s_) end
   else None.

Definition _s80_ (_s81_ : string) 
: option string :=
   
   let _s82_ := _s81_ in
   if ((string_startswith _s82_ "a0")) then
     match (string_drop _s82_ (projT1 (string_length "a0"))) with | s_ => Some (s_) end
   else None.

Definition _s76_ (_s77_ : string) 
: option string :=
   
   let _s78_ := _s77_ in
   if ((string_startswith _s78_ "s1")) then
     match (string_drop _s78_ (projT1 (string_length "s1"))) with | s_ => Some (s_) end
   else None.

Definition _s72_ (_s73_ : string) 
: option string :=
   
   let _s74_ := _s73_ in
   if ((string_startswith _s74_ "fp")) then
     match (string_drop _s74_ (projT1 (string_length "fp"))) with | s_ => Some (s_) end
   else None.

Definition _s68_ (_s69_ : string) 
: option string :=
   
   let _s70_ := _s69_ in
   if ((string_startswith _s70_ "t2")) then
     match (string_drop _s70_ (projT1 (string_length "t2"))) with | s_ => Some (s_) end
   else None.

Definition _s64_ (_s65_ : string) 
: option string :=
   
   let _s66_ := _s65_ in
   if ((string_startswith _s66_ "t1")) then
     match (string_drop _s66_ (projT1 (string_length "t1"))) with | s_ => Some (s_) end
   else None.

Definition _s60_ (_s61_ : string) 
: option string :=
   
   let _s62_ := _s61_ in
   if ((string_startswith _s62_ "t0")) then
     match (string_drop _s62_ (projT1 (string_length "t0"))) with | s_ => Some (s_) end
   else None.

Definition _s56_ (_s57_ : string) 
: option string :=
   
   let _s58_ := _s57_ in
   if ((string_startswith _s58_ "tp")) then
     match (string_drop _s58_ (projT1 (string_length "tp"))) with | s_ => Some (s_) end
   else None.

Definition _s52_ (_s53_ : string) 
: option string :=
   
   let _s54_ := _s53_ in
   if ((string_startswith _s54_ "gp")) then
     match (string_drop _s54_ (projT1 (string_length "gp"))) with | s_ => Some (s_) end
   else None.

Definition _s48_ (_s49_ : string) 
: option string :=
   
   let _s50_ := _s49_ in
   if ((string_startswith _s50_ "sp")) then
     match (string_drop _s50_ (projT1 (string_length "sp"))) with | s_ => Some (s_) end
   else None.

Definition _s44_ (_s45_ : string) 
: option string :=
   
   let _s46_ := _s45_ in
   if ((string_startswith _s46_ "ra")) then
     match (string_drop _s46_ (projT1 (string_length "ra"))) with | s_ => Some (s_) end
   else None.

Definition _s40_ (_s41_ : string) 
: option string :=
   
   let _s42_ := _s41_ in
   if ((string_startswith _s42_ "zero")) then
     match (string_drop _s42_ (projT1 (string_length "zero"))) with | s_ => Some (s_) end
   else None.

Definition reg_name_matches_prefix (arg_ : string) 
: M (option ((mword 5 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s43_ := arg_ in
   (if ((match (_s40_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s40_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s44_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s44_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s48_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s48_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s52_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s52_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s56_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s56_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s60_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s60_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s64_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s64_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s68_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s68_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s72_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s72_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s76_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s76_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s80_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s80_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s84_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s84_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s88_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s88_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s92_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s92_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s96_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s96_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s100_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s100_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s104_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s104_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s108_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s108_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s112_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s112_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s116_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s116_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s120_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s120_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s124_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s124_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s128_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s128_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s132_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s132_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s136_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s136_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s140_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s140_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s144_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s144_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s148_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s148_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s152_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s152_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B0;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s156_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s156_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B0;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s160_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s160_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B0]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s164_ _s43_) with | Some (s_) => true | _ => false end)) then
      (match (_s164_ _s43_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B1]  : mword 5), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 5 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 5 * {n : Z & ArithFact (n >= 0)}))).

Definition creg_name_forwards (arg_ : mword 3) 
: M (string) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then returnm ("s0"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then returnm ("s1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then returnm ("a0"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then returnm ("a1"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then returnm ("a2"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then returnm ("a3"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then returnm ("a4"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then returnm ("a5"  : string)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (string).

Definition creg_name_backwards (arg_ : string) 
: M (mword 3) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "s0")) then returnm ((vec_of_bits [B0;B0;B0]  : mword 3)  : mword 3)
    else if ((generic_eq p0_ "s1")) then returnm ((vec_of_bits [B0;B0;B1]  : mword 3)  : mword 3)
    else if ((generic_eq p0_ "a0")) then returnm ((vec_of_bits [B0;B1;B0]  : mword 3)  : mword 3)
    else if ((generic_eq p0_ "a1")) then returnm ((vec_of_bits [B0;B1;B1]  : mword 3)  : mword 3)
    else if ((generic_eq p0_ "a2")) then returnm ((vec_of_bits [B1;B0;B0]  : mword 3)  : mword 3)
    else if ((generic_eq p0_ "a3")) then returnm ((vec_of_bits [B1;B0;B1]  : mword 3)  : mword 3)
    else if ((generic_eq p0_ "a4")) then returnm ((vec_of_bits [B1;B1;B0]  : mword 3)  : mword 3)
    else if ((generic_eq p0_ "a5")) then returnm ((vec_of_bits [B1;B1;B1]  : mword 3)  : mword 3)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 3).

Definition creg_name_forwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then true
   else false.

Definition creg_name_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "s0")) then true
   else if ((generic_eq p0_ "s1")) then true
   else if ((generic_eq p0_ "a0")) then true
   else if ((generic_eq p0_ "a1")) then true
   else if ((generic_eq p0_ "a2")) then true
   else if ((generic_eq p0_ "a3")) then true
   else if ((generic_eq p0_ "a4")) then true
   else if ((generic_eq p0_ "a5")) then true
   else false.

Definition _s196_ (_s197_ : string) 
: option string :=
   
   let _s198_ := _s197_ in
   if ((string_startswith _s198_ "a5")) then
     match (string_drop _s198_ (projT1 (string_length "a5"))) with | s_ => Some (s_) end
   else None.

Definition _s192_ (_s193_ : string) 
: option string :=
   
   let _s194_ := _s193_ in
   if ((string_startswith _s194_ "a4")) then
     match (string_drop _s194_ (projT1 (string_length "a4"))) with | s_ => Some (s_) end
   else None.

Definition _s188_ (_s189_ : string) 
: option string :=
   
   let _s190_ := _s189_ in
   if ((string_startswith _s190_ "a3")) then
     match (string_drop _s190_ (projT1 (string_length "a3"))) with | s_ => Some (s_) end
   else None.

Definition _s184_ (_s185_ : string) 
: option string :=
   
   let _s186_ := _s185_ in
   if ((string_startswith _s186_ "a2")) then
     match (string_drop _s186_ (projT1 (string_length "a2"))) with | s_ => Some (s_) end
   else None.

Definition _s180_ (_s181_ : string) 
: option string :=
   
   let _s182_ := _s181_ in
   if ((string_startswith _s182_ "a1")) then
     match (string_drop _s182_ (projT1 (string_length "a1"))) with | s_ => Some (s_) end
   else None.

Definition _s176_ (_s177_ : string) 
: option string :=
   
   let _s178_ := _s177_ in
   if ((string_startswith _s178_ "a0")) then
     match (string_drop _s178_ (projT1 (string_length "a0"))) with | s_ => Some (s_) end
   else None.

Definition _s172_ (_s173_ : string) 
: option string :=
   
   let _s174_ := _s173_ in
   if ((string_startswith _s174_ "s1")) then
     match (string_drop _s174_ (projT1 (string_length "s1"))) with | s_ => Some (s_) end
   else None.

Definition _s168_ (_s169_ : string) 
: option string :=
   
   let _s170_ := _s169_ in
   if ((string_startswith _s170_ "s0")) then
     match (string_drop _s170_ (projT1 (string_length "s0"))) with | s_ => Some (s_) end
   else None.

Definition creg_name_matches_prefix (arg_ : string) 
: M (option ((mword 3 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s171_ := arg_ in
   (if ((match (_s168_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s168_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s172_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s172_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s176_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s176_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s180_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s180_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s184_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s184_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s188_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s188_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s192_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s192_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s196_ _s171_) with | Some (s_) => true | _ => false end)) then
      (match (_s196_ _s171_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1]  : mword 3), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 3 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 3 * {n : Z & ArithFact (n >= 0)}))).

Definition init_base_regs '(tt : unit) 
: M (unit) :=
   
   write_reg x1_ref zero_reg >>
   write_reg x2_ref zero_reg >>
   write_reg x3_ref zero_reg >>
   write_reg x4_ref zero_reg >>
   write_reg x5_ref zero_reg >>
   write_reg x6_ref zero_reg >>
   write_reg x7_ref zero_reg >>
   write_reg x8_ref zero_reg >>
   write_reg x9_ref zero_reg >>
   write_reg x10_ref zero_reg >>
   write_reg x11_ref zero_reg >>
   write_reg x12_ref zero_reg >>
   write_reg x13_ref zero_reg >>
   write_reg x14_ref zero_reg >>
   write_reg x15_ref zero_reg >>
   write_reg x16_ref zero_reg >>
   write_reg x17_ref zero_reg >>
   write_reg x18_ref zero_reg >>
   write_reg x19_ref zero_reg >>
   write_reg x20_ref zero_reg >>
   write_reg x21_ref zero_reg >>
   write_reg x22_ref zero_reg >>
   write_reg x23_ref zero_reg >>
   write_reg x24_ref zero_reg >>
   write_reg x25_ref zero_reg >>
   write_reg x26_ref zero_reg >>
   write_reg x27_ref zero_reg >>
   write_reg x28_ref zero_reg >>
   write_reg x29_ref zero_reg >>
   write_reg x30_ref zero_reg >> write_reg x31_ref zero_reg  : M (unit).

Definition get_arch_pc '(tt : unit) 
: M (mword 64) :=
   
   ((read_reg PC_ref)  : M (mword 64))
    : M (mword 64).

Definition get_next_pc '(tt : unit) 
: M (mword 64) :=
   
   ((read_reg nextPC_ref)  : M (mword 64))
    : M (mword 64).

Definition set_next_pc (pc : mword 64)  : M (unit) :=  write_reg nextPC_ref pc  : M (unit).

Definition tick_pc '(tt : unit) 
: M (unit) :=
   
   ((read_reg nextPC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   write_reg PC_ref w__0
    : M (unit).

Definition Mk_Misa (v : mword 64)  : Misa :=  {| Misa_Misa_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Misa_bits (v : Misa)  : mword 64 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 63 0.

Definition _set_Misa_bits (r_ref : register_ref regstate register_value Misa) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_bits (v : Misa) (x : mword 64) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Misa_MXL (v : Misa)  : mword 2 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 63 62.

Definition _set_Misa_MXL (r_ref : register_ref regstate register_value Misa) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 63 62 (subrange_vec_dec v 1 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_MXL (v : Misa) (x : mword 2) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 63 62 (subrange_vec_dec x 1 0)) ]}.

Definition _get_Misa_Z (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 25 25.

Definition _set_Misa_Z (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 25 25 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_Z (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 25 25 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_Y (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 24 24.

Definition _set_Misa_Y (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 24 24 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_Y (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 24 24 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_X (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 23 23.

Definition _set_Misa_X (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 23 23 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_X (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 23 23 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_W (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 22 22.

Definition _set_Misa_W (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 22 22 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_W (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 22 22 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_V (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 21 21.

Definition _set_Misa_V (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 21 21 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_V (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 21 21 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_U (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 20 20.

Definition _set_Misa_U (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 20 20 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_U (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 20 20 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_T (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 19 19.

Definition _set_Misa_T (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 19 19 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_T (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 19 19 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_S (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 18 18.

Definition _set_Misa_S (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 18 18 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_S (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 18 18 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_R (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 17 17.

Definition _set_Misa_R (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 17 17 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_R (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 17 17 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_Q (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 16 16.

Definition _set_Misa_Q (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 16 16 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_Q (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 16 16 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_P (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 15 15.

Definition _set_Misa_P (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 15 15 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_P (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 15 15 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_O (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 14 14.

Definition _set_Misa_O (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 14 14 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_O (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 14 14 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_N (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 13 13.

Definition _set_Misa_N (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 13 13 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_N (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 13 13 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_M (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 12 12.

Definition _set_Misa_M (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 12 12 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_M (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 12 12 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_L (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 11 11.

Definition _set_Misa_L (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 11 11 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_L (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 11 11 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_K (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 10 10.

Definition _set_Misa_K (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 10 10 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_K (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 10 10 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_J (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 9 9.

Definition _set_Misa_J (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 9 9 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_J (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 9 9 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_I (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 8 8.

Definition _set_Misa_I (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_I (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_H (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 7 7.

Definition _set_Misa_H (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_H (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_G (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 6 6.

Definition _set_Misa_G (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 6 6 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_G (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 6 6 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_F (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 5 5.

Definition _set_Misa_F (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_F (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_E (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 4 4.

Definition _set_Misa_E (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_E (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_D (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 3 3.

Definition _set_Misa_D (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 3 3 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_D (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 3 3 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_C (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 2 2.

Definition _set_Misa_C (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 2 2 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_C (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_B (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 1 1.

Definition _set_Misa_B (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_B (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Misa_A (v : Misa)  : mword 1 :=  subrange_vec_dec v.(Misa_Misa_chunk_0) 0 0.

Definition _set_Misa_A (r_ref : register_ref regstate register_value Misa) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Misa_Misa_chunk_0 :=
         (update_subrange_vec_dec r.(Misa_Misa_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Misa in
   write_reg r_ref r
    : M (unit).

Definition _update_Misa_A (v : Misa) (x : mword 1) 
: Misa :=
   
   {[ v with
     Misa_Misa_chunk_0 :=
       (update_subrange_vec_dec v.(Misa_Misa_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition legalize_misa (m : Misa) (v : mword 64) 
: M (Misa) :=
   
   (if ((sys_enable_writable_misa tt)) then
      let v := Mk_Misa v in
      (and_boolM (returnm ((eq_vec (_get_Misa_C v) ((bool_to_bits false)  : mword 1))  : bool))
         (((read_reg nextPC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
          (bit_to_bool (access_vec_dec w__0 1)) >>= fun w__1 : bool =>
          returnm ((Bool.eqb w__1 true)
           : bool))) >>= fun w__2 : bool =>
      returnm ((if sumbool_of_bool (w__2) then m
                else _update_Misa_C m (_get_Misa_C v))
       : Misa)
    else returnm (m  : Misa))
    : M (Misa).

Definition haveAtomics '(tt : unit) 
: M (bool) :=
   
   read_reg misa_ref >>= fun w__0 : Misa =>
   returnm ((eq_vec (_get_Misa_A w__0) ((bool_to_bits true)  : mword 1))
    : bool).

Definition haveRVC '(tt : unit) 
: M (bool) :=
   
   read_reg misa_ref >>= fun w__0 : Misa =>
   returnm ((eq_vec (_get_Misa_C w__0) ((bool_to_bits true)  : mword 1))
    : bool).

Definition haveMulDiv '(tt : unit) 
: M (bool) :=
   
   read_reg misa_ref >>= fun w__0 : Misa =>
   returnm ((eq_vec (_get_Misa_M w__0) ((bool_to_bits true)  : mword 1))
    : bool).

Definition haveSupMode '(tt : unit) 
: M (bool) :=
   
   read_reg misa_ref >>= fun w__0 : Misa =>
   returnm ((eq_vec (_get_Misa_S w__0) ((bool_to_bits true)  : mword 1))
    : bool).

Definition haveUsrMode '(tt : unit) 
: M (bool) :=
   
   read_reg misa_ref >>= fun w__0 : Misa =>
   returnm ((eq_vec (_get_Misa_U w__0) ((bool_to_bits true)  : mword 1))
    : bool).

Definition haveNExt '(tt : unit) 
: M (bool) :=
   
   read_reg misa_ref >>= fun w__0 : Misa =>
   returnm ((eq_vec (_get_Misa_N w__0) ((bool_to_bits true)  : mword 1))
    : bool).

Definition Mk_Mstatus (v : mword 64) 
: Mstatus :=
   
   {| Mstatus_Mstatus_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Mstatus_bits (v : Mstatus) 
: mword 64 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 63 0.

Definition _set_Mstatus_bits (r_ref : register_ref regstate register_value Mstatus) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_bits (v : Mstatus) (x : mword 64) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Mstatus_SD (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 63 63.

Definition _set_Mstatus_SD (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 63 63 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_SD (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 63 63 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_TSR (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 22 22.

Definition _set_Mstatus_TSR (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 22 22 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_TSR (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 22 22 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_TW (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 21 21.

Definition _set_Mstatus_TW (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 21 21 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_TW (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 21 21 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_TVM (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 20 20.

Definition _set_Mstatus_TVM (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 20 20 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_TVM (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 20 20 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_MXR (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 19 19.

Definition _set_Mstatus_MXR (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 19 19 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_MXR (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 19 19 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_SUM (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 18 18.

Definition _set_Mstatus_SUM (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 18 18 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_SUM (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 18 18 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_MPRV (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 17 17.

Definition _set_Mstatus_MPRV (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 17 17 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_MPRV (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 17 17 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_XS (v : Mstatus) 
: mword 2 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 16 15.

Definition _set_Mstatus_XS (r_ref : register_ref regstate register_value Mstatus) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 16 15 (subrange_vec_dec v 1 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_XS (v : Mstatus) (x : mword 2) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 16 15 (subrange_vec_dec x 1 0)) ]}.

Definition _get_Mstatus_FS (v : Mstatus) 
: mword 2 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 14 13.

Definition _set_Mstatus_FS (r_ref : register_ref regstate register_value Mstatus) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 14 13 (subrange_vec_dec v 1 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_FS (v : Mstatus) (x : mword 2) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 14 13 (subrange_vec_dec x 1 0)) ]}.

Definition _get_Mstatus_MPP (v : Mstatus) 
: mword 2 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 12 11.

Definition _set_Mstatus_MPP (r_ref : register_ref regstate register_value Mstatus) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 12 11 (subrange_vec_dec v 1 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_MPP (v : Mstatus) (x : mword 2) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 12 11 (subrange_vec_dec x 1 0)) ]}.

Definition _get_Mstatus_SPP (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 8 8.

Definition _set_Mstatus_SPP (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_SPP (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_MPIE (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 7 7.

Definition _set_Mstatus_MPIE (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_MPIE (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_SPIE (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 5 5.

Definition _set_Mstatus_SPIE (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_SPIE (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_UPIE (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 4 4.

Definition _set_Mstatus_UPIE (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_UPIE (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_MIE (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 3 3.

Definition _set_Mstatus_MIE (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 3 3 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_MIE (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 3 3 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_SIE (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 1 1.

Definition _set_Mstatus_SIE (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_SIE (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mstatus_UIE (v : Mstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 0 0.

Definition _set_Mstatus_UIE (r_ref : register_ref regstate register_value Mstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mstatus_Mstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Mstatus_Mstatus_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Mstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Mstatus_UIE (v : Mstatus) (x : mword 1) 
: Mstatus :=
   
   {[ v with
     Mstatus_Mstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Mstatus_Mstatus_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition effectivePrivilege (m : Mstatus) (priv : Privilege) 
: M (Privilege) :=
   
   (if ((eq_vec (_get_Mstatus_MPRV m) ((bool_to_bits true)  : mword 1))) then
      read_reg mstatus_ref >>= fun w__0 : Mstatus =>
      (privLevel_of_bits (_get_Mstatus_MPP w__0))
       : M (Privilege)
    else read_reg cur_privilege_ref  : M (Privilege))
    : M (Privilege).

Definition get_mstatus_SXL (m : Mstatus) 
: mword 2 :=
   
   subrange_vec_dec (_get_Mstatus_bits m) 35 34.

Definition set_mstatus_SXL (m : Mstatus) (a : mword 2) 
: Mstatus :=
   
   let m := update_subrange_vec_dec (_get_Mstatus_bits m) 35 34 a in
   Mk_Mstatus m.

Definition get_mstatus_UXL (m : Mstatus) 
: mword 2 :=
   
   subrange_vec_dec (_get_Mstatus_bits m) 33 32.

Definition set_mstatus_UXL (m : Mstatus) (a : mword 2) 
: Mstatus :=
   
   let m := update_subrange_vec_dec (_get_Mstatus_bits m) 33 32 a in
   Mk_Mstatus m.

Definition legalize_mstatus (o : Mstatus) (v : mword 64) 
: M (Mstatus) :=
   
   let m : Mstatus := Mk_Mstatus v in
   let m := _update_Mstatus_XS m (extStatus_to_bits Off) in
   (or_boolM
      ((extStatus_of_bits (_get_Mstatus_FS m)) >>= fun w__0 : ExtStatus =>
       returnm ((eq_vec (extStatus_to_bits w__0) ((extStatus_to_bits Dirty)  : mword 2))
        : bool))
      ((extStatus_of_bits (_get_Mstatus_XS m)) >>= fun w__1 : ExtStatus =>
       returnm ((eq_vec (extStatus_to_bits w__1) ((extStatus_to_bits Dirty)  : mword 2))
        : bool))) >>= fun w__2 : bool =>
   let m := _update_Mstatus_SD m ((bool_to_bits w__2)  : mword 1) in
   let m := set_mstatus_SXL m (get_mstatus_SXL o) in
   let m := set_mstatus_UXL m (get_mstatus_UXL o) in
   let m := _update_Mstatus_UPIE m ((bool_to_bits false)  : mword 1) in
   let m := _update_Mstatus_UIE m ((bool_to_bits false)  : mword 1) in
   returnm (m
    : Mstatus).

Definition cur_Architecture '(tt : unit) 
: M (Architecture) :=
   
   read_reg cur_privilege_ref >>= fun w__0 : Privilege =>
   (match w__0 with
    | Machine => read_reg misa_ref >>= fun w__1 : Misa => returnm ((_get_Misa_MXL w__1)  : mword 2)
    | Supervisor =>
       read_reg mstatus_ref >>= fun w__2 : Mstatus => returnm ((get_mstatus_SXL w__2)  : mword 2)
    | User =>
       read_reg mstatus_ref >>= fun w__3 : Mstatus => returnm ((get_mstatus_UXL w__3)  : mword 2)
    end) >>= fun a : arch_xlen =>
   (match (architecture a) with
    | Some (a) => returnm (a  : Architecture)
    | None => (internal_error "Invalid current architecture")  : M (Architecture)
    end)
    : M (Architecture).

Definition in32BitMode '(tt : unit) 
: M (bool) :=
   
   (cur_Architecture tt) >>= fun w__0 : Architecture => returnm ((generic_eq w__0 RV32)  : bool).

Definition Mk_Minterrupts (v : mword 64) 
: Minterrupts :=
   
   {| Minterrupts_Minterrupts_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Minterrupts_bits (v : Minterrupts) 
: mword 64 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 63 0.

Definition _set_Minterrupts_bits
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_bits (v : Minterrupts) (x : mword 64) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Minterrupts_MEI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 11 11.

Definition _set_Minterrupts_MEI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 11 11 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_MEI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 11 11 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_SEI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 9 9.

Definition _set_Minterrupts_SEI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 9 9 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_SEI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 9 9 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_UEI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 8 8.

Definition _set_Minterrupts_UEI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_UEI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_MTI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 7 7.

Definition _set_Minterrupts_MTI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_MTI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_STI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 5 5.

Definition _set_Minterrupts_STI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_STI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_UTI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 4 4.

Definition _set_Minterrupts_UTI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_UTI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_MSI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 3 3.

Definition _set_Minterrupts_MSI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 3 3 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_MSI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 3 3 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_SSI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 1 1.

Definition _set_Minterrupts_SSI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_SSI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Minterrupts_USI (v : Minterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 0 0.

Definition _set_Minterrupts_USI
(r_ref : register_ref regstate register_value Minterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Minterrupts_Minterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Minterrupts_Minterrupts_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Minterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Minterrupts_USI (v : Minterrupts) (x : mword 1) 
: Minterrupts :=
   
   {[ v with
     Minterrupts_Minterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Minterrupts_Minterrupts_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition legalize_mip (o : Minterrupts) (v : mword 64) 
: M (Minterrupts) :=
   
   let v := Mk_Minterrupts v in
   let m := _update_Minterrupts_SEI o (_get_Minterrupts_SEI v) in
   let m := _update_Minterrupts_STI m (_get_Minterrupts_STI v) in
   let m := _update_Minterrupts_SSI m (_get_Minterrupts_SSI v) in
   (haveUsrMode tt) >>= fun w__0 : bool =>
   returnm ((if sumbool_of_bool (w__0) then
               let m := _update_Minterrupts_UEI m (_get_Minterrupts_UEI v) in
               let m := _update_Minterrupts_UTI m (_get_Minterrupts_UTI v) in
               _update_Minterrupts_USI m (_get_Minterrupts_USI v)
             else m)
    : Minterrupts).

Definition legalize_mie (o : Minterrupts) (v : mword 64) 
: M (Minterrupts) :=
   
   let v := Mk_Minterrupts v in
   let m := _update_Minterrupts_MEI o (_get_Minterrupts_MEI v) in
   let m := _update_Minterrupts_MTI m (_get_Minterrupts_MTI v) in
   let m := _update_Minterrupts_MSI m (_get_Minterrupts_MSI v) in
   let m := _update_Minterrupts_SEI m (_get_Minterrupts_SEI v) in
   let m := _update_Minterrupts_STI m (_get_Minterrupts_STI v) in
   let m := _update_Minterrupts_SSI m (_get_Minterrupts_SSI v) in
   (haveUsrMode tt) >>= fun w__0 : bool =>
   returnm ((if sumbool_of_bool (w__0) then
               let m := _update_Minterrupts_UEI m (_get_Minterrupts_UEI v) in
               let m := _update_Minterrupts_UTI m (_get_Minterrupts_UTI v) in
               _update_Minterrupts_USI m (_get_Minterrupts_USI v)
             else m)
    : Minterrupts).

Definition legalize_mideleg (o : Minterrupts) (v : mword 64) 
: Minterrupts :=
   
   let m := Mk_Minterrupts v in
   let m := _update_Minterrupts_MEI m ((bool_to_bits false)  : mword 1) in
   let m := _update_Minterrupts_MTI m ((bool_to_bits false)  : mword 1) in
   _update_Minterrupts_MSI m ((bool_to_bits false)  : mword 1).

Definition Mk_Medeleg (v : mword 64) 
: Medeleg :=
   
   {| Medeleg_Medeleg_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Medeleg_bits (v : Medeleg) 
: mword 64 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 63 0.

Definition _set_Medeleg_bits (r_ref : register_ref regstate register_value Medeleg) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_bits (v : Medeleg) (x : mword 64) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Medeleg_SAMO_Page_Fault (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 15 15.

Definition _set_Medeleg_SAMO_Page_Fault
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 15 15 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_SAMO_Page_Fault (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 15 15 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Load_Page_Fault (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 13 13.

Definition _set_Medeleg_Load_Page_Fault
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 13 13 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Load_Page_Fault (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 13 13 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Fetch_Page_Fault (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 12 12.

Definition _set_Medeleg_Fetch_Page_Fault
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 12 12 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Fetch_Page_Fault (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 12 12 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_MEnvCall (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 10 10.

Definition _set_Medeleg_MEnvCall
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 10 10 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_MEnvCall (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 10 10 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_SEnvCall (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 9 9.

Definition _set_Medeleg_SEnvCall
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 9 9 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_SEnvCall (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 9 9 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_UEnvCall (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 8 8.

Definition _set_Medeleg_UEnvCall
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_UEnvCall (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_SAMO_Access_Fault (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 7 7.

Definition _set_Medeleg_SAMO_Access_Fault
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_SAMO_Access_Fault (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_SAMO_Addr_Align (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 6 6.

Definition _set_Medeleg_SAMO_Addr_Align
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 6 6 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_SAMO_Addr_Align (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 6 6 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Load_Access_Fault (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 5 5.

Definition _set_Medeleg_Load_Access_Fault
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Load_Access_Fault (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Load_Addr_Align (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 4 4.

Definition _set_Medeleg_Load_Addr_Align
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Load_Addr_Align (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Breakpoint (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 3 3.

Definition _set_Medeleg_Breakpoint
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 3 3 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Breakpoint (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 3 3 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Illegal_Instr (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 2 2.

Definition _set_Medeleg_Illegal_Instr
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 2 2 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Illegal_Instr (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Fetch_Access_Fault (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 1 1.

Definition _set_Medeleg_Fetch_Access_Fault
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Fetch_Access_Fault (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Medeleg_Fetch_Addr_Align (v : Medeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 0 0.

Definition _set_Medeleg_Fetch_Addr_Align
(r_ref : register_ref regstate register_value Medeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Medeleg_Medeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Medeleg_Medeleg_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Medeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Medeleg_Fetch_Addr_Align (v : Medeleg) (x : mword 1) 
: Medeleg :=
   
   {[ v with
     Medeleg_Medeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Medeleg_Medeleg_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition legalize_medeleg (o : Medeleg) (v : mword 64) 
: Medeleg :=
   
   let m := Mk_Medeleg v in
   _update_Medeleg_MEnvCall m ((bool_to_bits false)  : mword 1).

Definition Mk_Mtvec (v : mword 64) 
: Mtvec :=
   
   {| Mtvec_Mtvec_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Mtvec_bits (v : Mtvec) 
: mword 64 :=
   
   subrange_vec_dec v.(Mtvec_Mtvec_chunk_0) 63 0.

Definition _set_Mtvec_bits (r_ref : register_ref regstate register_value Mtvec) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mtvec_Mtvec_chunk_0 :=
         (update_subrange_vec_dec r.(Mtvec_Mtvec_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Mtvec in
   write_reg r_ref r
    : M (unit).

Definition _update_Mtvec_bits (v : Mtvec) (x : mword 64) 
: Mtvec :=
   
   {[ v with
     Mtvec_Mtvec_chunk_0 :=
       (update_subrange_vec_dec v.(Mtvec_Mtvec_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Mtvec_Base (v : Mtvec) 
: mword 62 :=
   
   subrange_vec_dec v.(Mtvec_Mtvec_chunk_0) 63 2.

Definition _set_Mtvec_Base (r_ref : register_ref regstate register_value Mtvec) (v : mword 62) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mtvec_Mtvec_chunk_0 :=
         (update_subrange_vec_dec r.(Mtvec_Mtvec_chunk_0) 63 2 (subrange_vec_dec v 61 0)) ]}
      : Mtvec in
   write_reg r_ref r
    : M (unit).

Definition _update_Mtvec_Base (v : Mtvec) (x : mword 62) 
: Mtvec :=
   
   {[ v with
     Mtvec_Mtvec_chunk_0 :=
       (update_subrange_vec_dec v.(Mtvec_Mtvec_chunk_0) 63 2 (subrange_vec_dec x 61 0)) ]}.

Definition _get_Mtvec_Mode (v : Mtvec)  : mword 2 :=  subrange_vec_dec v.(Mtvec_Mtvec_chunk_0) 1 0.

Definition _set_Mtvec_Mode (r_ref : register_ref regstate register_value Mtvec) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mtvec_Mtvec_chunk_0 :=
         (update_subrange_vec_dec r.(Mtvec_Mtvec_chunk_0) 1 0 (subrange_vec_dec v 1 0)) ]}
      : Mtvec in
   write_reg r_ref r
    : M (unit).

Definition _update_Mtvec_Mode (v : Mtvec) (x : mword 2) 
: Mtvec :=
   
   {[ v with
     Mtvec_Mtvec_chunk_0 :=
       (update_subrange_vec_dec v.(Mtvec_Mtvec_chunk_0) 1 0 (subrange_vec_dec x 1 0)) ]}.

Definition legalize_tvec (o : Mtvec) (v : mword 64) 
: Mtvec :=
   
   let v := Mk_Mtvec v in
   match (trapVectorMode_of_bits (_get_Mtvec_Mode v)) with
   | TV_Direct => v
   | TV_Vector => v
   | _ => _update_Mtvec_Mode v (_get_Mtvec_Mode o)
   end.

Definition Mk_Mcause (v : mword 64) 
: Mcause :=
   
   {| Mcause_Mcause_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Mcause_bits (v : Mcause) 
: mword 64 :=
   
   subrange_vec_dec v.(Mcause_Mcause_chunk_0) 63 0.

Definition _set_Mcause_bits (r_ref : register_ref regstate register_value Mcause) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mcause_Mcause_chunk_0 :=
         (update_subrange_vec_dec r.(Mcause_Mcause_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Mcause in
   write_reg r_ref r
    : M (unit).

Definition _update_Mcause_bits (v : Mcause) (x : mword 64) 
: Mcause :=
   
   {[ v with
     Mcause_Mcause_chunk_0 :=
       (update_subrange_vec_dec v.(Mcause_Mcause_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Mcause_IsInterrupt (v : Mcause) 
: mword 1 :=
   
   subrange_vec_dec v.(Mcause_Mcause_chunk_0) 63 63.

Definition _set_Mcause_IsInterrupt
(r_ref : register_ref regstate register_value Mcause) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mcause_Mcause_chunk_0 :=
         (update_subrange_vec_dec r.(Mcause_Mcause_chunk_0) 63 63 (subrange_vec_dec v 0 0)) ]}
      : Mcause in
   write_reg r_ref r
    : M (unit).

Definition _update_Mcause_IsInterrupt (v : Mcause) (x : mword 1) 
: Mcause :=
   
   {[ v with
     Mcause_Mcause_chunk_0 :=
       (update_subrange_vec_dec v.(Mcause_Mcause_chunk_0) 63 63 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Mcause_Cause (v : Mcause) 
: mword 63 :=
   
   subrange_vec_dec v.(Mcause_Mcause_chunk_0) 62 0.

Definition _set_Mcause_Cause (r_ref : register_ref regstate register_value Mcause) (v : mword 63) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Mcause_Mcause_chunk_0 :=
         (update_subrange_vec_dec r.(Mcause_Mcause_chunk_0) 62 0 (subrange_vec_dec v 62 0)) ]}
      : Mcause in
   write_reg r_ref r
    : M (unit).

Definition _update_Mcause_Cause (v : Mcause) (x : mword 63) 
: Mcause :=
   
   {[ v with
     Mcause_Mcause_chunk_0 :=
       (update_subrange_vec_dec v.(Mcause_Mcause_chunk_0) 62 0 (subrange_vec_dec x 62 0)) ]}.

Definition tvec_addr (m : Mtvec) (c : Mcause) 
: option (mword 64) :=
   
   let base : xlenbits := concat_vec (_get_Mtvec_Base m) (vec_of_bits [B0;B0]  : mword 2) in
   match (trapVectorMode_of_bits (_get_Mtvec_Mode m)) with
   | TV_Direct => Some (base)
   | TV_Vector =>
      if ((eq_vec (_get_Mcause_IsInterrupt c) ((bool_to_bits true)  : mword 1))) then
        Some
          (add_vec base (shiftl (EXTZ 64 (_get_Mcause_Cause c)) 2))
      else Some (base)
   | TV_Reserved => None
   end.

Definition legalize_xepc (v : mword 64) 
: M (mword 64) :=
   
   (or_boolM (returnm ((sys_enable_writable_misa tt)  : bool))
      (read_reg misa_ref >>= fun w__0 : Misa =>
       returnm ((eq_vec (_get_Misa_C w__0) ((bool_to_bits true)  : mword 1))
        : bool))) >>= fun w__1 : bool =>
   returnm ((if sumbool_of_bool (w__1) then update_vec_dec v 0 B0
             else and_vec v (EXTS 64 (vec_of_bits [B1;B0;B0]  : mword 3)))
    : mword 64).

Definition pc_alignment_mask '(tt : unit) 
: M (mword 64) :=
   
   read_reg misa_ref >>= fun w__0 : Misa =>
   returnm ((not_vec
               (EXTZ 64
                  (if ((eq_vec (_get_Misa_C w__0) ((bool_to_bits true)  : mword 1))) then
                     (vec_of_bits [B0;B0]  : mword 2)
                   else (vec_of_bits [B1;B0]  : mword 2))))
    : mword 64).

Definition Mk_Counteren (v : mword 32) 
: Counteren :=
   
   {| Counteren_Counteren_chunk_0 := (subrange_vec_dec v 31 0) |}.

Definition _get_Counteren_bits (v : Counteren) 
: mword 32 :=
   
   subrange_vec_dec v.(Counteren_Counteren_chunk_0) 31 0.

Definition _set_Counteren_bits
(r_ref : register_ref regstate register_value Counteren) (v : mword 32) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Counteren_Counteren_chunk_0 :=
         (update_subrange_vec_dec r.(Counteren_Counteren_chunk_0) 31 0 (subrange_vec_dec v 31 0)) ]}
      : Counteren in
   write_reg r_ref r
    : M (unit).

Definition _update_Counteren_bits (v : Counteren) (x : mword 32) 
: Counteren :=
   
   {[ v with
     Counteren_Counteren_chunk_0 :=
       (update_subrange_vec_dec v.(Counteren_Counteren_chunk_0) 31 0 (subrange_vec_dec x 31 0)) ]}.

Definition _get_Counteren_HPM (v : Counteren) 
: mword 29 :=
   
   subrange_vec_dec v.(Counteren_Counteren_chunk_0) 31 3.

Definition _set_Counteren_HPM
(r_ref : register_ref regstate register_value Counteren) (v : mword 29) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Counteren_Counteren_chunk_0 :=
         (update_subrange_vec_dec r.(Counteren_Counteren_chunk_0) 31 3 (subrange_vec_dec v 28 0)) ]}
      : Counteren in
   write_reg r_ref r
    : M (unit).

Definition _update_Counteren_HPM (v : Counteren) (x : mword 29) 
: Counteren :=
   
   {[ v with
     Counteren_Counteren_chunk_0 :=
       (update_subrange_vec_dec v.(Counteren_Counteren_chunk_0) 31 3 (subrange_vec_dec x 28 0)) ]}.

Definition _get_Counteren_IR (v : Counteren) 
: mword 1 :=
   
   subrange_vec_dec v.(Counteren_Counteren_chunk_0) 2 2.

Definition _set_Counteren_IR (r_ref : register_ref regstate register_value Counteren) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Counteren_Counteren_chunk_0 :=
         (update_subrange_vec_dec r.(Counteren_Counteren_chunk_0) 2 2 (subrange_vec_dec v 0 0)) ]}
      : Counteren in
   write_reg r_ref r
    : M (unit).

Definition _update_Counteren_IR (v : Counteren) (x : mword 1) 
: Counteren :=
   
   {[ v with
     Counteren_Counteren_chunk_0 :=
       (update_subrange_vec_dec v.(Counteren_Counteren_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Counteren_TM (v : Counteren) 
: mword 1 :=
   
   subrange_vec_dec v.(Counteren_Counteren_chunk_0) 1 1.

Definition _set_Counteren_TM (r_ref : register_ref regstate register_value Counteren) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Counteren_Counteren_chunk_0 :=
         (update_subrange_vec_dec r.(Counteren_Counteren_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Counteren in
   write_reg r_ref r
    : M (unit).

Definition _update_Counteren_TM (v : Counteren) (x : mword 1) 
: Counteren :=
   
   {[ v with
     Counteren_Counteren_chunk_0 :=
       (update_subrange_vec_dec v.(Counteren_Counteren_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Counteren_CY (v : Counteren) 
: mword 1 :=
   
   subrange_vec_dec v.(Counteren_Counteren_chunk_0) 0 0.

Definition _set_Counteren_CY (r_ref : register_ref regstate register_value Counteren) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Counteren_Counteren_chunk_0 :=
         (update_subrange_vec_dec r.(Counteren_Counteren_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Counteren in
   write_reg r_ref r
    : M (unit).

Definition _update_Counteren_CY (v : Counteren) (x : mword 1) 
: Counteren :=
   
   {[ v with
     Counteren_Counteren_chunk_0 :=
       (update_subrange_vec_dec v.(Counteren_Counteren_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition legalize_mcounteren (c : Counteren) (v : mword 64) 
: M (Counteren) :=
   
   (cast_unit_vec (access_vec_dec v 2)) >>= fun w__0 : mword 1 =>
   let c := _update_Counteren_IR c (w__0  : mword 1) in
   (cast_unit_vec (access_vec_dec v 1)) >>= fun w__1 : mword 1 =>
   let c := _update_Counteren_TM c (w__1  : mword 1) in
   (cast_unit_vec (access_vec_dec v 0)) >>= fun w__2 : mword 1 =>
   let c := _update_Counteren_CY c (w__2  : mword 1) in
   returnm (c
    : Counteren).

Definition legalize_scounteren (c : Counteren) (v : mword 64) 
: M (Counteren) :=
   
   (cast_unit_vec (access_vec_dec v 2)) >>= fun w__0 : mword 1 =>
   let c := _update_Counteren_IR c (w__0  : mword 1) in
   (cast_unit_vec (access_vec_dec v 1)) >>= fun w__1 : mword 1 =>
   let c := _update_Counteren_TM c (w__1  : mword 1) in
   (cast_unit_vec (access_vec_dec v 0)) >>= fun w__2 : mword 1 =>
   let c := _update_Counteren_CY c (w__2  : mword 1) in
   returnm (c
    : Counteren).

Definition retire_instruction '(tt : unit) 
: M (unit) :=
   
   read_reg minstret_written_ref >>= fun w__0 : bool =>
   (if ((Bool.eqb w__0 true)) then write_reg minstret_written_ref false  : M (unit)
    else
      ((read_reg minstret_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
      write_reg minstret_ref (add_vec_int w__1 1)
       : M (unit))
    : M (unit).

Definition Mk_Sstatus (v : mword 64) 
: Sstatus :=
   
   {| Sstatus_Sstatus_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Sstatus_bits (v : Sstatus) 
: mword 64 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 63 0.

Definition _set_Sstatus_bits (r_ref : register_ref regstate register_value Sstatus) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_bits (v : Sstatus) (x : mword 64) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Sstatus_SD (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 63 63.

Definition _set_Sstatus_SD (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 63 63 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_SD (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 63 63 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sstatus_MXR (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 19 19.

Definition _set_Sstatus_MXR (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 19 19 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_MXR (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 19 19 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sstatus_SUM (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 18 18.

Definition _set_Sstatus_SUM (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 18 18 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_SUM (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 18 18 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sstatus_XS (v : Sstatus) 
: mword 2 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 16 15.

Definition _set_Sstatus_XS (r_ref : register_ref regstate register_value Sstatus) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 16 15 (subrange_vec_dec v 1 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_XS (v : Sstatus) (x : mword 2) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 16 15 (subrange_vec_dec x 1 0)) ]}.

Definition _get_Sstatus_FS (v : Sstatus) 
: mword 2 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 14 13.

Definition _set_Sstatus_FS (r_ref : register_ref regstate register_value Sstatus) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 14 13 (subrange_vec_dec v 1 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_FS (v : Sstatus) (x : mword 2) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 14 13 (subrange_vec_dec x 1 0)) ]}.

Definition _get_Sstatus_SPP (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 8 8.

Definition _set_Sstatus_SPP (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_SPP (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sstatus_SPIE (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 5 5.

Definition _set_Sstatus_SPIE (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_SPIE (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sstatus_UPIE (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 4 4.

Definition _set_Sstatus_UPIE (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_UPIE (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sstatus_SIE (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 1 1.

Definition _set_Sstatus_SIE (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_SIE (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sstatus_UIE (v : Sstatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 0 0.

Definition _set_Sstatus_UIE (r_ref : register_ref regstate register_value Sstatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sstatus_Sstatus_chunk_0 :=
         (update_subrange_vec_dec r.(Sstatus_Sstatus_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Sstatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Sstatus_UIE (v : Sstatus) (x : mword 1) 
: Sstatus :=
   
   {[ v with
     Sstatus_Sstatus_chunk_0 :=
       (update_subrange_vec_dec v.(Sstatus_Sstatus_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition get_sstatus_UXL (s : Sstatus) 
: mword 2 :=
   
   let m := Mk_Mstatus (_get_Sstatus_bits s) in
   get_mstatus_UXL m.

Definition set_sstatus_UXL (s : Sstatus) (a : mword 2) 
: Sstatus :=
   
   let m := Mk_Mstatus (_get_Sstatus_bits s) in
   let m := set_mstatus_UXL m a in
   Mk_Sstatus (_get_Mstatus_bits m).

Definition lower_mstatus (m : Mstatus) 
: Sstatus :=
   
   let s := Mk_Sstatus (EXTZ 64 (vec_of_bits [B0]  : mword 1)) in
   let s := _update_Sstatus_SD s (_get_Mstatus_SD m) in
   let s := set_sstatus_UXL s (get_mstatus_UXL m) in
   let s := _update_Sstatus_MXR s (_get_Mstatus_MXR m) in
   let s := _update_Sstatus_SUM s (_get_Mstatus_SUM m) in
   let s := _update_Sstatus_XS s (_get_Mstatus_XS m) in
   let s := _update_Sstatus_FS s (_get_Mstatus_FS m) in
   let s := _update_Sstatus_SPP s (_get_Mstatus_SPP m) in
   let s := _update_Sstatus_SPIE s (_get_Mstatus_SPIE m) in
   let s := _update_Sstatus_UPIE s (_get_Mstatus_UPIE m) in
   let s := _update_Sstatus_SIE s (_get_Mstatus_SIE m) in
   _update_Sstatus_UIE s (_get_Mstatus_UIE m).

Definition lift_sstatus (m : Mstatus) (s : Sstatus) 
: M (Mstatus) :=
   
   let m := _update_Mstatus_MXR m (_get_Sstatus_MXR s) in
   let m := _update_Mstatus_SUM m (_get_Sstatus_SUM s) in
   let m := _update_Mstatus_XS m (_get_Sstatus_XS s) in
   let m := _update_Mstatus_FS m (_get_Sstatus_FS s) in
   (or_boolM
      ((extStatus_of_bits (_get_Mstatus_FS m)) >>= fun w__0 : ExtStatus =>
       returnm ((eq_vec (extStatus_to_bits w__0) ((extStatus_to_bits Dirty)  : mword 2))
        : bool))
      ((extStatus_of_bits (_get_Mstatus_XS m)) >>= fun w__1 : ExtStatus =>
       returnm ((eq_vec (extStatus_to_bits w__1) ((extStatus_to_bits Dirty)  : mword 2))
        : bool))) >>= fun w__2 : bool =>
   let m := _update_Mstatus_SD m ((bool_to_bits w__2)  : mword 1) in
   let m := _update_Mstatus_SPP m (_get_Sstatus_SPP s) in
   let m := _update_Mstatus_SPIE m (_get_Sstatus_SPIE s) in
   let m := _update_Mstatus_UPIE m (_get_Sstatus_UPIE s) in
   let m := _update_Mstatus_SIE m (_get_Sstatus_SIE s) in
   let m := _update_Mstatus_UIE m (_get_Sstatus_UIE s) in
   returnm (m
    : Mstatus).

Definition legalize_sstatus (m : Mstatus) (v : mword 64) 
: M (Mstatus) :=
   
   (lift_sstatus m (Mk_Sstatus v))
    : M (Mstatus).

Definition Mk_Sedeleg (v : mword 64) 
: Sedeleg :=
   
   {| Sedeleg_Sedeleg_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Sedeleg_bits (v : Sedeleg) 
: mword 64 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 63 0.

Definition _set_Sedeleg_bits (r_ref : register_ref regstate register_value Sedeleg) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_bits (v : Sedeleg) (x : mword 64) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Sedeleg_UEnvCall (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 8 8.

Definition _set_Sedeleg_UEnvCall
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_UEnvCall (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_SAMO_Access_Fault (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 7 7.

Definition _set_Sedeleg_SAMO_Access_Fault
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_SAMO_Access_Fault (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_SAMO_Addr_Align (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 6 6.

Definition _set_Sedeleg_SAMO_Addr_Align
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 6 6 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_SAMO_Addr_Align (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 6 6 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_Load_Access_Fault (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 5 5.

Definition _set_Sedeleg_Load_Access_Fault
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_Load_Access_Fault (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_Load_Addr_Align (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 4 4.

Definition _set_Sedeleg_Load_Addr_Align
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_Load_Addr_Align (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_Breakpoint (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 3 3.

Definition _set_Sedeleg_Breakpoint
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 3 3 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_Breakpoint (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 3 3 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_Illegal_Instr (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 2 2.

Definition _set_Sedeleg_Illegal_Instr
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 2 2 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_Illegal_Instr (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_Fetch_Access_Fault (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 1 1.

Definition _set_Sedeleg_Fetch_Access_Fault
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_Fetch_Access_Fault (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sedeleg_Fetch_Addr_Align (v : Sedeleg) 
: mword 1 :=
   
   subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 0 0.

Definition _set_Sedeleg_Fetch_Addr_Align
(r_ref : register_ref regstate register_value Sedeleg) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sedeleg_Sedeleg_chunk_0 :=
         (update_subrange_vec_dec r.(Sedeleg_Sedeleg_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Sedeleg in
   write_reg r_ref r
    : M (unit).

Definition _update_Sedeleg_Fetch_Addr_Align (v : Sedeleg) (x : mword 1) 
: Sedeleg :=
   
   {[ v with
     Sedeleg_Sedeleg_chunk_0 :=
       (update_subrange_vec_dec v.(Sedeleg_Sedeleg_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition legalize_sedeleg (s : Sedeleg) (v : mword 64) 
: Sedeleg :=
   
   Mk_Sedeleg (EXTZ 64 (subrange_vec_dec v 8 0)).

Definition Mk_Sinterrupts (v : mword 64) 
: Sinterrupts :=
   
   {| Sinterrupts_Sinterrupts_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Sinterrupts_bits (v : Sinterrupts) 
: mword 64 :=
   
   subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 63 0.

Definition _set_Sinterrupts_bits
(r_ref : register_ref regstate register_value Sinterrupts) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sinterrupts_Sinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Sinterrupts_Sinterrupts_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Sinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Sinterrupts_bits (v : Sinterrupts) (x : mword 64) 
: Sinterrupts :=
   
   {[ v with
     Sinterrupts_Sinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Sinterrupts_SEI (v : Sinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 9 9.

Definition _set_Sinterrupts_SEI
(r_ref : register_ref regstate register_value Sinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sinterrupts_Sinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Sinterrupts_Sinterrupts_chunk_0) 9 9 (subrange_vec_dec v 0 0)) ]}
      : Sinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Sinterrupts_SEI (v : Sinterrupts) (x : mword 1) 
: Sinterrupts :=
   
   {[ v with
     Sinterrupts_Sinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 9 9 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sinterrupts_UEI (v : Sinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 8 8.

Definition _set_Sinterrupts_UEI
(r_ref : register_ref regstate register_value Sinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sinterrupts_Sinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Sinterrupts_Sinterrupts_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Sinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Sinterrupts_UEI (v : Sinterrupts) (x : mword 1) 
: Sinterrupts :=
   
   {[ v with
     Sinterrupts_Sinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sinterrupts_STI (v : Sinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 5 5.

Definition _set_Sinterrupts_STI
(r_ref : register_ref regstate register_value Sinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sinterrupts_Sinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Sinterrupts_Sinterrupts_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : Sinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Sinterrupts_STI (v : Sinterrupts) (x : mword 1) 
: Sinterrupts :=
   
   {[ v with
     Sinterrupts_Sinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sinterrupts_UTI (v : Sinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 4 4.

Definition _set_Sinterrupts_UTI
(r_ref : register_ref regstate register_value Sinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sinterrupts_Sinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Sinterrupts_Sinterrupts_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Sinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Sinterrupts_UTI (v : Sinterrupts) (x : mword 1) 
: Sinterrupts :=
   
   {[ v with
     Sinterrupts_Sinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sinterrupts_SSI (v : Sinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 1 1.

Definition _set_Sinterrupts_SSI
(r_ref : register_ref regstate register_value Sinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sinterrupts_Sinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Sinterrupts_Sinterrupts_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Sinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Sinterrupts_SSI (v : Sinterrupts) (x : mword 1) 
: Sinterrupts :=
   
   {[ v with
     Sinterrupts_Sinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Sinterrupts_USI (v : Sinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 0 0.

Definition _set_Sinterrupts_USI
(r_ref : register_ref regstate register_value Sinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Sinterrupts_Sinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Sinterrupts_Sinterrupts_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Sinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Sinterrupts_USI (v : Sinterrupts) (x : mword 1) 
: Sinterrupts :=
   
   {[ v with
     Sinterrupts_Sinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Sinterrupts_Sinterrupts_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition lower_mip (m : Minterrupts) (d : Minterrupts) 
: Sinterrupts :=
   
   let s : Sinterrupts := Mk_Sinterrupts (EXTZ 64 (vec_of_bits [B0]  : mword 1)) in
   let s := _update_Sinterrupts_SEI s (and_vec (_get_Minterrupts_SEI m) (_get_Minterrupts_SEI d)) in
   let s := _update_Sinterrupts_STI s (and_vec (_get_Minterrupts_STI m) (_get_Minterrupts_STI d)) in
   let s := _update_Sinterrupts_SSI s (and_vec (_get_Minterrupts_SSI m) (_get_Minterrupts_SSI d)) in
   let s := _update_Sinterrupts_UEI s (and_vec (_get_Minterrupts_UEI m) (_get_Minterrupts_UEI d)) in
   let s := _update_Sinterrupts_UTI s (and_vec (_get_Minterrupts_UTI m) (_get_Minterrupts_UTI d)) in
   _update_Sinterrupts_USI s (and_vec (_get_Minterrupts_USI m) (_get_Minterrupts_USI d)).

Definition lower_mie (m : Minterrupts) (d : Minterrupts) 
: Sinterrupts :=
   
   let s : Sinterrupts := Mk_Sinterrupts (EXTZ 64 (vec_of_bits [B0]  : mword 1)) in
   let s := _update_Sinterrupts_SEI s (and_vec (_get_Minterrupts_SEI m) (_get_Minterrupts_SEI d)) in
   let s := _update_Sinterrupts_STI s (and_vec (_get_Minterrupts_STI m) (_get_Minterrupts_STI d)) in
   let s := _update_Sinterrupts_SSI s (and_vec (_get_Minterrupts_SSI m) (_get_Minterrupts_SSI d)) in
   let s := _update_Sinterrupts_UEI s (and_vec (_get_Minterrupts_UEI m) (_get_Minterrupts_UEI d)) in
   let s := _update_Sinterrupts_UTI s (and_vec (_get_Minterrupts_UTI m) (_get_Minterrupts_UTI d)) in
   _update_Sinterrupts_USI s (and_vec (_get_Minterrupts_USI m) (_get_Minterrupts_USI d)).

Definition lift_sip (o : Minterrupts) (d : Minterrupts) (s : Sinterrupts) 
: M (Minterrupts) :=
   
   let m : Minterrupts := o in
   let m := _update_Minterrupts_SSI m (and_vec (_get_Sinterrupts_SSI s) (_get_Minterrupts_SSI d)) in
   (haveNExt tt) >>= fun w__0 : bool =>
   returnm ((if sumbool_of_bool (w__0) then
               let m :=
                 if ((eq_vec (_get_Minterrupts_UEI d) ((bool_to_bits true)  : mword 1))) then
                   _update_Minterrupts_UEI m (_get_Sinterrupts_UEI s)
                 else m in
               if ((eq_vec (_get_Minterrupts_USI d) ((bool_to_bits true)  : mword 1))) then
                 _update_Minterrupts_USI m (_get_Sinterrupts_USI s)
               else m
             else m)
    : Minterrupts).

Definition legalize_sip (m : Minterrupts) (d : Minterrupts) (v : mword 64) 
: M (Minterrupts) :=
   
   (lift_sip m d (Mk_Sinterrupts v))
    : M (Minterrupts).

Definition lift_sie (o : Minterrupts) (d : Minterrupts) (s : Sinterrupts) 
: M (Minterrupts) :=
   
   let m : Minterrupts := o in
   let m :=
     if ((eq_vec (_get_Minterrupts_SEI d) ((bool_to_bits true)  : mword 1))) then
       _update_Minterrupts_SEI m (_get_Sinterrupts_SEI s)
     else m in
   let m :=
     if ((eq_vec (_get_Minterrupts_STI d) ((bool_to_bits true)  : mword 1))) then
       _update_Minterrupts_STI m (_get_Sinterrupts_STI s)
     else m in
   let m :=
     if ((eq_vec (_get_Minterrupts_SSI d) ((bool_to_bits true)  : mword 1))) then
       _update_Minterrupts_SSI m (_get_Sinterrupts_SSI s)
     else m in
   (haveNExt tt) >>= fun w__0 : bool =>
   returnm ((if sumbool_of_bool (w__0) then
               let m :=
                 if ((eq_vec (_get_Minterrupts_UEI d) ((bool_to_bits true)  : mword 1))) then
                   _update_Minterrupts_UEI m (_get_Sinterrupts_UEI s)
                 else m in
               let m :=
                 if ((eq_vec (_get_Minterrupts_UTI d) ((bool_to_bits true)  : mword 1))) then
                   _update_Minterrupts_UTI m (_get_Sinterrupts_UTI s)
                 else m in
               if ((eq_vec (_get_Minterrupts_USI d) ((bool_to_bits true)  : mword 1))) then
                 _update_Minterrupts_USI m (_get_Sinterrupts_USI s)
               else m
             else m)
    : Minterrupts).

Definition legalize_sie (m : Minterrupts) (d : Minterrupts) (v : mword 64) 
: M (Minterrupts) :=
   
   (lift_sie m d (Mk_Sinterrupts v))
    : M (Minterrupts).

Definition Mk_Satp64 (v : mword 64) 
: Satp64 :=
   
   {| Satp64_Satp64_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Satp64_bits (v : Satp64) 
: mword 64 :=
   
   subrange_vec_dec v.(Satp64_Satp64_chunk_0) 63 0.

Definition _set_Satp64_bits (r_ref : register_ref regstate register_value Satp64) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp64_Satp64_chunk_0 :=
         (update_subrange_vec_dec r.(Satp64_Satp64_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Satp64 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp64_bits (v : Satp64) (x : mword 64) 
: Satp64 :=
   
   {[ v with
     Satp64_Satp64_chunk_0 :=
       (update_subrange_vec_dec v.(Satp64_Satp64_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Satp64_Mode (v : Satp64) 
: mword 4 :=
   
   subrange_vec_dec v.(Satp64_Satp64_chunk_0) 63 60.

Definition _set_Satp64_Mode (r_ref : register_ref regstate register_value Satp64) (v : mword 4) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp64_Satp64_chunk_0 :=
         (update_subrange_vec_dec r.(Satp64_Satp64_chunk_0) 63 60 (subrange_vec_dec v 3 0)) ]}
      : Satp64 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp64_Mode (v : Satp64) (x : mword 4) 
: Satp64 :=
   
   {[ v with
     Satp64_Satp64_chunk_0 :=
       (update_subrange_vec_dec v.(Satp64_Satp64_chunk_0) 63 60 (subrange_vec_dec x 3 0)) ]}.

Definition _get_Satp64_Asid (v : Satp64) 
: mword 16 :=
   
   subrange_vec_dec v.(Satp64_Satp64_chunk_0) 59 44.

Definition _set_Satp64_Asid (r_ref : register_ref regstate register_value Satp64) (v : mword 16) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp64_Satp64_chunk_0 :=
         (update_subrange_vec_dec r.(Satp64_Satp64_chunk_0) 59 44 (subrange_vec_dec v 15 0)) ]}
      : Satp64 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp64_Asid (v : Satp64) (x : mword 16) 
: Satp64 :=
   
   {[ v with
     Satp64_Satp64_chunk_0 :=
       (update_subrange_vec_dec v.(Satp64_Satp64_chunk_0) 59 44 (subrange_vec_dec x 15 0)) ]}.

Definition _get_Satp64_PPN (v : Satp64) 
: mword 44 :=
   
   subrange_vec_dec v.(Satp64_Satp64_chunk_0) 43 0.

Definition _set_Satp64_PPN (r_ref : register_ref regstate register_value Satp64) (v : mword 44) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp64_Satp64_chunk_0 :=
         (update_subrange_vec_dec r.(Satp64_Satp64_chunk_0) 43 0 (subrange_vec_dec v 43 0)) ]}
      : Satp64 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp64_PPN (v : Satp64) (x : mword 44) 
: Satp64 :=
   
   {[ v with
     Satp64_Satp64_chunk_0 :=
       (update_subrange_vec_dec v.(Satp64_Satp64_chunk_0) 43 0 (subrange_vec_dec x 43 0)) ]}.

Definition legalize_satp64 (a : Architecture) (o : mword 64) (v : mword 64) 
: mword 64 :=
   
   let s := Mk_Satp64 v in
   match (satp64Mode_of_bits a (_get_Satp64_Mode s)) with
   | None => o
   | Some (Sv32) => o
   | Some (_) => _get_Satp64_bits s
   end.

Definition Mk_Satp32 (v : mword 32) 
: Satp32 :=
   
   {| Satp32_Satp32_chunk_0 := (subrange_vec_dec v 31 0) |}.

Definition _get_Satp32_bits (v : Satp32) 
: mword 32 :=
   
   subrange_vec_dec v.(Satp32_Satp32_chunk_0) 31 0.

Definition _set_Satp32_bits (r_ref : register_ref regstate register_value Satp32) (v : mword 32) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp32_Satp32_chunk_0 :=
         (update_subrange_vec_dec r.(Satp32_Satp32_chunk_0) 31 0 (subrange_vec_dec v 31 0)) ]}
      : Satp32 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp32_bits (v : Satp32) (x : mword 32) 
: Satp32 :=
   
   {[ v with
     Satp32_Satp32_chunk_0 :=
       (update_subrange_vec_dec v.(Satp32_Satp32_chunk_0) 31 0 (subrange_vec_dec x 31 0)) ]}.

Definition _get_Satp32_Mode (v : Satp32) 
: mword 1 :=
   
   subrange_vec_dec v.(Satp32_Satp32_chunk_0) 31 31.

Definition _set_Satp32_Mode (r_ref : register_ref regstate register_value Satp32) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp32_Satp32_chunk_0 :=
         (update_subrange_vec_dec r.(Satp32_Satp32_chunk_0) 31 31 (subrange_vec_dec v 0 0)) ]}
      : Satp32 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp32_Mode (v : Satp32) (x : mword 1) 
: Satp32 :=
   
   {[ v with
     Satp32_Satp32_chunk_0 :=
       (update_subrange_vec_dec v.(Satp32_Satp32_chunk_0) 31 31 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Satp32_Asid (v : Satp32) 
: mword 9 :=
   
   subrange_vec_dec v.(Satp32_Satp32_chunk_0) 30 22.

Definition _set_Satp32_Asid (r_ref : register_ref regstate register_value Satp32) (v : mword 9) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp32_Satp32_chunk_0 :=
         (update_subrange_vec_dec r.(Satp32_Satp32_chunk_0) 30 22 (subrange_vec_dec v 8 0)) ]}
      : Satp32 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp32_Asid (v : Satp32) (x : mword 9) 
: Satp32 :=
   
   {[ v with
     Satp32_Satp32_chunk_0 :=
       (update_subrange_vec_dec v.(Satp32_Satp32_chunk_0) 30 22 (subrange_vec_dec x 8 0)) ]}.

Definition _get_Satp32_PPN (v : Satp32) 
: mword 22 :=
   
   subrange_vec_dec v.(Satp32_Satp32_chunk_0) 21 0.

Definition _set_Satp32_PPN (r_ref : register_ref regstate register_value Satp32) (v : mword 22) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Satp32_Satp32_chunk_0 :=
         (update_subrange_vec_dec r.(Satp32_Satp32_chunk_0) 21 0 (subrange_vec_dec v 21 0)) ]}
      : Satp32 in
   write_reg r_ref r
    : M (unit).

Definition _update_Satp32_PPN (v : Satp32) (x : mword 22) 
: Satp32 :=
   
   {[ v with
     Satp32_Satp32_chunk_0 :=
       (update_subrange_vec_dec v.(Satp32_Satp32_chunk_0) 21 0 (subrange_vec_dec x 21 0)) ]}.

Definition legalize_satp32 (a : Architecture) (o : mword 32) (v : mword 32)  : mword 32 :=  v.

Definition PmpAddrMatchType_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 3)} 
: PmpAddrMatchType :=
   
   let l__20 := arg_ in
   if sumbool_of_bool ((Z.eqb l__20 0)) then OFF
   else if sumbool_of_bool ((Z.eqb l__20 1)) then TOR
   else if sumbool_of_bool ((Z.eqb l__20 2)) then NA4
   else NAPOT.

Definition num_of_PmpAddrMatchType (arg_ : PmpAddrMatchType) 
: {e : Z & ArithFact (0 <= e /\ e <= 3)} :=
   
   build_ex(match arg_ with | OFF => 0 | TOR => 1 | NA4 => 2 | NAPOT => 3 end).

Definition pmpAddrMatchType_of_bits (bs : mword 2) 
: M (PmpAddrMatchType) :=
   
   let b__0 := bs in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0]  : mword 2))) then returnm (OFF  : PmpAddrMatchType)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then returnm (TOR  : PmpAddrMatchType)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then returnm (NA4  : PmpAddrMatchType)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then
      returnm (NAPOT
       : PmpAddrMatchType)
    else
      assert_exp' false "Pattern match failure at model/riscv_pmp_regs.sail 7:2 - 12:3" >>= fun _ =>
      exit tt)
    : M (PmpAddrMatchType).

Definition pmpAddrMatchType_to_bits (bs : PmpAddrMatchType) 
: mword 2 :=
   
   match bs with
   | OFF => (vec_of_bits [B0;B0]  : mword 2)
   | TOR => (vec_of_bits [B0;B1]  : mword 2)
   | NA4 => (vec_of_bits [B1;B0]  : mword 2)
   | NAPOT => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition Mk_Pmpcfg_ent (v : mword 8) 
: Pmpcfg_ent :=
   
   {| Pmpcfg_ent_Pmpcfg_ent_chunk_0 := (subrange_vec_dec v 7 0) |}.

Definition _get_Pmpcfg_ent_bits (v : Pmpcfg_ent) 
: mword 8 :=
   
   subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 7 0.

Definition _set_Pmpcfg_ent_bits
(r_ref : register_ref regstate register_value Pmpcfg_ent) (v : mword 8) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         (update_subrange_vec_dec r.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 7 0 (subrange_vec_dec v 7 0)) ]}
      : Pmpcfg_ent in
   write_reg r_ref r
    : M (unit).

Definition _update_Pmpcfg_ent_bits (v : Pmpcfg_ent) (x : mword 8) 
: Pmpcfg_ent :=
   
   {[ v with
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       (update_subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 7 0 (subrange_vec_dec x 7 0)) ]}.

Definition _get_Pmpcfg_ent_L (v : Pmpcfg_ent) 
: mword 1 :=
   
   subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 7 7.

Definition _set_Pmpcfg_ent_L (r_ref : register_ref regstate register_value Pmpcfg_ent) (v : mword 1)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         (update_subrange_vec_dec r.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : Pmpcfg_ent in
   write_reg r_ref r
    : M (unit).

Definition _update_Pmpcfg_ent_L (v : Pmpcfg_ent) (x : mword 1) 
: Pmpcfg_ent :=
   
   {[ v with
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       (update_subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Pmpcfg_ent_A (v : Pmpcfg_ent) 
: mword 2 :=
   
   subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 4 3.

Definition _set_Pmpcfg_ent_A (r_ref : register_ref regstate register_value Pmpcfg_ent) (v : mword 2)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         (update_subrange_vec_dec r.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 4 3 (subrange_vec_dec v 1 0)) ]}
      : Pmpcfg_ent in
   write_reg r_ref r
    : M (unit).

Definition _update_Pmpcfg_ent_A (v : Pmpcfg_ent) (x : mword 2) 
: Pmpcfg_ent :=
   
   {[ v with
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       (update_subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 4 3 (subrange_vec_dec x 1 0)) ]}.

Definition _get_Pmpcfg_ent_X (v : Pmpcfg_ent) 
: mword 1 :=
   
   subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 2 2.

Definition _set_Pmpcfg_ent_X (r_ref : register_ref regstate register_value Pmpcfg_ent) (v : mword 1)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         (update_subrange_vec_dec r.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 2 2 (subrange_vec_dec v 0 0)) ]}
      : Pmpcfg_ent in
   write_reg r_ref r
    : M (unit).

Definition _update_Pmpcfg_ent_X (v : Pmpcfg_ent) (x : mword 1) 
: Pmpcfg_ent :=
   
   {[ v with
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       (update_subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Pmpcfg_ent_W (v : Pmpcfg_ent) 
: mword 1 :=
   
   subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 1 1.

Definition _set_Pmpcfg_ent_W (r_ref : register_ref regstate register_value Pmpcfg_ent) (v : mword 1)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         (update_subrange_vec_dec r.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : Pmpcfg_ent in
   write_reg r_ref r
    : M (unit).

Definition _update_Pmpcfg_ent_W (v : Pmpcfg_ent) (x : mword 1) 
: Pmpcfg_ent :=
   
   {[ v with
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       (update_subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Pmpcfg_ent_R (v : Pmpcfg_ent) 
: mword 1 :=
   
   subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 0 0.

Definition _set_Pmpcfg_ent_R (r_ref : register_ref regstate register_value Pmpcfg_ent) (v : mword 1)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         (update_subrange_vec_dec r.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Pmpcfg_ent in
   write_reg r_ref r
    : M (unit).

Definition _update_Pmpcfg_ent_R (v : Pmpcfg_ent) (x : mword 1) 
: Pmpcfg_ent :=
   
   {[ v with
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       (update_subrange_vec_dec v.(Pmpcfg_ent_Pmpcfg_ent_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition pmpReadCfgReg (n : Z) `{ArithFact (0 <= n /\ n < 4)} 
: M (mword 64) :=
   
   let l__18 := n in
   (if sumbool_of_bool ((Z.eqb l__18 0)) then
      read_reg pmp7cfg_ref >>= fun w__0 : Pmpcfg_ent =>
      read_reg pmp6cfg_ref >>= fun w__1 : Pmpcfg_ent =>
      read_reg pmp5cfg_ref >>= fun w__2 : Pmpcfg_ent =>
      read_reg pmp4cfg_ref >>= fun w__3 : Pmpcfg_ent =>
      read_reg pmp3cfg_ref >>= fun w__4 : Pmpcfg_ent =>
      read_reg pmp2cfg_ref >>= fun w__5 : Pmpcfg_ent =>
      read_reg pmp1cfg_ref >>= fun w__6 : Pmpcfg_ent =>
      read_reg pmp0cfg_ref >>= fun w__7 : Pmpcfg_ent =>
      returnm ((concat_vec (_get_Pmpcfg_ent_bits w__0)
                  (concat_vec (_get_Pmpcfg_ent_bits w__1)
                     (concat_vec (_get_Pmpcfg_ent_bits w__2)
                        (concat_vec (_get_Pmpcfg_ent_bits w__3)
                           (concat_vec (_get_Pmpcfg_ent_bits w__4)
                              (concat_vec (_get_Pmpcfg_ent_bits w__5)
                                 (concat_vec (_get_Pmpcfg_ent_bits w__6) (_get_Pmpcfg_ent_bits w__7))))))))
       : mword (8 + (8 + (8 + (8 + (8 + (8 + (8 + 8))))))))
    else if sumbool_of_bool ((Z.eqb l__18 2)) then
      read_reg pmp15cfg_ref >>= fun w__8 : Pmpcfg_ent =>
      read_reg pmp14cfg_ref >>= fun w__9 : Pmpcfg_ent =>
      read_reg pmp13cfg_ref >>= fun w__10 : Pmpcfg_ent =>
      read_reg pmp12cfg_ref >>= fun w__11 : Pmpcfg_ent =>
      read_reg pmp11cfg_ref >>= fun w__12 : Pmpcfg_ent =>
      read_reg pmp10cfg_ref >>= fun w__13 : Pmpcfg_ent =>
      read_reg pmp9cfg_ref >>= fun w__14 : Pmpcfg_ent =>
      read_reg pmp8cfg_ref >>= fun w__15 : Pmpcfg_ent =>
      returnm ((concat_vec (_get_Pmpcfg_ent_bits w__8)
                  (concat_vec (_get_Pmpcfg_ent_bits w__9)
                     (concat_vec (_get_Pmpcfg_ent_bits w__10)
                        (concat_vec (_get_Pmpcfg_ent_bits w__11)
                           (concat_vec (_get_Pmpcfg_ent_bits w__12)
                              (concat_vec (_get_Pmpcfg_ent_bits w__13)
                                 (concat_vec (_get_Pmpcfg_ent_bits w__14)
                                    (_get_Pmpcfg_ent_bits w__15))))))))
       : mword (8 + (8 + (8 + (8 + (8 + (8 + (8 + 8))))))))
    else
      assert_exp' false "Pattern match failure at model/riscv_pmp_regs.sail 75:2 - 85:8" >>= fun _ =>
      exit tt)
    : M (mword 64).

Definition pmpWriteCfg (cfg : Pmpcfg_ent) (v : mword 8) 
: Pmpcfg_ent :=
   
   if ((eq_vec (_get_Pmpcfg_ent_L cfg) ((bool_to_bits true)  : mword 1))) then cfg
   else Mk_Pmpcfg_ent v.

Definition pmpWriteCfgReg (n : Z) (v : mword 64) `{ArithFact (0 <= n /\ n < 4)} 
: M (unit) :=
   
   let l__16 := n in
   (if sumbool_of_bool ((Z.eqb l__16 0)) then
      read_reg pmp0cfg_ref >>= fun w__0 : Pmpcfg_ent =>
      write_reg pmp0cfg_ref (pmpWriteCfg w__0 (subrange_vec_dec v 7 0)) >>
      read_reg pmp1cfg_ref >>= fun w__1 : Pmpcfg_ent =>
      write_reg pmp1cfg_ref (pmpWriteCfg w__1 (subrange_vec_dec v 15 8)) >>
      read_reg pmp2cfg_ref >>= fun w__2 : Pmpcfg_ent =>
      write_reg pmp2cfg_ref (pmpWriteCfg w__2 (subrange_vec_dec v 23 16)) >>
      read_reg pmp3cfg_ref >>= fun w__3 : Pmpcfg_ent =>
      write_reg pmp3cfg_ref (pmpWriteCfg w__3 (subrange_vec_dec v 31 24)) >>
      read_reg pmp4cfg_ref >>= fun w__4 : Pmpcfg_ent =>
      write_reg pmp4cfg_ref (pmpWriteCfg w__4 (subrange_vec_dec v 39 32)) >>
      read_reg pmp5cfg_ref >>= fun w__5 : Pmpcfg_ent =>
      write_reg pmp5cfg_ref (pmpWriteCfg w__5 (subrange_vec_dec v 47 40)) >>
      read_reg pmp6cfg_ref >>= fun w__6 : Pmpcfg_ent =>
      write_reg pmp6cfg_ref (pmpWriteCfg w__6 (subrange_vec_dec v 55 48)) >>
      read_reg pmp7cfg_ref >>= fun w__7 : Pmpcfg_ent =>
      write_reg pmp7cfg_ref (pmpWriteCfg w__7 (subrange_vec_dec v 63 56))
       : M (unit)
    else if sumbool_of_bool ((Z.eqb l__16 2)) then
      read_reg pmp8cfg_ref >>= fun w__8 : Pmpcfg_ent =>
      let pmp8cfg8 := pmpWriteCfg w__8 (subrange_vec_dec v 7 0) in
      read_reg pmp9cfg_ref >>= fun w__9 : Pmpcfg_ent =>
      let pmp9cfg9 := pmpWriteCfg w__9 (subrange_vec_dec v 15 8) in
      read_reg pmp10cfg_ref >>= fun w__10 : Pmpcfg_ent =>
      write_reg pmp10cfg_ref (pmpWriteCfg w__10 (subrange_vec_dec v 23 16)) >>
      read_reg pmp11cfg_ref >>= fun w__11 : Pmpcfg_ent =>
      write_reg pmp11cfg_ref (pmpWriteCfg w__11 (subrange_vec_dec v 31 24)) >>
      read_reg pmp12cfg_ref >>= fun w__12 : Pmpcfg_ent =>
      write_reg pmp12cfg_ref (pmpWriteCfg w__12 (subrange_vec_dec v 39 32)) >>
      read_reg pmp13cfg_ref >>= fun w__13 : Pmpcfg_ent =>
      write_reg pmp13cfg_ref (pmpWriteCfg w__13 (subrange_vec_dec v 47 40)) >>
      read_reg pmp14cfg_ref >>= fun w__14 : Pmpcfg_ent =>
      write_reg pmp14cfg_ref (pmpWriteCfg w__14 (subrange_vec_dec v 55 48)) >>
      read_reg pmp15cfg_ref >>= fun w__15 : Pmpcfg_ent =>
      write_reg pmp15cfg_ref (pmpWriteCfg w__15 (subrange_vec_dec v 63 56))
       : M (unit)
    else
      assert_exp' false "Pattern match failure at model/riscv_pmp_regs.sail 94:2 - 137:8" >>= fun _ =>
      exit tt)
    : M (unit).

Definition pmpWriteAddr (cfg : Pmpcfg_ent) (reg : mword 64) (v : mword 64) 
: mword 64 :=
   
   if ((eq_vec (_get_Pmpcfg_ent_L cfg) ((bool_to_bits true)  : mword 1))) then reg
   else EXTZ 64 (subrange_vec_dec v 53 0).

Definition pmpAddrRange (cfg : Pmpcfg_ent) (pmpaddr : mword 64) (prev_pmpaddr : mword 64) 
: M (option ((mword 64 * mword 64))) :=
   
   (pmpAddrMatchType_of_bits (_get_Pmpcfg_ent_A cfg)) >>= fun w__0 : PmpAddrMatchType =>
   returnm ((match w__0 with
             | OFF => None
             | TOR => Some ((shiftl prev_pmpaddr 2, shiftl pmpaddr 2))
             | NA4 =>
                let lo := shiftl pmpaddr 2 in
                Some
                  ((lo, add_vec_int lo 4))
             | NAPOT =>
                let mask := xor_vec pmpaddr (add_vec_int pmpaddr 1) in
                let lo := and_vec pmpaddr (not_vec mask) in
                let len := add_vec_int mask 1 in
                Some
                  ((shiftl lo 2, shiftl (add_vec lo len) 2))
             end)
    : option ((mword 64 * mword 64))).

Definition pmpCheckRWX (ent : Pmpcfg_ent) (acc : AccessType) 
: bool :=
   
   match acc with
   | Read => eq_vec (_get_Pmpcfg_ent_R ent) ((bool_to_bits true)  : mword 1)
   | Write => eq_vec (_get_Pmpcfg_ent_W ent) ((bool_to_bits true)  : mword 1)
   | ReadWrite =>
      andb (eq_vec (_get_Pmpcfg_ent_R ent) ((bool_to_bits true)  : mword 1))
        (eq_vec (_get_Pmpcfg_ent_W ent) ((bool_to_bits true)  : mword 1))
   | Execute => eq_vec (_get_Pmpcfg_ent_X ent) ((bool_to_bits true)  : mword 1)
   end.

Definition pmpCheckPerms (ent : Pmpcfg_ent) (acc : AccessType) (priv : Privilege) 
: bool :=
   
   match priv with
   | Machine =>
      if ((eq_vec (_get_Pmpcfg_ent_L ent) ((bool_to_bits true)  : mword 1))) then
        pmpCheckRWX ent acc
      else true
   | _ => pmpCheckRWX ent acc
   end.

Definition pmpAddrMatch_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: pmpAddrMatch :=
   
   let l__14 := arg_ in
   if sumbool_of_bool ((Z.eqb l__14 0)) then PMP_NoMatch
   else if sumbool_of_bool ((Z.eqb l__14 1)) then PMP_PartialMatch
   else PMP_Match.

Definition num_of_pmpAddrMatch (arg_ : pmpAddrMatch) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | PMP_NoMatch => 0 | PMP_PartialMatch => 1 | PMP_Match => 2 end).

Definition pmpMatchAddr (addr : mword 64) (width : mword 64) (rng : option ((mword 64 * mword 64))) 
: pmpAddrMatch :=
   
   match rng with
   | None => PMP_NoMatch
   | Some ((lo, hi)) =>
      if ((zopz0zI_u hi lo)) then PMP_NoMatch
      else if ((orb (zopz0zI_u (add_vec addr width) lo) (zopz0zI_u hi addr))) then PMP_NoMatch
      else if ((andb (zopz0zIzJ_u lo addr) (zopz0zIzJ_u (add_vec addr width) hi))) then PMP_Match
      else PMP_PartialMatch
   end.

Definition pmpMatch_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 2)} 
: pmpMatch :=
   
   let l__12 := arg_ in
   if sumbool_of_bool ((Z.eqb l__12 0)) then PMP_Success
   else if sumbool_of_bool ((Z.eqb l__12 1)) then PMP_Continue
   else PMP_Fail.

Definition num_of_pmpMatch (arg_ : pmpMatch) 
: {e : Z & ArithFact (0 <= e /\ e <= 2)} :=
   
   build_ex(match arg_ with | PMP_Success => 0 | PMP_Continue => 1 | PMP_Fail => 2 end).

Definition pmpMatchEntry
(addr : mword 64) (width : mword 64) (acc : AccessType) (priv : Privilege) (ent : Pmpcfg_ent)
(pmpaddr : mword 64) (prev_pmpaddr : mword 64) 
: M (pmpMatch) :=
   
   (pmpAddrRange ent pmpaddr prev_pmpaddr) >>= fun rng =>
   returnm ((match (pmpMatchAddr addr width rng) with
             | PMP_NoMatch => PMP_Continue
             | PMP_PartialMatch => PMP_Fail
             | PMP_Match => if ((pmpCheckPerms ent acc priv)) then PMP_Success else PMP_Fail
             end)
    : pmpMatch).

Definition pmpCheck (addr : mword 64) (width : Z) (acc : AccessType) (priv : Privilege)
`{ArithFact (width > 0)} 
: M (option ExceptionType) :=
   
   let width : xlenbits := to_bits 64 width in
   read_reg pmp0cfg_ref >>= fun w__0 : Pmpcfg_ent =>
   ((read_reg pmpaddr0_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   (pmpMatchEntry addr width acc priv w__0 w__1 (zeros_implicit 64)) >>= fun w__2 : pmpMatch =>
   (match w__2 with
    | PMP_Success => returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
    | PMP_Fail =>
       returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))}))
    | PMP_Continue =>
       read_reg pmp1cfg_ref >>= fun w__3 : Pmpcfg_ent =>
       ((read_reg pmpaddr1_ref)  : M (mword 64)) >>= fun w__4 : mword 64 =>
       ((read_reg pmpaddr0_ref)  : M (mword 64)) >>= fun w__5 : mword 64 =>
       (pmpMatchEntry addr width acc priv w__3 w__4 w__5) >>= fun w__6 : pmpMatch =>
       (match w__6 with
        | PMP_Success =>
           returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
        | PMP_Fail =>
           returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))}))
        | PMP_Continue =>
           read_reg pmp2cfg_ref >>= fun w__7 : Pmpcfg_ent =>
           ((read_reg pmpaddr2_ref)  : M (mword 64)) >>= fun w__8 : mword 64 =>
           ((read_reg pmpaddr1_ref)  : M (mword 64)) >>= fun w__9 : mword 64 =>
           (pmpMatchEntry addr width acc priv w__7 w__8 w__9) >>= fun w__10 : pmpMatch =>
           (match w__10 with
            | PMP_Success =>
               returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
            | PMP_Fail =>
               returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))}))
            | PMP_Continue =>
               read_reg pmp3cfg_ref >>= fun w__11 : Pmpcfg_ent =>
               ((read_reg pmpaddr3_ref)  : M (mword 64)) >>= fun w__12 : mword 64 =>
               ((read_reg pmpaddr2_ref)  : M (mword 64)) >>= fun w__13 : mword 64 =>
               (pmpMatchEntry addr width acc priv w__11 w__12 w__13) >>= fun w__14 : pmpMatch =>
               (match w__14 with
                | PMP_Success =>
                   returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
                | PMP_Fail =>
                   returnm (projT1
                   (build_ex
                   false
                    : {_bool : bool & ArithFact (not (_bool = true))}))
                | PMP_Continue =>
                   read_reg pmp4cfg_ref >>= fun w__15 : Pmpcfg_ent =>
                   ((read_reg pmpaddr4_ref)  : M (mword 64)) >>= fun w__16 : mword 64 =>
                   ((read_reg pmpaddr3_ref)  : M (mword 64)) >>= fun w__17 : mword 64 =>
                   (pmpMatchEntry addr width acc priv w__15 w__16 w__17) >>= fun w__18 : pmpMatch =>
                   (match w__18 with
                    | PMP_Success =>
                       returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
                    | PMP_Fail =>
                       returnm (projT1
                       (build_ex
                       false
                        : {_bool : bool & ArithFact (not (_bool = true))}))
                    | PMP_Continue =>
                       read_reg pmp5cfg_ref >>= fun w__19 : Pmpcfg_ent =>
                       ((read_reg pmpaddr5_ref)  : M (mword 64)) >>= fun w__20 : mword 64 =>
                       ((read_reg pmpaddr4_ref)  : M (mword 64)) >>= fun w__21 : mword 64 =>
                       (pmpMatchEntry addr width acc priv w__19 w__20 w__21) >>= fun w__22 : pmpMatch =>
                       (match w__22 with
                        | PMP_Success =>
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                        | PMP_Fail =>
                           returnm (projT1
                           (build_ex
                           false
                            : {_bool : bool & ArithFact (not (_bool = true))}))
                        | PMP_Continue =>
                           read_reg pmp6cfg_ref >>= fun w__23 : Pmpcfg_ent =>
                           ((read_reg pmpaddr6_ref)  : M (mword 64)) >>= fun w__24 : mword 64 =>
                           ((read_reg pmpaddr5_ref)  : M (mword 64)) >>= fun w__25 : mword 64 =>
                           (pmpMatchEntry addr width acc priv w__23 w__24 w__25) >>= fun w__26 : pmpMatch =>
                           (match w__26 with
                            | PMP_Success =>
                               returnm (projT1
                               (build_ex
                               true
                                : {_bool : bool & ArithFact (_bool = true)}))
                            | PMP_Fail =>
                               returnm (projT1
                               (build_ex
                               false
                                : {_bool : bool & ArithFact (not (_bool = true))}))
                            | PMP_Continue =>
                               read_reg pmp7cfg_ref >>= fun w__27 : Pmpcfg_ent =>
                               ((read_reg pmpaddr7_ref)  : M (mword 64)) >>= fun w__28 : mword 64 =>
                               ((read_reg pmpaddr6_ref)  : M (mword 64)) >>= fun w__29 : mword 64 =>
                               (pmpMatchEntry addr width acc priv w__27 w__28 w__29) >>= fun w__30 : pmpMatch =>
                               (match w__30 with
                                | PMP_Success =>
                                   returnm (projT1
                                   (build_ex
                                   true
                                    : {_bool : bool & ArithFact (_bool = true)}))
                                | PMP_Fail =>
                                   returnm (projT1
                                   (build_ex
                                   false
                                    : {_bool : bool & ArithFact (not (_bool = true))}))
                                | PMP_Continue =>
                                   read_reg pmp8cfg_ref >>= fun w__31 : Pmpcfg_ent =>
                                   ((read_reg pmpaddr8_ref)  : M (mword 64)) >>= fun w__32 : mword 64 =>
                                   ((read_reg pmpaddr7_ref)  : M (mword 64)) >>= fun w__33 : mword 64 =>
                                   (pmpMatchEntry addr width acc priv w__31 w__32 w__33) >>= fun w__34 : pmpMatch =>
                                   (match w__34 with
                                    | PMP_Success =>
                                       returnm (projT1
                                       (build_ex
                                       true
                                        : {_bool : bool & ArithFact (_bool = true)}))
                                    | PMP_Fail =>
                                       returnm (projT1
                                       (build_ex
                                       false
                                        : {_bool : bool & ArithFact (not (_bool = true))}))
                                    | PMP_Continue =>
                                       read_reg pmp9cfg_ref >>= fun w__35 : Pmpcfg_ent =>
                                       ((read_reg pmpaddr9_ref)  : M (mword 64)) >>= fun w__36 : mword 64 =>
                                       ((read_reg pmpaddr8_ref)  : M (mword 64)) >>= fun w__37 : mword 64 =>
                                       (pmpMatchEntry addr width acc priv w__35 w__36 w__37) >>= fun w__38 : pmpMatch =>
                                       (match w__38 with
                                        | PMP_Success =>
                                           returnm (projT1
                                           (build_ex
                                           true
                                            : {_bool : bool & ArithFact (_bool = true)}))
                                        | PMP_Fail =>
                                           returnm (projT1
                                           (build_ex
                                           false
                                            : {_bool : bool & ArithFact (not (_bool = true))}))
                                        | PMP_Continue =>
                                           read_reg pmp10cfg_ref >>= fun w__39 : Pmpcfg_ent =>
                                           ((read_reg pmpaddr10_ref)  : M (mword 64)) >>= fun w__40 : mword 64 =>
                                           ((read_reg pmpaddr9_ref)  : M (mword 64)) >>= fun w__41 : mword 64 =>
                                           (pmpMatchEntry addr width acc priv w__39 w__40 w__41) >>= fun w__42 : pmpMatch =>
                                           (match w__42 with
                                            | PMP_Success =>
                                               returnm (projT1
                                               (build_ex
                                               true
                                                : {_bool : bool & ArithFact (_bool = true)}))
                                            | PMP_Fail =>
                                               returnm (projT1
                                               (build_ex
                                               false
                                                : {_bool : bool & ArithFact (not (_bool = true))}))
                                            | PMP_Continue =>
                                               read_reg pmp11cfg_ref >>= fun w__43 : Pmpcfg_ent =>
                                               ((read_reg pmpaddr11_ref)  : M (mword 64)) >>= fun w__44 : mword 64 =>
                                               ((read_reg pmpaddr10_ref)  : M (mword 64)) >>= fun w__45 : mword 64 =>
                                               (pmpMatchEntry addr width acc priv w__43 w__44 w__45) >>= fun w__46 : pmpMatch =>
                                               (match w__46 with
                                                | PMP_Success =>
                                                   returnm (projT1
                                                   (build_ex
                                                   true
                                                    : {_bool : bool & ArithFact (_bool = true)}))
                                                | PMP_Fail =>
                                                   returnm (projT1
                                                   (build_ex
                                                   false
                                                    : {_bool : bool & ArithFact (not (_bool = true))}))
                                                | PMP_Continue =>
                                                   read_reg pmp12cfg_ref >>= fun w__47 : Pmpcfg_ent =>
                                                   ((read_reg pmpaddr12_ref)  : M (mword 64)) >>= fun w__48 : mword 64 =>
                                                   ((read_reg pmpaddr11_ref)  : M (mword 64)) >>= fun w__49 : mword 64 =>
                                                   (pmpMatchEntry addr width acc priv w__47 w__48
                                                      w__49) >>= fun w__50 : pmpMatch =>
                                                   (match w__50 with
                                                    | PMP_Success =>
                                                       returnm (projT1
                                                       (build_ex
                                                       true
                                                        : {_bool : bool & ArithFact (_bool = true)}))
                                                    | PMP_Fail =>
                                                       returnm (projT1
                                                       (build_ex
                                                       false
                                                        : {_bool : bool & ArithFact (not (_bool =
                                                         true))}))
                                                    | PMP_Continue =>
                                                       read_reg pmp13cfg_ref >>= fun w__51 : Pmpcfg_ent =>
                                                       ((read_reg pmpaddr13_ref)  : M (mword 64)) >>= fun w__52 : mword 64 =>
                                                       ((read_reg pmpaddr12_ref)  : M (mword 64)) >>= fun w__53 : mword 64 =>
                                                       (pmpMatchEntry addr width acc priv w__51
                                                          w__52 w__53) >>= fun w__54 : pmpMatch =>
                                                       (match w__54 with
                                                        | PMP_Success =>
                                                           returnm (projT1
                                                           (build_ex
                                                           true
                                                            : {_bool : bool & ArithFact (_bool =
                                                             true)}))
                                                        | PMP_Fail =>
                                                           returnm (projT1
                                                           (build_ex
                                                           false
                                                            : {_bool : bool & ArithFact (not (_bool =
                                                             true))}))
                                                        | PMP_Continue =>
                                                           read_reg pmp14cfg_ref >>= fun w__55 : Pmpcfg_ent =>
                                                           ((read_reg pmpaddr14_ref)  : M (mword 64)) >>= fun w__56 : mword 64 =>
                                                           ((read_reg pmpaddr13_ref)  : M (mword 64)) >>= fun w__57 : mword 64 =>
                                                           (pmpMatchEntry addr width acc priv w__55
                                                              w__56 w__57) >>= fun w__58 : pmpMatch =>
                                                           (match w__58 with
                                                            | PMP_Success =>
                                                               returnm (projT1
                                                               (build_ex
                                                               true
                                                                : {_bool : bool & ArithFact (_bool =
                                                                 true)}))
                                                            | PMP_Fail =>
                                                               returnm (projT1
                                                               (build_ex
                                                               false
                                                                : {_bool : bool & ArithFact (not (_bool =
                                                                 true))}))
                                                            | PMP_Continue =>
                                                               read_reg pmp15cfg_ref >>= fun w__59 : Pmpcfg_ent =>
                                                               ((read_reg pmpaddr15_ref)
                                                                 : M (mword 64)) >>= fun w__60 : mword 64 =>
                                                               ((read_reg pmpaddr14_ref)
                                                                 : M (mword 64)) >>= fun w__61 : mword 64 =>
                                                               (pmpMatchEntry addr width acc priv
                                                                  w__59 w__60 w__61) >>= fun w__62 : pmpMatch =>
                                                               returnm ((match w__62 with
                                                                         | PMP_Success => true
                                                                         | PMP_Fail => false
                                                                         | PMP_Continue =>
                                                                            match priv with
                                                                            | Machine => true
                                                                            | _ => false
                                                                            end
                                                                         end)
                                                                : bool)
                                                            end)
                                                            : M (bool)
                                                        end)
                                                        : M (bool)
                                                    end)
                                                    : M (bool)
                                                end)
                                                : M (bool)
                                            end)
                                            : M (bool)
                                        end)
                                        : M (bool)
                                    end)
                                    : M (bool)
                                end)
                                : M (bool)
                            end)
                            : M (bool)
                        end)
                        : M (bool)
                    end)
                    : M (bool)
                end)
                : M (bool)
            end)
            : M (bool)
        end)
        : M (bool)
    end) >>= fun check' : bool =>
   returnm ((if sumbool_of_bool (check') then None
             else
               match acc with
               | Read => Some (E_Load_Access_Fault)
               | Write => Some (E_SAMO_Access_Fault)
               | ReadWrite => Some (E_SAMO_Access_Fault)
               | Execute => Some (E_Fetch_Access_Fault)
               end)
    : option ExceptionType).

Definition init_pmp '(tt : unit) 
: M (unit) :=
   
   read_reg pmp0cfg_ref >>= fun w__0 : Pmpcfg_ent =>
   write_reg pmp0cfg_ref (_update_Pmpcfg_ent_A w__0 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp1cfg_ref >>= fun w__1 : Pmpcfg_ent =>
   write_reg pmp1cfg_ref (_update_Pmpcfg_ent_A w__1 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp2cfg_ref >>= fun w__2 : Pmpcfg_ent =>
   write_reg pmp2cfg_ref (_update_Pmpcfg_ent_A w__2 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp3cfg_ref >>= fun w__3 : Pmpcfg_ent =>
   write_reg pmp3cfg_ref (_update_Pmpcfg_ent_A w__3 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp4cfg_ref >>= fun w__4 : Pmpcfg_ent =>
   write_reg pmp4cfg_ref (_update_Pmpcfg_ent_A w__4 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp5cfg_ref >>= fun w__5 : Pmpcfg_ent =>
   write_reg pmp5cfg_ref (_update_Pmpcfg_ent_A w__5 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp6cfg_ref >>= fun w__6 : Pmpcfg_ent =>
   write_reg pmp6cfg_ref (_update_Pmpcfg_ent_A w__6 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp7cfg_ref >>= fun w__7 : Pmpcfg_ent =>
   write_reg pmp7cfg_ref (_update_Pmpcfg_ent_A w__7 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp8cfg_ref >>= fun w__8 : Pmpcfg_ent =>
   write_reg pmp8cfg_ref (_update_Pmpcfg_ent_A w__8 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp9cfg_ref >>= fun w__9 : Pmpcfg_ent =>
   write_reg pmp9cfg_ref (_update_Pmpcfg_ent_A w__9 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp10cfg_ref >>= fun w__10 : Pmpcfg_ent =>
   write_reg pmp10cfg_ref (_update_Pmpcfg_ent_A w__10 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp11cfg_ref >>= fun w__11 : Pmpcfg_ent =>
   write_reg pmp11cfg_ref (_update_Pmpcfg_ent_A w__11 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp12cfg_ref >>= fun w__12 : Pmpcfg_ent =>
   write_reg pmp12cfg_ref (_update_Pmpcfg_ent_A w__12 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp13cfg_ref >>= fun w__13 : Pmpcfg_ent =>
   write_reg pmp13cfg_ref (_update_Pmpcfg_ent_A w__13 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp14cfg_ref >>= fun w__14 : Pmpcfg_ent =>
   write_reg pmp14cfg_ref (_update_Pmpcfg_ent_A w__14 (pmpAddrMatchType_to_bits OFF)) >>
   read_reg pmp15cfg_ref >>= fun w__15 : Pmpcfg_ent =>
   write_reg pmp15cfg_ref (_update_Pmpcfg_ent_A w__15 (pmpAddrMatchType_to_bits OFF))
    : M (unit).

Definition ext_init_regs '(tt : unit)  : M (unit) :=  returnm (tt  : unit).

Definition ext_rvfi_init '(tt : unit)  : M (unit) :=  returnm (tt  : unit).

Definition ext_fetch_check_pc (start_pc : mword 64) (pc : mword 64) 
: Ext_FetchAddr_Check unit :=
   
   Ext_FetchAddr_OK
     (pc).

Definition ext_handle_fetch_check_error (err : unit)  : unit :=  tt.

Definition ext_control_check_addr (pc : mword 64) 
: Ext_ControlAddr_Check unit :=
   
   Ext_ControlAddr_OK
     (pc).

Definition ext_control_check_pc (pc : mword 64) 
: Ext_ControlAddr_Check unit :=
   
   Ext_ControlAddr_OK
     (pc).

Definition ext_handle_control_check_error (err : unit)  : unit :=  tt.

Definition ext_data_get_addr
(base : mword 5) (offset : mword 64) (acc : AccessType) (width : word_width) 
: M (Ext_DataAddr_Check unit) :=
   
   (rX (projT1 (regidx_to_regno base))) >>= fun w__0 : mword 64 =>
   let addr := add_vec w__0 offset in
   returnm ((Ext_DataAddr_OK
               (addr))
    : Ext_DataAddr_Check unit).

Definition ext_handle_data_check_error (err : unit)  : unit :=  tt.

Definition csr_name (csr : mword 12) 
: string :=
   
   let b__0 := csr in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then "ustatus"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
     "uie"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
     "utvec"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "uscratch"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
     "uepc"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "ucause"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
     "utval"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
     "uip"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
     "fflags"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "frm"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
     "fcsr"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "cycle"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
     "time"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "instret"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "cycleh"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
     "timeh"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "instreth"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "sstatus"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "sedeleg"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
     "sideleg"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
     "sie"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
     "stvec"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
     "scounteren"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "sscratch"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
     "sepc"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "scause"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
     "stval"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
     "sip"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "satp"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  : mword 12))) then
     "mvendorid"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  : mword 12))) then
     "marchid"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  : mword 12))) then
     "mimpid"
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  : mword 12))) then
     "mhartid"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "mstatus"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
     "misa"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "medeleg"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
     "mideleg"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
     "mie"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
     "mtvec"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
     "mcounteren"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "mscratch"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
     "mepc"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "mcause"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
     "mtval"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
     "mip"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
     "pmpcfg0"
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12))) then
     "pmpaddr0"
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "mcycle"
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "minstret"
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
     "mcycleh"
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
     "minstreth"
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
     "tselect"
   else "UNKNOWN".

Definition csr_name_map_forwards (arg_ : mword 12) 
: M (string) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("ustatus"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ("uie"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      returnm ("utvec"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("uscratch"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("uepc"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("ucause"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("utval"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ("uip"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("fflags"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("frm"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("fcsr"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("cycle"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("time"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("instret"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("cycleh"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("timeh"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("instreth"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("sstatus"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("sedeleg"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("sideleg"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ("sie"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      returnm ("stvec"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
      returnm ("scounteren"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("sscratch"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("sepc"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("scause"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("stval"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ("sip"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("satp"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  : mword 12))) then
      returnm ("mvendorid"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  : mword 12))) then
      returnm ("marchid"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  : mword 12))) then
      returnm ("mimpid"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  : mword 12))) then
      returnm ("mhartid"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("mstatus"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("misa"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("medeleg"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("mideleg"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ("mie"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      returnm ("mtvec"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
      returnm ("mcounteren"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("mscratch"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("mepc"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("mcause"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("mtval"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ("mip"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("pmpcfg0"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("pmpcfg1"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("pmpcfg2"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("pmpcfg3"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12))) then
      returnm ("pmpaddr0"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B1]  : mword 12))) then
      returnm ("pmpaddr1"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B0]  : mword 12))) then
      returnm ("pmpaddr2"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B1]  : mword 12))) then
      returnm ("pmpaddr3"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B0]  : mword 12))) then
      returnm ("pmpaddr4"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B1]  : mword 12))) then
      returnm ("pmpaddr5"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B0]  : mword 12))) then
      returnm ("pmpaddr6"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B1]  : mword 12))) then
      returnm ("pmpaddr7"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B0]  : mword 12))) then
      returnm ("pmpaddr8"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B1]  : mword 12))) then
      returnm ("pmpaddr9"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0]  : mword 12))) then
      returnm ("pmpaddr10"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B1]  : mword 12))) then
      returnm ("pmpaddr11"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B0]  : mword 12))) then
      returnm ("pmpaddr12"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B1]  : mword 12))) then
      returnm ("pmpaddr13"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B0]  : mword 12))) then
      returnm ("pmpaddr14"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1]  : mword 12))) then
      returnm ("pmpaddr15"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("mcycle"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("minstret"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("mcycleh"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("minstreth"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ("tselect"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ("tdata1"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ("tdata2"
       : string)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ("tdata3"
       : string)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (string).

Definition csr_name_map_backwards (arg_ : string) 
: M (mword 12) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "ustatus")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "uie")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "utvec")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "uscratch")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "uepc")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "ucause")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "utval")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "uip")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "fflags")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "frm")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "fcsr")) then
      returnm ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "cycle")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "time")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "instret")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "cycleh")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "timeh")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "instreth")) then
      returnm ((vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "sstatus")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "sedeleg")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "sideleg")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "sie")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "stvec")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "scounteren")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "sscratch")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "sepc")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "scause")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "stval")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "sip")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "satp")) then
      returnm ((vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mvendorid")) then
      returnm ((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "marchid")) then
      returnm ((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mimpid")) then
      returnm ((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mhartid")) then
      returnm ((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mstatus")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "misa")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "medeleg")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mideleg")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mie")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mtvec")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mcounteren")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mscratch")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mepc")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mcause")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mtval")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mip")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpcfg0")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpcfg1")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpcfg2")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpcfg3")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr0")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr1")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr2")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr3")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr4")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr5")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr6")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr7")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr8")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr9")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr10")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr11")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr12")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr13")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr14")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "pmpaddr15")) then
      returnm ((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mcycle")) then
      returnm ((vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "minstret")) then
      returnm ((vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "mcycleh")) then
      returnm ((vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "minstreth")) then
      returnm ((vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "tselect")) then
      returnm ((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "tdata1")) then
      returnm ((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "tdata2")) then
      returnm ((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12)
       : mword 12)
    else if ((generic_eq p0_ "tdata3")) then
      returnm ((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12)
       : mword 12)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 12).

Definition csr_name_map_forwards_matches (arg_ : mword 12) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12))) then true
   else false.

Definition csr_name_map_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "ustatus")) then true
   else if ((generic_eq p0_ "uie")) then true
   else if ((generic_eq p0_ "utvec")) then true
   else if ((generic_eq p0_ "uscratch")) then true
   else if ((generic_eq p0_ "uepc")) then true
   else if ((generic_eq p0_ "ucause")) then true
   else if ((generic_eq p0_ "utval")) then true
   else if ((generic_eq p0_ "uip")) then true
   else if ((generic_eq p0_ "fflags")) then true
   else if ((generic_eq p0_ "frm")) then true
   else if ((generic_eq p0_ "fcsr")) then true
   else if ((generic_eq p0_ "cycle")) then true
   else if ((generic_eq p0_ "time")) then true
   else if ((generic_eq p0_ "instret")) then true
   else if ((generic_eq p0_ "cycleh")) then true
   else if ((generic_eq p0_ "timeh")) then true
   else if ((generic_eq p0_ "instreth")) then true
   else if ((generic_eq p0_ "sstatus")) then true
   else if ((generic_eq p0_ "sedeleg")) then true
   else if ((generic_eq p0_ "sideleg")) then true
   else if ((generic_eq p0_ "sie")) then true
   else if ((generic_eq p0_ "stvec")) then true
   else if ((generic_eq p0_ "scounteren")) then true
   else if ((generic_eq p0_ "sscratch")) then true
   else if ((generic_eq p0_ "sepc")) then true
   else if ((generic_eq p0_ "scause")) then true
   else if ((generic_eq p0_ "stval")) then true
   else if ((generic_eq p0_ "sip")) then true
   else if ((generic_eq p0_ "satp")) then true
   else if ((generic_eq p0_ "mvendorid")) then true
   else if ((generic_eq p0_ "marchid")) then true
   else if ((generic_eq p0_ "mimpid")) then true
   else if ((generic_eq p0_ "mhartid")) then true
   else if ((generic_eq p0_ "mstatus")) then true
   else if ((generic_eq p0_ "misa")) then true
   else if ((generic_eq p0_ "medeleg")) then true
   else if ((generic_eq p0_ "mideleg")) then true
   else if ((generic_eq p0_ "mie")) then true
   else if ((generic_eq p0_ "mtvec")) then true
   else if ((generic_eq p0_ "mcounteren")) then true
   else if ((generic_eq p0_ "mscratch")) then true
   else if ((generic_eq p0_ "mepc")) then true
   else if ((generic_eq p0_ "mcause")) then true
   else if ((generic_eq p0_ "mtval")) then true
   else if ((generic_eq p0_ "mip")) then true
   else if ((generic_eq p0_ "pmpcfg0")) then true
   else if ((generic_eq p0_ "pmpcfg1")) then true
   else if ((generic_eq p0_ "pmpcfg2")) then true
   else if ((generic_eq p0_ "pmpcfg3")) then true
   else if ((generic_eq p0_ "pmpaddr0")) then true
   else if ((generic_eq p0_ "pmpaddr1")) then true
   else if ((generic_eq p0_ "pmpaddr2")) then true
   else if ((generic_eq p0_ "pmpaddr3")) then true
   else if ((generic_eq p0_ "pmpaddr4")) then true
   else if ((generic_eq p0_ "pmpaddr5")) then true
   else if ((generic_eq p0_ "pmpaddr6")) then true
   else if ((generic_eq p0_ "pmpaddr7")) then true
   else if ((generic_eq p0_ "pmpaddr8")) then true
   else if ((generic_eq p0_ "pmpaddr9")) then true
   else if ((generic_eq p0_ "pmpaddr10")) then true
   else if ((generic_eq p0_ "pmpaddr11")) then true
   else if ((generic_eq p0_ "pmpaddr12")) then true
   else if ((generic_eq p0_ "pmpaddr13")) then true
   else if ((generic_eq p0_ "pmpaddr14")) then true
   else if ((generic_eq p0_ "pmpaddr15")) then true
   else if ((generic_eq p0_ "mcycle")) then true
   else if ((generic_eq p0_ "minstret")) then true
   else if ((generic_eq p0_ "mcycleh")) then true
   else if ((generic_eq p0_ "minstreth")) then true
   else if ((generic_eq p0_ "tselect")) then true
   else if ((generic_eq p0_ "tdata1")) then true
   else if ((generic_eq p0_ "tdata2")) then true
   else if ((generic_eq p0_ "tdata3")) then true
   else false.

Definition _s488_ (_s489_ : string) 
: option string :=
   
   let _s490_ := _s489_ in
   if ((string_startswith _s490_ "tdata3")) then
     match (string_drop _s490_ (projT1 (string_length "tdata3"))) with | s_ => Some (s_) end
   else None.

Definition _s484_ (_s485_ : string) 
: option string :=
   
   let _s486_ := _s485_ in
   if ((string_startswith _s486_ "tdata2")) then
     match (string_drop _s486_ (projT1 (string_length "tdata2"))) with | s_ => Some (s_) end
   else None.

Definition _s480_ (_s481_ : string) 
: option string :=
   
   let _s482_ := _s481_ in
   if ((string_startswith _s482_ "tdata1")) then
     match (string_drop _s482_ (projT1 (string_length "tdata1"))) with | s_ => Some (s_) end
   else None.

Definition _s476_ (_s477_ : string) 
: option string :=
   
   let _s478_ := _s477_ in
   if ((string_startswith _s478_ "tselect")) then
     match (string_drop _s478_ (projT1 (string_length "tselect"))) with | s_ => Some (s_) end
   else None.

Definition _s472_ (_s473_ : string) 
: option string :=
   
   let _s474_ := _s473_ in
   if ((string_startswith _s474_ "minstreth")) then
     match (string_drop _s474_ (projT1 (string_length "minstreth"))) with | s_ => Some (s_) end
   else None.

Definition _s468_ (_s469_ : string) 
: option string :=
   
   let _s470_ := _s469_ in
   if ((string_startswith _s470_ "mcycleh")) then
     match (string_drop _s470_ (projT1 (string_length "mcycleh"))) with | s_ => Some (s_) end
   else None.

Definition _s464_ (_s465_ : string) 
: option string :=
   
   let _s466_ := _s465_ in
   if ((string_startswith _s466_ "minstret")) then
     match (string_drop _s466_ (projT1 (string_length "minstret"))) with | s_ => Some (s_) end
   else None.

Definition _s460_ (_s461_ : string) 
: option string :=
   
   let _s462_ := _s461_ in
   if ((string_startswith _s462_ "mcycle")) then
     match (string_drop _s462_ (projT1 (string_length "mcycle"))) with | s_ => Some (s_) end
   else None.

Definition _s456_ (_s457_ : string) 
: option string :=
   
   let _s458_ := _s457_ in
   if ((string_startswith _s458_ "pmpaddr15")) then
     match (string_drop _s458_ (projT1 (string_length "pmpaddr15"))) with | s_ => Some (s_) end
   else None.

Definition _s452_ (_s453_ : string) 
: option string :=
   
   let _s454_ := _s453_ in
   if ((string_startswith _s454_ "pmpaddr14")) then
     match (string_drop _s454_ (projT1 (string_length "pmpaddr14"))) with | s_ => Some (s_) end
   else None.

Definition _s448_ (_s449_ : string) 
: option string :=
   
   let _s450_ := _s449_ in
   if ((string_startswith _s450_ "pmpaddr13")) then
     match (string_drop _s450_ (projT1 (string_length "pmpaddr13"))) with | s_ => Some (s_) end
   else None.

Definition _s444_ (_s445_ : string) 
: option string :=
   
   let _s446_ := _s445_ in
   if ((string_startswith _s446_ "pmpaddr12")) then
     match (string_drop _s446_ (projT1 (string_length "pmpaddr12"))) with | s_ => Some (s_) end
   else None.

Definition _s440_ (_s441_ : string) 
: option string :=
   
   let _s442_ := _s441_ in
   if ((string_startswith _s442_ "pmpaddr11")) then
     match (string_drop _s442_ (projT1 (string_length "pmpaddr11"))) with | s_ => Some (s_) end
   else None.

Definition _s436_ (_s437_ : string) 
: option string :=
   
   let _s438_ := _s437_ in
   if ((string_startswith _s438_ "pmpaddr10")) then
     match (string_drop _s438_ (projT1 (string_length "pmpaddr10"))) with | s_ => Some (s_) end
   else None.

Definition _s432_ (_s433_ : string) 
: option string :=
   
   let _s434_ := _s433_ in
   if ((string_startswith _s434_ "pmpaddr9")) then
     match (string_drop _s434_ (projT1 (string_length "pmpaddr9"))) with | s_ => Some (s_) end
   else None.

Definition _s428_ (_s429_ : string) 
: option string :=
   
   let _s430_ := _s429_ in
   if ((string_startswith _s430_ "pmpaddr8")) then
     match (string_drop _s430_ (projT1 (string_length "pmpaddr8"))) with | s_ => Some (s_) end
   else None.

Definition _s424_ (_s425_ : string) 
: option string :=
   
   let _s426_ := _s425_ in
   if ((string_startswith _s426_ "pmpaddr7")) then
     match (string_drop _s426_ (projT1 (string_length "pmpaddr7"))) with | s_ => Some (s_) end
   else None.

Definition _s420_ (_s421_ : string) 
: option string :=
   
   let _s422_ := _s421_ in
   if ((string_startswith _s422_ "pmpaddr6")) then
     match (string_drop _s422_ (projT1 (string_length "pmpaddr6"))) with | s_ => Some (s_) end
   else None.

Definition _s416_ (_s417_ : string) 
: option string :=
   
   let _s418_ := _s417_ in
   if ((string_startswith _s418_ "pmpaddr5")) then
     match (string_drop _s418_ (projT1 (string_length "pmpaddr5"))) with | s_ => Some (s_) end
   else None.

Definition _s412_ (_s413_ : string) 
: option string :=
   
   let _s414_ := _s413_ in
   if ((string_startswith _s414_ "pmpaddr4")) then
     match (string_drop _s414_ (projT1 (string_length "pmpaddr4"))) with | s_ => Some (s_) end
   else None.

Definition _s408_ (_s409_ : string) 
: option string :=
   
   let _s410_ := _s409_ in
   if ((string_startswith _s410_ "pmpaddr3")) then
     match (string_drop _s410_ (projT1 (string_length "pmpaddr3"))) with | s_ => Some (s_) end
   else None.

Definition _s404_ (_s405_ : string) 
: option string :=
   
   let _s406_ := _s405_ in
   if ((string_startswith _s406_ "pmpaddr2")) then
     match (string_drop _s406_ (projT1 (string_length "pmpaddr2"))) with | s_ => Some (s_) end
   else None.

Definition _s400_ (_s401_ : string) 
: option string :=
   
   let _s402_ := _s401_ in
   if ((string_startswith _s402_ "pmpaddr1")) then
     match (string_drop _s402_ (projT1 (string_length "pmpaddr1"))) with | s_ => Some (s_) end
   else None.

Definition _s396_ (_s397_ : string) 
: option string :=
   
   let _s398_ := _s397_ in
   if ((string_startswith _s398_ "pmpaddr0")) then
     match (string_drop _s398_ (projT1 (string_length "pmpaddr0"))) with | s_ => Some (s_) end
   else None.

Definition _s392_ (_s393_ : string) 
: option string :=
   
   let _s394_ := _s393_ in
   if ((string_startswith _s394_ "pmpcfg3")) then
     match (string_drop _s394_ (projT1 (string_length "pmpcfg3"))) with | s_ => Some (s_) end
   else None.

Definition _s388_ (_s389_ : string) 
: option string :=
   
   let _s390_ := _s389_ in
   if ((string_startswith _s390_ "pmpcfg2")) then
     match (string_drop _s390_ (projT1 (string_length "pmpcfg2"))) with | s_ => Some (s_) end
   else None.

Definition _s384_ (_s385_ : string) 
: option string :=
   
   let _s386_ := _s385_ in
   if ((string_startswith _s386_ "pmpcfg1")) then
     match (string_drop _s386_ (projT1 (string_length "pmpcfg1"))) with | s_ => Some (s_) end
   else None.

Definition _s380_ (_s381_ : string) 
: option string :=
   
   let _s382_ := _s381_ in
   if ((string_startswith _s382_ "pmpcfg0")) then
     match (string_drop _s382_ (projT1 (string_length "pmpcfg0"))) with | s_ => Some (s_) end
   else None.

Definition _s376_ (_s377_ : string) 
: option string :=
   
   let _s378_ := _s377_ in
   if ((string_startswith _s378_ "mip")) then
     match (string_drop _s378_ (projT1 (string_length "mip"))) with | s_ => Some (s_) end
   else None.

Definition _s372_ (_s373_ : string) 
: option string :=
   
   let _s374_ := _s373_ in
   if ((string_startswith _s374_ "mtval")) then
     match (string_drop _s374_ (projT1 (string_length "mtval"))) with | s_ => Some (s_) end
   else None.

Definition _s368_ (_s369_ : string) 
: option string :=
   
   let _s370_ := _s369_ in
   if ((string_startswith _s370_ "mcause")) then
     match (string_drop _s370_ (projT1 (string_length "mcause"))) with | s_ => Some (s_) end
   else None.

Definition _s364_ (_s365_ : string) 
: option string :=
   
   let _s366_ := _s365_ in
   if ((string_startswith _s366_ "mepc")) then
     match (string_drop _s366_ (projT1 (string_length "mepc"))) with | s_ => Some (s_) end
   else None.

Definition _s360_ (_s361_ : string) 
: option string :=
   
   let _s362_ := _s361_ in
   if ((string_startswith _s362_ "mscratch")) then
     match (string_drop _s362_ (projT1 (string_length "mscratch"))) with | s_ => Some (s_) end
   else None.

Definition _s356_ (_s357_ : string) 
: option string :=
   
   let _s358_ := _s357_ in
   if ((string_startswith _s358_ "mcounteren")) then
     match (string_drop _s358_ (projT1 (string_length "mcounteren"))) with | s_ => Some (s_) end
   else None.

Definition _s352_ (_s353_ : string) 
: option string :=
   
   let _s354_ := _s353_ in
   if ((string_startswith _s354_ "mtvec")) then
     match (string_drop _s354_ (projT1 (string_length "mtvec"))) with | s_ => Some (s_) end
   else None.

Definition _s348_ (_s349_ : string) 
: option string :=
   
   let _s350_ := _s349_ in
   if ((string_startswith _s350_ "mie")) then
     match (string_drop _s350_ (projT1 (string_length "mie"))) with | s_ => Some (s_) end
   else None.

Definition _s344_ (_s345_ : string) 
: option string :=
   
   let _s346_ := _s345_ in
   if ((string_startswith _s346_ "mideleg")) then
     match (string_drop _s346_ (projT1 (string_length "mideleg"))) with | s_ => Some (s_) end
   else None.

Definition _s340_ (_s341_ : string) 
: option string :=
   
   let _s342_ := _s341_ in
   if ((string_startswith _s342_ "medeleg")) then
     match (string_drop _s342_ (projT1 (string_length "medeleg"))) with | s_ => Some (s_) end
   else None.

Definition _s336_ (_s337_ : string) 
: option string :=
   
   let _s338_ := _s337_ in
   if ((string_startswith _s338_ "misa")) then
     match (string_drop _s338_ (projT1 (string_length "misa"))) with | s_ => Some (s_) end
   else None.

Definition _s332_ (_s333_ : string) 
: option string :=
   
   let _s334_ := _s333_ in
   if ((string_startswith _s334_ "mstatus")) then
     match (string_drop _s334_ (projT1 (string_length "mstatus"))) with | s_ => Some (s_) end
   else None.

Definition _s328_ (_s329_ : string) 
: option string :=
   
   let _s330_ := _s329_ in
   if ((string_startswith _s330_ "mhartid")) then
     match (string_drop _s330_ (projT1 (string_length "mhartid"))) with | s_ => Some (s_) end
   else None.

Definition _s324_ (_s325_ : string) 
: option string :=
   
   let _s326_ := _s325_ in
   if ((string_startswith _s326_ "mimpid")) then
     match (string_drop _s326_ (projT1 (string_length "mimpid"))) with | s_ => Some (s_) end
   else None.

Definition _s320_ (_s321_ : string) 
: option string :=
   
   let _s322_ := _s321_ in
   if ((string_startswith _s322_ "marchid")) then
     match (string_drop _s322_ (projT1 (string_length "marchid"))) with | s_ => Some (s_) end
   else None.

Definition _s316_ (_s317_ : string) 
: option string :=
   
   let _s318_ := _s317_ in
   if ((string_startswith _s318_ "mvendorid")) then
     match (string_drop _s318_ (projT1 (string_length "mvendorid"))) with | s_ => Some (s_) end
   else None.

Definition _s312_ (_s313_ : string) 
: option string :=
   
   let _s314_ := _s313_ in
   if ((string_startswith _s314_ "satp")) then
     match (string_drop _s314_ (projT1 (string_length "satp"))) with | s_ => Some (s_) end
   else None.

Definition _s308_ (_s309_ : string) 
: option string :=
   
   let _s310_ := _s309_ in
   if ((string_startswith _s310_ "sip")) then
     match (string_drop _s310_ (projT1 (string_length "sip"))) with | s_ => Some (s_) end
   else None.

Definition _s304_ (_s305_ : string) 
: option string :=
   
   let _s306_ := _s305_ in
   if ((string_startswith _s306_ "stval")) then
     match (string_drop _s306_ (projT1 (string_length "stval"))) with | s_ => Some (s_) end
   else None.

Definition _s300_ (_s301_ : string) 
: option string :=
   
   let _s302_ := _s301_ in
   if ((string_startswith _s302_ "scause")) then
     match (string_drop _s302_ (projT1 (string_length "scause"))) with | s_ => Some (s_) end
   else None.

Definition _s296_ (_s297_ : string) 
: option string :=
   
   let _s298_ := _s297_ in
   if ((string_startswith _s298_ "sepc")) then
     match (string_drop _s298_ (projT1 (string_length "sepc"))) with | s_ => Some (s_) end
   else None.

Definition _s292_ (_s293_ : string) 
: option string :=
   
   let _s294_ := _s293_ in
   if ((string_startswith _s294_ "sscratch")) then
     match (string_drop _s294_ (projT1 (string_length "sscratch"))) with | s_ => Some (s_) end
   else None.

Definition _s288_ (_s289_ : string) 
: option string :=
   
   let _s290_ := _s289_ in
   if ((string_startswith _s290_ "scounteren")) then
     match (string_drop _s290_ (projT1 (string_length "scounteren"))) with | s_ => Some (s_) end
   else None.

Definition _s284_ (_s285_ : string) 
: option string :=
   
   let _s286_ := _s285_ in
   if ((string_startswith _s286_ "stvec")) then
     match (string_drop _s286_ (projT1 (string_length "stvec"))) with | s_ => Some (s_) end
   else None.

Definition _s280_ (_s281_ : string) 
: option string :=
   
   let _s282_ := _s281_ in
   if ((string_startswith _s282_ "sie")) then
     match (string_drop _s282_ (projT1 (string_length "sie"))) with | s_ => Some (s_) end
   else None.

Definition _s276_ (_s277_ : string) 
: option string :=
   
   let _s278_ := _s277_ in
   if ((string_startswith _s278_ "sideleg")) then
     match (string_drop _s278_ (projT1 (string_length "sideleg"))) with | s_ => Some (s_) end
   else None.

Definition _s272_ (_s273_ : string) 
: option string :=
   
   let _s274_ := _s273_ in
   if ((string_startswith _s274_ "sedeleg")) then
     match (string_drop _s274_ (projT1 (string_length "sedeleg"))) with | s_ => Some (s_) end
   else None.

Definition _s268_ (_s269_ : string) 
: option string :=
   
   let _s270_ := _s269_ in
   if ((string_startswith _s270_ "sstatus")) then
     match (string_drop _s270_ (projT1 (string_length "sstatus"))) with | s_ => Some (s_) end
   else None.

Definition _s264_ (_s265_ : string) 
: option string :=
   
   let _s266_ := _s265_ in
   if ((string_startswith _s266_ "instreth")) then
     match (string_drop _s266_ (projT1 (string_length "instreth"))) with | s_ => Some (s_) end
   else None.

Definition _s260_ (_s261_ : string) 
: option string :=
   
   let _s262_ := _s261_ in
   if ((string_startswith _s262_ "timeh")) then
     match (string_drop _s262_ (projT1 (string_length "timeh"))) with | s_ => Some (s_) end
   else None.

Definition _s256_ (_s257_ : string) 
: option string :=
   
   let _s258_ := _s257_ in
   if ((string_startswith _s258_ "cycleh")) then
     match (string_drop _s258_ (projT1 (string_length "cycleh"))) with | s_ => Some (s_) end
   else None.

Definition _s252_ (_s253_ : string) 
: option string :=
   
   let _s254_ := _s253_ in
   if ((string_startswith _s254_ "instret")) then
     match (string_drop _s254_ (projT1 (string_length "instret"))) with | s_ => Some (s_) end
   else None.

Definition _s248_ (_s249_ : string) 
: option string :=
   
   let _s250_ := _s249_ in
   if ((string_startswith _s250_ "time")) then
     match (string_drop _s250_ (projT1 (string_length "time"))) with | s_ => Some (s_) end
   else None.

Definition _s244_ (_s245_ : string) 
: option string :=
   
   let _s246_ := _s245_ in
   if ((string_startswith _s246_ "cycle")) then
     match (string_drop _s246_ (projT1 (string_length "cycle"))) with | s_ => Some (s_) end
   else None.

Definition _s240_ (_s241_ : string) 
: option string :=
   
   let _s242_ := _s241_ in
   if ((string_startswith _s242_ "fcsr")) then
     match (string_drop _s242_ (projT1 (string_length "fcsr"))) with | s_ => Some (s_) end
   else None.

Definition _s236_ (_s237_ : string) 
: option string :=
   
   let _s238_ := _s237_ in
   if ((string_startswith _s238_ "frm")) then
     match (string_drop _s238_ (projT1 (string_length "frm"))) with | s_ => Some (s_) end
   else None.

Definition _s232_ (_s233_ : string) 
: option string :=
   
   let _s234_ := _s233_ in
   if ((string_startswith _s234_ "fflags")) then
     match (string_drop _s234_ (projT1 (string_length "fflags"))) with | s_ => Some (s_) end
   else None.

Definition _s228_ (_s229_ : string) 
: option string :=
   
   let _s230_ := _s229_ in
   if ((string_startswith _s230_ "uip")) then
     match (string_drop _s230_ (projT1 (string_length "uip"))) with | s_ => Some (s_) end
   else None.

Definition _s224_ (_s225_ : string) 
: option string :=
   
   let _s226_ := _s225_ in
   if ((string_startswith _s226_ "utval")) then
     match (string_drop _s226_ (projT1 (string_length "utval"))) with | s_ => Some (s_) end
   else None.

Definition _s220_ (_s221_ : string) 
: option string :=
   
   let _s222_ := _s221_ in
   if ((string_startswith _s222_ "ucause")) then
     match (string_drop _s222_ (projT1 (string_length "ucause"))) with | s_ => Some (s_) end
   else None.

Definition _s216_ (_s217_ : string) 
: option string :=
   
   let _s218_ := _s217_ in
   if ((string_startswith _s218_ "uepc")) then
     match (string_drop _s218_ (projT1 (string_length "uepc"))) with | s_ => Some (s_) end
   else None.

Definition _s212_ (_s213_ : string) 
: option string :=
   
   let _s214_ := _s213_ in
   if ((string_startswith _s214_ "uscratch")) then
     match (string_drop _s214_ (projT1 (string_length "uscratch"))) with | s_ => Some (s_) end
   else None.

Definition _s208_ (_s209_ : string) 
: option string :=
   
   let _s210_ := _s209_ in
   if ((string_startswith _s210_ "utvec")) then
     match (string_drop _s210_ (projT1 (string_length "utvec"))) with | s_ => Some (s_) end
   else None.

Definition _s204_ (_s205_ : string) 
: option string :=
   
   let _s206_ := _s205_ in
   if ((string_startswith _s206_ "uie")) then
     match (string_drop _s206_ (projT1 (string_length "uie"))) with | s_ => Some (s_) end
   else None.

Definition _s200_ (_s201_ : string) 
: option string :=
   
   let _s202_ := _s201_ in
   if ((string_startswith _s202_ "ustatus")) then
     match (string_drop _s202_ (projT1 (string_length "ustatus"))) with | s_ => Some (s_) end
   else None.

Definition csr_name_map_matches_prefix (arg_ : string) 
: M (option ((mword 12 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s203_ := arg_ in
   (if ((match (_s200_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s200_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s204_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s204_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s208_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s208_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s212_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s212_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s216_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s216_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s220_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s220_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s224_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s224_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s228_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s228_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s232_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s232_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s236_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s236_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s240_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s240_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s244_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s244_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s248_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s248_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s252_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s252_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s256_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s256_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s260_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s260_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s264_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s264_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s268_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s268_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s272_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s272_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s276_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s276_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s280_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s280_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s284_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s284_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s288_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s288_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s292_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s292_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s296_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s296_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s300_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s300_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s304_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s304_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s308_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s308_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s312_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s312_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s316_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s316_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s320_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s320_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s324_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s324_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s328_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s328_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s332_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s332_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s336_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s336_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s340_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s340_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s344_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s344_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s348_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s348_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s352_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s352_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s356_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s356_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s360_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s360_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s364_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s364_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s368_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s368_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s372_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s372_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s376_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s376_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s380_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s380_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s384_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s384_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s388_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s388_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s392_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s392_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s396_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s396_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s400_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s400_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s404_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s404_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s408_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s408_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s412_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s412_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s416_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s416_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s420_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s420_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s424_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s424_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s428_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s428_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s432_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s432_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s436_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s436_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s440_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s440_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s444_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s444_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s448_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s448_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s452_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s452_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s456_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s456_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s460_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s460_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s464_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s464_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s468_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s468_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s472_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s472_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s476_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s476_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s480_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s480_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s484_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s484_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s488_ _s203_) with | Some (s_) => true | _ => false end)) then
      (match (_s488_ _s203_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 12 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 12 * {n : Z & ArithFact (n >= 0)}))).

Definition Mk_Ustatus (v : mword 64) 
: Ustatus :=
   
   {| Ustatus_Ustatus_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Ustatus_bits (v : Ustatus) 
: mword 64 :=
   
   subrange_vec_dec v.(Ustatus_Ustatus_chunk_0) 63 0.

Definition _set_Ustatus_bits (r_ref : register_ref regstate register_value Ustatus) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Ustatus_Ustatus_chunk_0 :=
         (update_subrange_vec_dec r.(Ustatus_Ustatus_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Ustatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Ustatus_bits (v : Ustatus) (x : mword 64) 
: Ustatus :=
   
   {[ v with
     Ustatus_Ustatus_chunk_0 :=
       (update_subrange_vec_dec v.(Ustatus_Ustatus_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Ustatus_UPIE (v : Ustatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Ustatus_Ustatus_chunk_0) 4 4.

Definition _set_Ustatus_UPIE (r_ref : register_ref regstate register_value Ustatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Ustatus_Ustatus_chunk_0 :=
         (update_subrange_vec_dec r.(Ustatus_Ustatus_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Ustatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Ustatus_UPIE (v : Ustatus) (x : mword 1) 
: Ustatus :=
   
   {[ v with
     Ustatus_Ustatus_chunk_0 :=
       (update_subrange_vec_dec v.(Ustatus_Ustatus_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Ustatus_UIE (v : Ustatus) 
: mword 1 :=
   
   subrange_vec_dec v.(Ustatus_Ustatus_chunk_0) 0 0.

Definition _set_Ustatus_UIE (r_ref : register_ref regstate register_value Ustatus) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Ustatus_Ustatus_chunk_0 :=
         (update_subrange_vec_dec r.(Ustatus_Ustatus_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Ustatus in
   write_reg r_ref r
    : M (unit).

Definition _update_Ustatus_UIE (v : Ustatus) (x : mword 1) 
: Ustatus :=
   
   {[ v with
     Ustatus_Ustatus_chunk_0 :=
       (update_subrange_vec_dec v.(Ustatus_Ustatus_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition lower_sstatus (s : Sstatus) 
: Ustatus :=
   
   let u := Mk_Ustatus (EXTZ 64 (vec_of_bits [B0]  : mword 1)) in
   let u := _update_Ustatus_UPIE u (_get_Sstatus_UPIE s) in
   _update_Ustatus_UIE u (_get_Sstatus_UIE s).

Definition lift_ustatus (s : Sstatus) (u : Ustatus) 
: Sstatus :=
   
   let s := _update_Sstatus_UPIE s (_get_Ustatus_UPIE u) in
   _update_Sstatus_UIE s (_get_Ustatus_UIE u).

Definition legalize_ustatus (m : Mstatus) (v : mword 64) 
: M (Mstatus) :=
   
   let u := Mk_Ustatus v in
   let s := lower_mstatus m in
   let s := lift_ustatus s u in
   (lift_sstatus m s)
    : M (Mstatus).

Definition Mk_Uinterrupts (v : mword 64) 
: Uinterrupts :=
   
   {| Uinterrupts_Uinterrupts_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_Uinterrupts_bits (v : Uinterrupts) 
: mword 64 :=
   
   subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 63 0.

Definition _set_Uinterrupts_bits
(r_ref : register_ref regstate register_value Uinterrupts) (v : mword 64) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Uinterrupts_Uinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Uinterrupts_Uinterrupts_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : Uinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Uinterrupts_bits (v : Uinterrupts) (x : mword 64) 
: Uinterrupts :=
   
   {[ v with
     Uinterrupts_Uinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_Uinterrupts_UEI (v : Uinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 8 8.

Definition _set_Uinterrupts_UEI
(r_ref : register_ref regstate register_value Uinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Uinterrupts_Uinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Uinterrupts_Uinterrupts_chunk_0) 8 8 (subrange_vec_dec v 0 0)) ]}
      : Uinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Uinterrupts_UEI (v : Uinterrupts) (x : mword 1) 
: Uinterrupts :=
   
   {[ v with
     Uinterrupts_Uinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 8 8 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Uinterrupts_UTI (v : Uinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 4 4.

Definition _set_Uinterrupts_UTI
(r_ref : register_ref regstate register_value Uinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Uinterrupts_Uinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Uinterrupts_Uinterrupts_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : Uinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Uinterrupts_UTI (v : Uinterrupts) (x : mword 1) 
: Uinterrupts :=
   
   {[ v with
     Uinterrupts_Uinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_Uinterrupts_USI (v : Uinterrupts) 
: mword 1 :=
   
   subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 0 0.

Definition _set_Uinterrupts_USI
(r_ref : register_ref regstate register_value Uinterrupts) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       Uinterrupts_Uinterrupts_chunk_0 :=
         (update_subrange_vec_dec r.(Uinterrupts_Uinterrupts_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : Uinterrupts in
   write_reg r_ref r
    : M (unit).

Definition _update_Uinterrupts_USI (v : Uinterrupts) (x : mword 1) 
: Uinterrupts :=
   
   {[ v with
     Uinterrupts_Uinterrupts_chunk_0 :=
       (update_subrange_vec_dec v.(Uinterrupts_Uinterrupts_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition lower_sip (s : Sinterrupts) (d : Sinterrupts) 
: Uinterrupts :=
   
   let u : Uinterrupts := Mk_Uinterrupts (EXTZ 64 (vec_of_bits [B0]  : mword 1)) in
   let u := _update_Uinterrupts_UEI u (and_vec (_get_Sinterrupts_UEI s) (_get_Sinterrupts_UEI d)) in
   let u := _update_Uinterrupts_UTI u (and_vec (_get_Sinterrupts_UTI s) (_get_Sinterrupts_UTI d)) in
   _update_Uinterrupts_USI u (and_vec (_get_Sinterrupts_USI s) (_get_Sinterrupts_USI d)).

Definition lower_sie (s : Sinterrupts) (d : Sinterrupts) 
: Uinterrupts :=
   
   let u : Uinterrupts := Mk_Uinterrupts (EXTZ 64 (vec_of_bits [B0]  : mword 1)) in
   let u := _update_Uinterrupts_UEI u (and_vec (_get_Sinterrupts_UEI s) (_get_Sinterrupts_UEI d)) in
   let u := _update_Uinterrupts_UTI u (and_vec (_get_Sinterrupts_UTI s) (_get_Sinterrupts_UTI d)) in
   _update_Uinterrupts_USI u (and_vec (_get_Sinterrupts_USI s) (_get_Sinterrupts_USI d)).

Definition lift_uip (o : Sinterrupts) (d : Sinterrupts) (u : Uinterrupts) 
: Sinterrupts :=
   
   let s : Sinterrupts := o in
   if ((eq_vec (_get_Sinterrupts_USI d) ((bool_to_bits true)  : mword 1))) then
     _update_Sinterrupts_USI s (_get_Uinterrupts_USI u)
   else s.

Definition legalize_uip (s : Sinterrupts) (d : Sinterrupts) (v : mword 64) 
: Sinterrupts :=
   
   lift_uip s d (Mk_Uinterrupts v).

Definition lift_uie (o : Sinterrupts) (d : Sinterrupts) (u : Uinterrupts) 
: Sinterrupts :=
   
   let s : Sinterrupts := o in
   let s :=
     if ((eq_vec (_get_Sinterrupts_UEI d) ((bool_to_bits true)  : mword 1))) then
       _update_Sinterrupts_UEI s (_get_Uinterrupts_UEI u)
     else s in
   let s :=
     if ((eq_vec (_get_Sinterrupts_UTI d) ((bool_to_bits true)  : mword 1))) then
       _update_Sinterrupts_UTI s (_get_Uinterrupts_UTI u)
     else s in
   if ((eq_vec (_get_Sinterrupts_USI d) ((bool_to_bits true)  : mword 1))) then
     _update_Sinterrupts_USI s (_get_Uinterrupts_USI u)
   else s.

Definition legalize_uie (s : Sinterrupts) (d : Sinterrupts) (v : mword 64) 
: Sinterrupts :=
   
   lift_uie s d (Mk_Uinterrupts v).

Definition handle_trap_extension (p : Privilege) (pc : mword 64) (u : option unit)  : unit :=  tt.

Definition prepare_trap_vector (p : Privilege) (cause : Mcause) 
: M (mword 64) :=
   
   (match p with
    | Machine => read_reg mtvec_ref  : M (Mtvec)
    | Supervisor => read_reg stvec_ref  : M (Mtvec)
    | User => read_reg utvec_ref  : M (Mtvec)
    end) >>= fun tvec : Mtvec =>
   (match (tvec_addr tvec cause) with
    | Some (epc) => returnm (epc  : mword 64)
    | None => (internal_error "Invalid tvec mode")  : M (mword 64)
    end)
    : M (mword 64).

Definition get_xret_target (p : Privilege) 
: M (mword 64) :=
   
   (match p with
    | Machine => ((read_reg mepc_ref)  : M (mword 64))  : M (mword 64)
    | Supervisor => ((read_reg sepc_ref)  : M (mword 64))  : M (mword 64)
    | User => ((read_reg uepc_ref)  : M (mword 64))  : M (mword 64)
    end)
    : M (mword 64).

Definition set_xret_target (p : Privilege) (value : mword 64) 
: M (mword 64) :=
   
   (legalize_xepc value) >>= fun target =>
   (match p with
    | Machine => write_reg mepc_ref target  : M (unit)
    | Supervisor => write_reg sepc_ref target  : M (unit)
    | User => write_reg uepc_ref target  : M (unit)
    end) >>
   returnm (target
    : mword 64).

Definition prepare_xret_target (p : Privilege) 
: M (mword 64) :=
   
   (get_xret_target p)
    : M (mword 64).

Definition get_mtvec '(tt : unit) 
: M (mword 64) :=
   
   read_reg mtvec_ref >>= fun w__0 : Mtvec => returnm ((_get_Mtvec_bits w__0)  : mword 64).

Definition get_stvec '(tt : unit) 
: M (mword 64) :=
   
   read_reg stvec_ref >>= fun w__0 : Mtvec => returnm ((_get_Mtvec_bits w__0)  : mword 64).

Definition get_utvec '(tt : unit) 
: M (mword 64) :=
   
   read_reg utvec_ref >>= fun w__0 : Mtvec => returnm ((_get_Mtvec_bits w__0)  : mword 64).

Definition set_mtvec (value : mword 64) 
: M (mword 64) :=
   
   read_reg mtvec_ref >>= fun w__0 : Mtvec =>
   write_reg mtvec_ref (legalize_tvec w__0 value) >>
   read_reg mtvec_ref >>= fun w__1 : Mtvec => returnm ((_get_Mtvec_bits w__1)  : mword 64).

Definition set_stvec (value : mword 64) 
: M (mword 64) :=
   
   read_reg stvec_ref >>= fun w__0 : Mtvec =>
   write_reg stvec_ref (legalize_tvec w__0 value) >>
   read_reg stvec_ref >>= fun w__1 : Mtvec => returnm ((_get_Mtvec_bits w__1)  : mword 64).

Definition set_utvec (value : mword 64) 
: M (mword 64) :=
   
   read_reg utvec_ref >>= fun w__0 : Mtvec =>
   write_reg utvec_ref (legalize_tvec w__0 value) >>
   read_reg utvec_ref >>= fun w__1 : Mtvec => returnm ((_get_Mtvec_bits w__1)  : mword 64).

Definition is_NExt_CSR_defined (csr : mword 12) (p : Privilege) 
: M (bool) :=
   
   let b__0 := csr in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      (haveUsrMode tt)
       : M (bool)
    else returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))})))
    : M (bool).

Definition read_NExt_CSR (csr : mword 12) 
: M (option (mword 64)) :=
   
   let b__0 := csr in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      read_reg mstatus_ref >>= fun w__0 : Mstatus =>
      returnm ((Some
                  (_get_Ustatus_bits (lower_sstatus (lower_mstatus w__0))))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      read_reg mie_ref >>= fun w__1 : Minterrupts =>
      read_reg mideleg_ref >>= fun w__2 : Minterrupts =>
      read_reg sideleg_ref >>= fun w__3 : Sinterrupts =>
      returnm ((Some
                  (_get_Uinterrupts_bits (lower_sie (lower_mie w__1 w__2) w__3)))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      (get_utvec tt) >>= fun w__4 : mword 64 => returnm ((Some (w__4))  : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      ((read_reg uscratch_ref)  : M (mword 64)) >>= fun w__5 : mword 64 =>
      returnm ((Some
                  (w__5))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      (get_xret_target User) >>= fun w__6 : mword 64 =>
      (pc_alignment_mask tt) >>= fun w__7 : mword 64 =>
      returnm ((Some
                  (and_vec w__6 w__7))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      read_reg ucause_ref >>= fun w__8 : Mcause =>
      returnm ((Some
                  (_get_Mcause_bits w__8))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      ((read_reg utval_ref)  : M (mword 64)) >>= fun w__9 : mword 64 =>
      returnm ((Some
                  (w__9))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      read_reg mip_ref >>= fun w__10 : Minterrupts =>
      read_reg mideleg_ref >>= fun w__11 : Minterrupts =>
      read_reg sideleg_ref >>= fun w__12 : Sinterrupts =>
      returnm ((Some
                  (_get_Uinterrupts_bits (lower_sip (lower_mip w__10 w__11) w__12)))
       : option (mword 64))
    else returnm (None  : option (mword 64)))
    : M (option xlenbits).

Definition write_NExt_CSR (csr : mword 12) (value : mword 64) 
: M (bool) :=
   
   let b__0 := csr in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      read_reg mstatus_ref >>= fun w__0 : Mstatus =>
      (legalize_ustatus w__0 value) >>= fun w__1 : Mstatus =>
      write_reg mstatus_ref w__1 >>
      read_reg mstatus_ref >>= fun w__2 : Mstatus =>
      returnm ((Some
                  (_get_Mstatus_bits w__2))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      read_reg mie_ref >>= fun w__3 : Minterrupts =>
      read_reg mideleg_ref >>= fun w__4 : Minterrupts =>
      read_reg sideleg_ref >>= fun w__5 : Sinterrupts =>
      let sie := legalize_uie (lower_mie w__3 w__4) w__5 value in
      read_reg mie_ref >>= fun w__6 : Minterrupts =>
      read_reg mideleg_ref >>= fun w__7 : Minterrupts =>
      (lift_sie w__6 w__7 sie) >>= fun w__8 : Minterrupts =>
      write_reg mie_ref w__8 >>
      read_reg mie_ref >>= fun w__9 : Minterrupts =>
      returnm ((Some
                  (_get_Minterrupts_bits w__9))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      (set_utvec value) >>= fun w__10 : mword 64 => returnm ((Some (w__10))  : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      write_reg uscratch_ref value >>
      ((read_reg uscratch_ref)  : M (mword 64)) >>= fun w__11 : mword 64 =>
      returnm ((Some
                  (w__11))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      (set_xret_target User value) >>= fun w__12 : mword 64 =>
      returnm ((Some
                  (w__12))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      (_set_Mcause_bits ucause_ref value) >>
      read_reg ucause_ref >>= fun w__13 : Mcause =>
      returnm ((Some
                  (_get_Mcause_bits w__13))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      write_reg utval_ref value >>
      ((read_reg utval_ref)  : M (mword 64)) >>= fun w__14 : mword 64 =>
      returnm ((Some
                  (w__14))
       : option (mword 64))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      read_reg mip_ref >>= fun w__15 : Minterrupts =>
      read_reg mideleg_ref >>= fun w__16 : Minterrupts =>
      read_reg sideleg_ref >>= fun w__17 : Sinterrupts =>
      let sip := legalize_uip (lower_mip w__15 w__16) w__17 value in
      read_reg mip_ref >>= fun w__18 : Minterrupts =>
      read_reg mideleg_ref >>= fun w__19 : Minterrupts =>
      (lift_sip w__18 w__19 sip) >>= fun w__20 : Minterrupts =>
      write_reg mip_ref w__20 >>
      read_reg mip_ref >>= fun w__21 : Minterrupts =>
      returnm ((Some
                  (_get_Minterrupts_bits w__21))
       : option (mword 64))
    else returnm (None  : option (mword 64))) >>= fun res : option xlenbits =>
   returnm ((match res with
             | Some (v) =>
                let '_ :=
                  (if ((get_config_print_reg tt)) then
                     print_endline
                       (String.append "CSR "
                          (String.append (csr_name csr)
                             (String.append " <- "
                                (String.append (string_of_bits v)
                                   (String.append " (input: "
                                      (String.append (string_of_bits value) ")"))))))
                   else tt)
                   : unit in
                true
             | None => false
             end)
    : bool).

Definition ext_is_CSR_defined (csr : mword 12) (p : Privilege) 
: M (bool) :=
   
   (is_NExt_CSR_defined csr p)
    : M (bool).

Definition ext_read_CSR (csr : mword 12) 
: M (option (mword 64)) :=
   
   (read_NExt_CSR csr)
    : M (option (mword 64)).

Definition ext_write_CSR (csr : mword 12) (value : mword 64) 
: M (bool) :=
   
   (write_NExt_CSR csr value)
    : M (bool).

Definition csrAccess (csr : mword 12)  : mword 2 :=  subrange_vec_dec csr 11 10.

Definition csrPriv (csr : mword 12)  : mword 2 :=  subrange_vec_dec csr 9 8.

Definition is_CSR_defined (csr : mword 12) (p : Privilege) 
: M (bool) :=
   
   let b__0 := csr in
   (if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm (projT1
      (build_ex
      (andb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2)) (Z.eqb 64 32))
       : {_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (simp_0 = true /\ 64 = 32))}))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B1]  : mword 12))) then
      returnm (projT1
      (build_ex
      (andb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2)) (Z.eqb 64 32))
       : {_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (simp_0 = true /\ 64 = 32))}))
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm (projT1
      (build_ex
      (andb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2)) (Z.eqb 64 32))
       : {_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (simp_0 = true /\ 64 = 32))}))
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm (projT1
      (build_ex
      (andb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2)) (Z.eqb 64 32))
       : {_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (simp_0 = true /\ 64 = 32))}))
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      (and_boolM ((haveSupMode tt)  : M (bool))
         (returnm ((orb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Machine)  : mword 2))
                      (eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2)))
           : bool)))
       : M (bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits User)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits User)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits User)  : mword 2))
       : bool)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
      returnm (projT1
      (build_ex
      (andb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits User)  : mword 2)) (Z.eqb 64 32))
       : {_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (simp_0 = true /\ 64 = 32))}))
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
      returnm (projT1
      (build_ex
      (andb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits User)  : mword 2)) (Z.eqb 64 32))
       : {_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (simp_0 = true /\ 64 = 32))}))
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
      returnm (projT1
      (build_ex
      (andb (eq_vec (privLevel_to_bits p) ((privLevel_to_bits User)  : mword 2)) (Z.eqb 64 32))
       : {_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (simp_0 = true /\ 64 = 32))}))
    else (ext_is_CSR_defined csr p)  : M (bool))
    : M (bool).

Definition check_CSR_access (csrrw : mword 2) (csrpr : mword 2) (p : Privilege) (isWrite : bool) 
: bool :=
   
   andb (negb (andb (Bool.eqb isWrite true) (eq_vec csrrw (vec_of_bits [B1;B1]  : mword 2))))
     (zopz0zKzJ_u (privLevel_to_bits p) csrpr).

Definition check_TVM_SATP (csr : mword 12) (p : Privilege) 
: M (bool) :=
   
   (and_boolM
      (returnm ((eq_vec csr (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))
        : bool))
      ((and_boolM
          (returnm ((eq_vec (privLevel_to_bits p) ((privLevel_to_bits Supervisor)  : mword 2))
            : bool))
          (read_reg mstatus_ref >>= fun w__0 : Mstatus =>
           returnm ((eq_vec (_get_Mstatus_TVM w__0) ((bool_to_bits true)  : mword 1))
            : bool)))
       : M (bool))) >>= fun w__2 : bool =>
   returnm ((negb w__2)
    : bool).

Definition check_Counteren (csr : mword 12) (p : Privilege) 
: M (bool) :=
   
   (match (csr, p) with
    | (b__0, Supervisor) =>
       (if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          read_reg mcounteren_ref >>= fun w__0 : Counteren =>
          returnm ((eq_vec (_get_Counteren_CY w__0) ((bool_to_bits true)  : mword 1))
           : bool)
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          read_reg mcounteren_ref >>= fun w__1 : Counteren =>
          returnm ((eq_vec (_get_Counteren_TM w__1) ((bool_to_bits true)  : mword 1))
           : bool)
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          read_reg mcounteren_ref >>= fun w__2 : Counteren =>
          returnm ((eq_vec (_get_Counteren_IR w__2) ((bool_to_bits true)  : mword 1))
           : bool)
        else
          returnm ((match (b__0, Supervisor) with
                    | (_, _) =>
                       if ((andb
                              (zopz0zIzJ_u
                                 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12) csr)
                              (zopz0zIzJ_u csr
                                 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1]  : mword 12))))
                       then
                         false
                       else true
                    end)
           : bool))
        : M (bool)
    | (b__3, User) =>
       (if ((eq_vec b__3 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          (and_boolM
             (read_reg mcounteren_ref >>= fun w__6 : Counteren =>
              returnm ((eq_vec (_get_Counteren_CY w__6) ((bool_to_bits true)  : mword 1))
               : bool))
             ((or_boolM ((haveSupMode tt) >>= fun w__7 : bool => returnm ((negb w__7)  : bool))
                 (read_reg scounteren_ref >>= fun w__8 : Counteren =>
                  returnm ((eq_vec (_get_Counteren_CY w__8) ((bool_to_bits true)  : mword 1))
                   : bool)))
              : M (bool)))
           : M (bool)
        else if ((eq_vec b__3 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          (and_boolM
             (read_reg mcounteren_ref >>= fun w__11 : Counteren =>
              returnm ((eq_vec (_get_Counteren_TM w__11) ((bool_to_bits true)  : mword 1))
               : bool))
             ((or_boolM ((haveSupMode tt) >>= fun w__12 : bool => returnm ((negb w__12)  : bool))
                 (read_reg scounteren_ref >>= fun w__13 : Counteren =>
                  returnm ((eq_vec (_get_Counteren_TM w__13) ((bool_to_bits true)  : mword 1))
                   : bool)))
              : M (bool)))
           : M (bool)
        else if ((eq_vec b__3 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          (and_boolM
             (read_reg mcounteren_ref >>= fun w__16 : Counteren =>
              returnm ((eq_vec (_get_Counteren_IR w__16) ((bool_to_bits true)  : mword 1))
               : bool))
             ((or_boolM ((haveSupMode tt) >>= fun w__17 : bool => returnm ((negb w__17)  : bool))
                 (read_reg scounteren_ref >>= fun w__18 : Counteren =>
                  returnm ((eq_vec (_get_Counteren_IR w__18) ((bool_to_bits true)  : mword 1))
                   : bool)))
              : M (bool)))
           : M (bool)
        else
          returnm ((match (b__3, User) with
                    | (_, _) =>
                       if ((andb
                              (zopz0zIzJ_u
                                 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12) csr)
                              (zopz0zIzJ_u csr
                                 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1]  : mword 12))))
                       then
                         false
                       else true
                    end)
           : bool))
        : M (bool)
    | (_, _) =>
       returnm ((if ((andb
                        (zopz0zIzJ_u (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12)
                           csr)
                        (zopz0zIzJ_u csr
                           (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B1;B1;B1;B1;B1]  : mword 12)))) then
                   false
                 else true)
        : bool)
    end)
    : M (bool).

Definition check_CSR (csr : mword 12) (p : Privilege) (isWrite : bool) 
: M (bool) :=
   
   (and_boolM ((is_CSR_defined csr p)  : M (bool))
      ((and_boolM (returnm ((check_CSR_access (csrAccess csr) (csrPriv csr) p isWrite)  : bool))
          ((and_boolM ((check_TVM_SATP csr p)  : M (bool)) ((check_Counteren csr p)  : M (bool)))
           : M (bool)))
       : M (bool)))
    : M (bool).

Axiom speculate_conditional : forall  (_ : unit) , M (bool).

Axiom load_reservation : forall  (_ : mword 64) , unit.

Axiom match_reservation : forall  (_ : mword 64) , bool.

Axiom cancel_reservation : forall  (_ : unit) , unit.

Definition exception_delegatee (e : ExceptionType) (p : Privilege) 
: M (Privilege) :=
   
   let idx := projT1 (num_of_ExceptionType e) in
   read_reg medeleg_ref >>= fun w__0 : Medeleg =>
   let super := access_vec_dec (_get_Medeleg_bits w__0) idx in
   (haveSupMode tt) >>= fun w__1 : bool =>
   (if sumbool_of_bool (w__1) then
      (and_boolM ((bit_to_bool super)  : M (bool))
         ((and_boolM ((haveNExt tt)  : M (bool))
             (read_reg sedeleg_ref >>= fun w__4 : Sedeleg =>
              (bit_to_bool (access_vec_dec (_get_Sedeleg_bits w__4) idx))
               : M (bool)))
          : M (bool)))
       : M (bool)
    else (and_boolM ((bit_to_bool super)  : M (bool)) ((haveNExt tt)  : M (bool)))  : M (bool)) >>= fun user =>
   (and_boolMP (build_trivial_ex ((haveUsrMode tt)  : M (bool)))
      ((returnm (build_ex
        user)) : M ({_bool : bool & ArithFact (iff (_bool = true) (user = true))})) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
     true) (user = true /\ simp_0 = true))})) >>= fun '(existT _ w__12 _) =>
   (if sumbool_of_bool (w__12) then returnm (User  : Privilege)
    else
      (and_boolM ((haveSupMode tt)  : M (bool)) ((bit_to_bool super)  : M (bool))) >>= fun w__15 : bool =>
      returnm ((if sumbool_of_bool (w__15) then Supervisor
                else Machine)
       : Privilege)) >>= fun deleg =>
   returnm ((if ((zopz0zI_u (privLevel_to_bits deleg) (privLevel_to_bits p))) then p
             else deleg)
    : Privilege).

Definition findPendingInterrupt (ip : mword 64) 
: option InterruptType :=
   
   let ip := Mk_Minterrupts ip in
   if ((eq_vec (_get_Minterrupts_MEI ip) ((bool_to_bits true)  : mword 1))) then Some (I_M_External)
   else if ((eq_vec (_get_Minterrupts_MSI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_M_Software)
   else if ((eq_vec (_get_Minterrupts_MTI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_M_Timer)
   else if ((eq_vec (_get_Minterrupts_SEI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_S_External)
   else if ((eq_vec (_get_Minterrupts_SSI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_S_Software)
   else if ((eq_vec (_get_Minterrupts_STI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_S_Timer)
   else if ((eq_vec (_get_Minterrupts_UEI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_U_External)
   else if ((eq_vec (_get_Minterrupts_USI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_U_Software)
   else if ((eq_vec (_get_Minterrupts_UTI ip) ((bool_to_bits true)  : mword 1))) then
     Some
       (I_U_Timer)
   else None.

Definition processPending
(xip : Minterrupts) (xie : Minterrupts) (xideleg : mword 64) (priv_enabled : bool) 
: interrupt_set :=
   
   let effective_pend :=
     and_vec (_get_Minterrupts_bits xip) (and_vec (_get_Minterrupts_bits xie) (not_vec xideleg)) in
   let effective_delg := and_vec (_get_Minterrupts_bits xip) xideleg in
   if sumbool_of_bool ((andb priv_enabled
                          (neq_vec effective_pend (EXTZ 64 (vec_of_bits [B0]  : mword 1))))) then
     Ints_Pending
       (effective_pend)
   else if ((neq_vec effective_delg (EXTZ 64 (vec_of_bits [B0]  : mword 1)))) then
     Ints_Delegated
       (effective_delg)
   else Ints_Empty (tt).

Definition getPendingSet (priv : Privilege) 
: M (option ((mword 64 * Privilege))) :=
   
   (haveUsrMode tt) >>= fun w__0 : bool =>
   assert_exp' w__0 "no user mode: M/U or M/S/U system required" >>= fun _ =>
   read_reg mip_ref >>= fun w__1 : Minterrupts =>
   read_reg mie_ref >>= fun w__2 : Minterrupts =>
   let effective_pending := and_vec (_get_Minterrupts_bits w__1) (_get_Minterrupts_bits w__2) in
   (if ((eq_vec effective_pending (EXTZ 64 (vec_of_bits [B0]  : mword 1)))) then
      returnm (None
       : option ((mword 64 * Privilege)))
    else
      (or_boolM
         (returnm ((neq_vec (privLevel_to_bits priv) ((privLevel_to_bits Machine)  : mword 2))
           : bool))
         ((and_boolM
             (returnm ((eq_vec (privLevel_to_bits priv) ((privLevel_to_bits Machine)  : mword 2))
               : bool))
             (read_reg mstatus_ref >>= fun w__3 : Mstatus =>
              returnm ((eq_vec (_get_Mstatus_MIE w__3) ((bool_to_bits true)  : mword 1))
               : bool)))
          : M (bool))) >>= fun mIE =>
      (and_boolM ((haveSupMode tt)  : M (bool))
         ((or_boolM
             (returnm ((eq_vec (privLevel_to_bits priv) ((privLevel_to_bits User)  : mword 2))
               : bool))
             ((and_boolM
                 (returnm ((eq_vec (privLevel_to_bits priv)
                              ((privLevel_to_bits Supervisor)
                               : mword 2))
                   : bool))
                 (read_reg mstatus_ref >>= fun w__6 : Mstatus =>
                  returnm ((eq_vec (_get_Mstatus_SIE w__6) ((bool_to_bits true)  : mword 1))
                   : bool)))
              : M (bool)))
          : M (bool))) >>= fun sIE =>
      (and_boolM ((haveNExt tt)  : M (bool))
         ((and_boolM
             (returnm ((eq_vec (privLevel_to_bits priv) ((privLevel_to_bits User)  : mword 2))
               : bool))
             (read_reg mstatus_ref >>= fun w__10 : Mstatus =>
              returnm ((eq_vec (_get_Mstatus_UIE w__10) ((bool_to_bits true)  : mword 1))
               : bool)))
          : M (bool))) >>= fun uIE =>
      read_reg mip_ref >>= fun w__12 : Minterrupts =>
      read_reg mie_ref >>= fun w__13 : Minterrupts =>
      read_reg mideleg_ref >>= fun w__14 : Minterrupts =>
      (match (processPending w__12 w__13 (_get_Minterrupts_bits w__14) mIE) with
       | Ints_Empty (tt) => returnm (None  : option ((mword 64 * Privilege)))
       | Ints_Pending (p) =>
          let r := (p, Machine) in
          returnm ((Some
                      (r))
           : option ((mword 64 * Privilege)))
       | Ints_Delegated (d) =>
          (haveSupMode tt) >>= fun w__15 : bool =>
          (if sumbool_of_bool ((negb w__15)) then
             returnm ((if sumbool_of_bool (uIE) then
                         let r := (d, User) in
                         Some
                           (r)
                       else None)
              : option ((mword 64 * Privilege)))
           else
             read_reg mie_ref >>= fun w__16 : Minterrupts =>
             read_reg sideleg_ref >>= fun w__17 : Sinterrupts =>
             returnm ((match (processPending (Mk_Minterrupts d) w__16 (_get_Sinterrupts_bits w__17)
                                sIE) with
                       | Ints_Empty (tt) => None
                       | Ints_Pending (p) =>
                          let r := (p, Supervisor) in
                          Some
                            (r)
                       | Ints_Delegated (d) =>
                          if sumbool_of_bool (uIE) then
                            let r := (d, User) in
                            Some
                              (r)
                          else None
                       end)
              : option ((mword 64 * Privilege))))
           : M (option ((mword 64 * Privilege)))
       end)
       : M (option ((mword 64 * Privilege))))
    : M (option ((mword 64 * Privilege))).

Definition dispatchInterrupt (priv : Privilege) 
: M (option ((InterruptType * Privilege))) :=
   
   (or_boolM ((haveUsrMode tt) >>= fun w__0 : bool => returnm ((negb w__0)  : bool))
      ((and_boolM ((haveSupMode tt) >>= fun w__1 : bool => returnm ((negb w__1)  : bool))
          ((haveNExt tt) >>= fun w__2 : bool => returnm ((negb w__2)  : bool)))
       : M (bool))) >>= fun w__4 : bool =>
   (if sumbool_of_bool (w__4) then
      assert_exp (eq_vec (privLevel_to_bits priv) ((privLevel_to_bits Machine)  : mword 2)) "invalid current privilege" >>
      read_reg mip_ref >>= fun w__5 : Minterrupts =>
      read_reg mie_ref >>= fun w__6 : Minterrupts =>
      let enabled_pending := and_vec (_get_Minterrupts_bits w__5) (_get_Minterrupts_bits w__6) in
      returnm ((match (findPendingInterrupt enabled_pending) with
                | Some (i) =>
                   let r := (i, Machine) in
                   Some
                     (r)
                | None => None
                end)
       : option ((InterruptType * Privilege)))
    else
      (getPendingSet priv) >>= fun w__7 : option ((mword 64 * Privilege)) =>
      returnm ((match w__7 with
                | None => None
                | Some ((ip, p)) =>
                   match (findPendingInterrupt ip) with
                   | None => None
                   | Some (i) =>
                      let r := (i, p) in
                      Some
                        (r)
                   end
                end)
       : option ((InterruptType * Privilege))))
    : M (option ((InterruptType * Privilege))).

Definition tval (excinfo : option (mword 64)) 
: mword 64 :=
   
   match excinfo with | Some (e) => e | None => EXTZ 64 (vec_of_bits [B0]  : mword 1) end.

Definition rvfi_trap '(tt : unit)  : unit :=  tt.

Definition trap_handler
(del_priv : Privilege) (intr : bool) (c : mword 8) (pc : mword 64) (info : option (mword 64))
(ext : option unit) 
: M (mword 64) :=
   
   let '_ := (rvfi_trap tt)  : unit in
   let '_ :=
     (if ((get_config_print_platform tt)) then
        print_endline
          (String.append "handling "
             (String.append (if sumbool_of_bool (intr) then "int#" else "exc#")
                (String.append (string_of_bits c)
                   (String.append " at priv "
                      (String.append (privLevel_to_str del_priv)
                         (String.append " with tval " (string_of_bits (tval info))))))))
      else tt)
      : unit in
   let '_ := (cancel_reservation tt)  : unit in
   (match del_priv with
    | Machine =>
       (_set_Mcause_IsInterrupt mcause_ref ((bool_to_bits intr)  : mword 1)) >>
       (_set_Mcause_Cause mcause_ref (EXTZ 63 c)) >>
       read_reg mstatus_ref >>= fun w__0 : Mstatus =>
       (_set_Mstatus_MPIE mstatus_ref (_get_Mstatus_MIE w__0)) >>
       (_set_Mstatus_MIE mstatus_ref ((bool_to_bits false)  : mword 1)) >>
       read_reg cur_privilege_ref >>= fun w__1 : Privilege =>
       (_set_Mstatus_MPP mstatus_ref (privLevel_to_bits w__1)) >>
       write_reg mtval_ref (tval info) >>
       write_reg mepc_ref pc >>
       write_reg cur_privilege_ref del_priv >>
       let '_ := (handle_trap_extension del_priv pc ext)  : unit in
       (if ((get_config_print_reg tt)) then
          read_reg mstatus_ref >>= fun w__2 : Mstatus =>
          returnm ((print_endline
                      (String.append "CSR mstatus <- " (string_of_bits (_get_Mstatus_bits w__2))))
           : unit)
        else returnm (tt  : unit)) >>
       read_reg mcause_ref >>= fun w__3 : Mcause =>
       (prepare_trap_vector del_priv w__3)
        : M (mword 64)
    | Supervisor =>
       (haveSupMode tt) >>= fun w__5 : bool =>
       assert_exp' w__5 "no supervisor mode present for delegation" >>= fun _ =>
       (_set_Mcause_IsInterrupt scause_ref ((bool_to_bits intr)  : mword 1)) >>
       (_set_Mcause_Cause scause_ref (EXTZ 63 c)) >>
       read_reg mstatus_ref >>= fun w__6 : Mstatus =>
       (_set_Mstatus_SPIE mstatus_ref (_get_Mstatus_SIE w__6)) >>
       (_set_Mstatus_SIE mstatus_ref ((bool_to_bits false)  : mword 1)) >>
       read_reg cur_privilege_ref >>= fun w__7 : Privilege =>
       (match w__7 with
        | User => returnm ((bool_to_bits false)  : mword 1)
        | Supervisor => returnm ((bool_to_bits true)  : mword 1)
        | Machine => (internal_error "invalid privilege for s-mode trap")  : M (mword 1)
        end) >>= fun w__9 : mword 1 =>
       (_set_Mstatus_SPP mstatus_ref w__9) >>
       write_reg stval_ref (tval info) >>
       write_reg sepc_ref pc >>
       write_reg cur_privilege_ref del_priv >>
       let '_ := (handle_trap_extension del_priv pc ext)  : unit in
       (if ((get_config_print_reg tt)) then
          read_reg mstatus_ref >>= fun w__10 : Mstatus =>
          returnm ((print_endline
                      (String.append "CSR mstatus <- " (string_of_bits (_get_Mstatus_bits w__10))))
           : unit)
        else returnm (tt  : unit)) >>
       read_reg scause_ref >>= fun w__11 : Mcause =>
       (prepare_trap_vector del_priv w__11)
        : M (mword 64)
    | User =>
       (haveUsrMode tt) >>= fun w__13 : bool =>
       assert_exp' w__13 "no user mode present for delegation" >>= fun _ =>
       (_set_Mcause_IsInterrupt ucause_ref ((bool_to_bits intr)  : mword 1)) >>
       (_set_Mcause_Cause ucause_ref (EXTZ 63 c)) >>
       read_reg mstatus_ref >>= fun w__14 : Mstatus =>
       (_set_Mstatus_UPIE mstatus_ref (_get_Mstatus_UIE w__14)) >>
       (_set_Mstatus_UIE mstatus_ref ((bool_to_bits false)  : mword 1)) >>
       write_reg utval_ref (tval info) >>
       write_reg uepc_ref pc >>
       write_reg cur_privilege_ref del_priv >>
       let '_ := (handle_trap_extension del_priv pc ext)  : unit in
       (if ((get_config_print_reg tt)) then
          read_reg mstatus_ref >>= fun w__15 : Mstatus =>
          returnm ((print_endline
                      (String.append "CSR mstatus <- " (string_of_bits (_get_Mstatus_bits w__15))))
           : unit)
        else returnm (tt  : unit)) >>
       read_reg ucause_ref >>= fun w__16 : Mcause =>
       (prepare_trap_vector del_priv w__16)
        : M (mword 64)
    end)
    : M (mword 64).

Definition exception_handler (cur_priv : Privilege) (ctl : ctl_result) (pc : mword 64) 
: M (mword 64) :=
   
   (match (cur_priv, ctl) with
    | (_, CTL_TRAP (e)) =>
       (exception_delegatee e.(sync_exception_trap) cur_priv) >>= fun del_priv =>
       let '_ :=
         (if ((get_config_print_platform tt)) then
            print_endline
              (String.append "trapping from "
                 (String.append (privLevel_to_str cur_priv)
                    (String.append " to "
                       (String.append (privLevel_to_str del_priv)
                          (String.append " to handle "
                             (exceptionType_to_str e.(sync_exception_trap)))))))
          else tt)
          : unit in
       (trap_handler del_priv false ((exceptionType_to_bits e.(sync_exception_trap))  : mword 8) pc
          e.(sync_exception_excinfo) e.(sync_exception_ext))
        : M (mword 64)
    | (_, CTL_MRET (tt)) =>
       read_reg cur_privilege_ref >>= fun prev_priv =>
       read_reg mstatus_ref >>= fun w__1 : Mstatus =>
       (_set_Mstatus_MIE mstatus_ref (_get_Mstatus_MPIE w__1)) >>
       (_set_Mstatus_MPIE mstatus_ref ((bool_to_bits true)  : mword 1)) >>
       read_reg mstatus_ref >>= fun w__2 : Mstatus =>
       (privLevel_of_bits (_get_Mstatus_MPP w__2)) >>= fun w__3 : Privilege =>
       write_reg cur_privilege_ref w__3 >>
       (haveUsrMode tt) >>= fun w__4 : bool =>
       (_set_Mstatus_MPP mstatus_ref
          (privLevel_to_bits (if sumbool_of_bool (w__4) then User else Machine))) >>
       (if ((get_config_print_reg tt)) then
          read_reg mstatus_ref >>= fun w__5 : Mstatus =>
          returnm ((print_endline
                      (String.append "CSR mstatus <- " (string_of_bits (_get_Mstatus_bits w__5))))
           : unit)
        else returnm (tt  : unit)) >>
       (if ((get_config_print_platform tt)) then
          read_reg cur_privilege_ref >>= fun w__6 : Privilege =>
          returnm ((print_endline
                      (String.append "ret-ing from "
                         (String.append (privLevel_to_str prev_priv)
                            (String.append " to " (privLevel_to_str w__6)))))
           : unit)
        else returnm (tt  : unit)) >>
       let '_ := (cancel_reservation tt)  : unit in
       (prepare_xret_target Machine) >>= fun w__7 : mword 64 =>
       (pc_alignment_mask tt) >>= fun w__8 : mword 64 => returnm ((and_vec w__7 w__8)  : mword 64)
    | (_, CTL_SRET (tt)) =>
       read_reg cur_privilege_ref >>= fun prev_priv =>
       read_reg mstatus_ref >>= fun w__9 : Mstatus =>
       (_set_Mstatus_SIE mstatus_ref (_get_Mstatus_SPIE w__9)) >>
       (_set_Mstatus_SPIE mstatus_ref ((bool_to_bits true)  : mword 1)) >>
       read_reg mstatus_ref >>= fun w__10 : Mstatus =>
       write_reg
         cur_privilege_ref
         (if ((eq_vec (_get_Mstatus_SPP w__10) ((bool_to_bits true)  : mword 1))) then Supervisor
          else User) >>
       (_set_Mstatus_SPP mstatus_ref ((bool_to_bits false)  : mword 1)) >>
       (if ((get_config_print_reg tt)) then
          read_reg mstatus_ref >>= fun w__11 : Mstatus =>
          returnm ((print_endline
                      (String.append "CSR mstatus <- " (string_of_bits (_get_Mstatus_bits w__11))))
           : unit)
        else returnm (tt  : unit)) >>
       (if ((get_config_print_platform tt)) then
          read_reg cur_privilege_ref >>= fun w__12 : Privilege =>
          returnm ((print_endline
                      (String.append "ret-ing from "
                         (String.append (privLevel_to_str prev_priv)
                            (String.append " to " (privLevel_to_str w__12)))))
           : unit)
        else returnm (tt  : unit)) >>
       let '_ := (cancel_reservation tt)  : unit in
       (prepare_xret_target Supervisor) >>= fun w__13 : mword 64 =>
       (pc_alignment_mask tt) >>= fun w__14 : mword 64 =>
       returnm ((and_vec w__13 w__14)
        : mword 64)
    | (_, CTL_URET (tt)) =>
       read_reg cur_privilege_ref >>= fun prev_priv =>
       read_reg mstatus_ref >>= fun w__15 : Mstatus =>
       (_set_Mstatus_UIE mstatus_ref (_get_Mstatus_UPIE w__15)) >>
       (_set_Mstatus_UPIE mstatus_ref ((bool_to_bits true)  : mword 1)) >>
       write_reg cur_privilege_ref User >>
       (if ((get_config_print_reg tt)) then
          read_reg mstatus_ref >>= fun w__16 : Mstatus =>
          returnm ((print_endline
                      (String.append "CSR mstatus <- " (string_of_bits (_get_Mstatus_bits w__16))))
           : unit)
        else returnm (tt  : unit)) >>
       (if ((get_config_print_platform tt)) then
          read_reg cur_privilege_ref >>= fun w__17 : Privilege =>
          returnm ((print_endline
                      (String.append "ret-ing from "
                         (String.append (privLevel_to_str prev_priv)
                            (String.append " to " (privLevel_to_str w__17)))))
           : unit)
        else returnm (tt  : unit)) >>
       let '_ := (cancel_reservation tt)  : unit in
       (prepare_xret_target User) >>= fun w__18 : mword 64 =>
       (pc_alignment_mask tt) >>= fun w__19 : mword 64 =>
       returnm ((and_vec w__18 w__19)
        : mword 64)
    end)
    : M (mword 64).

Definition handle_mem_exception (addr : mword 64) (e : ExceptionType) 
: M (unit) :=
   
   let t : sync_exception :=
     {| sync_exception_trap := e; 
        sync_exception_excinfo := (Some (addr)); 
        sync_exception_ext := None |} in
   read_reg cur_privilege_ref >>= fun w__0 : Privilege =>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   (exception_handler w__0 (CTL_TRAP (t)) w__1) >>= fun w__2 : mword 64 =>
   (set_next_pc w__2)
    : M (unit).

Definition handle_interrupt (i : InterruptType) (del_priv : Privilege) 
: M (unit) :=
   
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   (trap_handler del_priv true ((interruptType_to_bits i)  : mword 8) w__0 None None) >>= fun w__1 : mword 64 =>
   (set_next_pc w__1)
    : M (unit).

Definition init_sys '(tt : unit) 
: M (unit) :=
   
   write_reg cur_privilege_ref Machine >>
   write_reg mhartid_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   (_set_Misa_MXL misa_ref (arch_to_bits RV64)) >>
   (_set_Misa_A misa_ref ((bool_to_bits true)  : mword 1)) >>
   (_set_Misa_C misa_ref ((bool_to_bits (sys_enable_rvc tt))  : mword 1)) >>
   (_set_Misa_I misa_ref ((bool_to_bits true)  : mword 1)) >>
   (_set_Misa_M misa_ref ((bool_to_bits true)  : mword 1)) >>
   (_set_Misa_U misa_ref ((bool_to_bits true)  : mword 1)) >>
   (_set_Misa_S misa_ref ((bool_to_bits true)  : mword 1)) >>
   read_reg mstatus_ref >>= fun w__0 : Mstatus =>
   read_reg misa_ref >>= fun w__1 : Misa =>
   write_reg mstatus_ref (set_mstatus_SXL w__0 (_get_Misa_MXL w__1)) >>
   read_reg mstatus_ref >>= fun w__2 : Mstatus =>
   read_reg misa_ref >>= fun w__3 : Misa =>
   write_reg mstatus_ref (set_mstatus_UXL w__2 (_get_Misa_MXL w__3)) >>
   (_set_Mstatus_SD mstatus_ref ((bool_to_bits false)  : mword 1)) >>
   (_set_Minterrupts_bits mip_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))) >>
   (_set_Minterrupts_bits mie_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))) >>
   (_set_Minterrupts_bits mideleg_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))) >>
   (_set_Medeleg_bits medeleg_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))) >>
   (_set_Mtvec_bits mtvec_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))) >>
   (_set_Mcause_bits mcause_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))) >>
   write_reg mepc_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   write_reg mtval_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   write_reg mscratch_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   write_reg mcycle_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   write_reg mtime_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   (_set_Counteren_bits mcounteren_ref (EXTZ 32 (vec_of_bits [B0]  : mword 1))) >>
   write_reg minstret_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   write_reg minstret_written_ref false >>
   (init_pmp tt) >>
   (if ((get_config_print_reg tt)) then
      read_reg mstatus_ref >>= fun w__4 : Mstatus =>
      returnm ((print_endline
                  (String.append "CSR mstatus <- "
                     (String.append (string_of_bits (_get_Mstatus_bits w__4))
                        (String.append " (input: "
                           (String.append
                              (string_of_bits ((EXTZ 64 (vec_of_bits [B0]  : mword 1))  : xlenbits))
                              ")")))))
       : unit)
    else returnm (tt  : unit))
    : M (unit).

Axiom elf_tohost : forall  (_ : unit) , Z.

Axiom elf_entry : forall  (_ : unit) , Z.

Axiom plat_ram_base : forall  (_ : unit) , mword 64.

Axiom plat_ram_size : forall  (_ : unit) , mword 64.

Axiom plat_enable_pmp : forall  (_ : unit) , bool.

Axiom plat_enable_dirty_update : forall  (_ : unit) , bool.

Axiom plat_enable_misaligned_access : forall  (_ : unit) , bool.

Axiom plat_mtval_has_illegal_inst_bits : forall  (_ : unit) , bool.

Axiom plat_rom_base : forall  (_ : unit) , mword 64.

Axiom plat_rom_size : forall  (_ : unit) , mword 64.

Axiom plat_clint_base : forall  (_ : unit) , mword 64.

Axiom plat_clint_size : forall  (_ : unit) , mword 64.

Definition plat_htif_tohost '(tt : unit)  : mword 64 :=  to_bits 64 (elf_tohost tt).

Definition phys_mem_segments '(tt : unit) 
: list ((mword 64 * mword 64)) :=
   
   (plat_rom_base tt, plat_rom_size tt) :: (plat_ram_base tt, plat_ram_size tt) :: [].

Definition within_phys_mem (addr : mword 64) (width : Z) `{ArithFact (width <= 16)} 
: bool :=
   
   let addr_int := projT1 (uint addr) in
   let ram_base_int := projT1 (uint (plat_ram_base tt)) in
   let rom_base_int := projT1 (uint (plat_rom_base tt)) in
   let ram_size_int := projT1 (uint (plat_ram_size tt)) in
   let rom_size_int := projT1 (uint (plat_rom_size tt)) in
   if sumbool_of_bool ((andb (Z.leb ram_base_int addr_int)
                          (Z.leb (Z.add addr_int (projT1 (__id width)))
                             (Z.add ram_base_int ram_size_int)))) then
     true
   else if sumbool_of_bool ((andb (Z.leb rom_base_int addr_int)
                               (Z.leb (Z.add addr_int (projT1 (__id width)))
                                  (Z.add rom_base_int rom_size_int)))) then
     true
   else
     let '_ :=
       (print_endline
          (String.append "within_phys_mem: "
             (String.append (string_of_bits addr) " not within phys-mem:")))
        : unit in
     let '_ :=
       (print_endline (String.append "  plat_rom_base: " (string_of_bits (plat_rom_base tt))))
        : unit in
     let '_ :=
       (print_endline (String.append "  plat_rom_size: " (string_of_bits (plat_rom_size tt))))
        : unit in
     let '_ :=
       (print_endline (String.append "  plat_ram_base: " (string_of_bits (plat_ram_base tt))))
        : unit in
     let '_ :=
       (print_endline (String.append "  plat_ram_size: " (string_of_bits (plat_ram_size tt))))
        : unit in
     false.

Definition within_clint (addr : mword 64) (width : Z) `{ArithFact (0 < width /\ width <= 16)} 
: bool :=
   
   let addr_int := projT1 (uint addr) in
   let clint_base_int := projT1 (uint (plat_clint_base tt)) in
   let clint_size_int := projT1 (uint (plat_clint_size tt)) in
   andb (Z.leb clint_base_int addr_int)
     (Z.leb (Z.add addr_int (projT1 (__id width))) (Z.add clint_base_int clint_size_int)).

Definition within_htif_writable (addr : mword 64) (width : Z)
`{ArithFact (0 < width /\ width <= 16)} 
: bool :=
   
   orb (eq_vec (plat_htif_tohost tt) addr)
     (andb (eq_vec (add_vec_int (plat_htif_tohost tt) 4) addr) (Z.eqb width 4)).

Definition within_htif_readable (addr : mword 64) (width : Z)
`{ArithFact (0 < width /\ width <= 16)} 
: bool :=
   
   orb (eq_vec (plat_htif_tohost tt) addr)
     (andb (eq_vec (add_vec_int (plat_htif_tohost tt) 4) addr) (Z.eqb width 4)).

Axiom plat_insns_per_tick : forall  (_ : unit) , Z.

Definition MSIP_BASE : xlenbits :=
EXTZ 64 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 20).
Hint Unfold MSIP_BASE : sail.
Definition MTIMECMP_BASE : xlenbits :=
EXTZ 64 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 20).
Hint Unfold MTIMECMP_BASE : sail.
Definition MTIMECMP_BASE_HI : xlenbits :=
EXTZ 64 (vec_of_bits [B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 20).
Hint Unfold MTIMECMP_BASE_HI : sail.
Definition MTIME_BASE : xlenbits :=
EXTZ 64 (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B0;B0;B0]  : mword 20).
Hint Unfold MTIME_BASE : sail.
Definition MTIME_BASE_HI : xlenbits :=
EXTZ 64 (vec_of_bits [B0;B0;B0;B0;B1;B0;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B1;B0;B0]  : mword 20).
Hint Unfold MTIME_BASE_HI : sail.
Definition clint_load (addr : mword 64) (width : Z) `{ArithFact (width > 0)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   let addr := sub_vec addr (plat_clint_base tt) in
   (if sumbool_of_bool ((andb (eq_vec addr MSIP_BASE)
                           (orb (Z.eqb (projT1 (__id width)) 8) (Z.eqb (projT1 (__id width)) 4))))
    then
      (if ((get_config_print_platform tt)) then
         read_reg mip_ref >>= fun w__0 : Minterrupts =>
         returnm ((print_endline
                     (String.append "clint["
                        (String.append (string_of_bits addr)
                           (String.append "] -> " (string_of_bits (_get_Minterrupts_MSI w__0))))))
          : unit)
       else returnm (tt  : unit)) >>
      read_reg mip_ref >>= fun w__1 : Minterrupts =>
      returnm ((MemValue
                  (zero_extend (_get_Minterrupts_MSI w__1) (Z.mul 8 (projT1 (__id width)))))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (eq_vec addr MTIMECMP_BASE) (Z.eqb (projT1 (__id width)) 4)))
    then
      (if ((get_config_print_platform tt)) then
         ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
         returnm ((print_endline
                     (String.append "clint<4>["
                        (String.append (string_of_bits addr)
                           (String.append "] -> " (string_of_bits (subrange_vec_dec w__2 31 0))))))
          : unit)
       else returnm (tt  : unit)) >>
      ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__3 : mword 64 =>
      returnm ((MemValue
                  (zero_extend (subrange_vec_dec w__3 31 0) _))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (eq_vec addr MTIMECMP_BASE) (Z.eqb (projT1 (__id width)) 8)))
    then
      (if ((get_config_print_platform tt)) then
         ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__4 : mword 64 =>
         returnm ((print_endline
                     (String.append "clint<8>["
                        (String.append (string_of_bits addr)
                           (String.append "] -> " (string_of_bits w__4)))))
          : unit)
       else returnm (tt  : unit)) >>
      ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__5 : mword 64 =>
      returnm ((MemValue
                  (zero_extend w__5 _))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (eq_vec addr MTIMECMP_BASE_HI) (Z.eqb (projT1 (__id width)) 4)))
    then
      (if ((get_config_print_platform tt)) then
         ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__6 : mword 64 =>
         returnm ((print_endline
                     (String.append "clint-hi<4>["
                        (String.append (string_of_bits addr)
                           (String.append "] -> " (string_of_bits (subrange_vec_dec w__6 63 32))))))
          : unit)
       else returnm (tt  : unit)) >>
      ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__7 : mword 64 =>
      returnm ((MemValue
                  (zero_extend (subrange_vec_dec w__7 63 32) _))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (eq_vec addr MTIME_BASE) (Z.eqb (projT1 (__id width)) 4))) then
      (if ((get_config_print_platform tt)) then
         ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__8 : mword 64 =>
         returnm ((print_endline
                     (String.append "clint["
                        (String.append (string_of_bits addr)
                           (String.append "] -> " (string_of_bits w__8)))))
          : unit)
       else returnm (tt  : unit)) >>
      ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__9 : mword 64 =>
      returnm ((MemValue
                  (zero_extend (subrange_vec_dec w__9 31 0) _))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (eq_vec addr MTIME_BASE) (Z.eqb (projT1 (__id width)) 8))) then
      (if ((get_config_print_platform tt)) then
         ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__10 : mword 64 =>
         returnm ((print_endline
                     (String.append "clint["
                        (String.append (string_of_bits addr)
                           (String.append "] -> " (string_of_bits w__10)))))
          : unit)
       else returnm (tt  : unit)) >>
      ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__11 : mword 64 =>
      returnm ((MemValue
                  (zero_extend w__11 _))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (eq_vec addr MTIME_BASE_HI) (Z.eqb (projT1 (__id width)) 4)))
    then
      (if ((get_config_print_platform tt)) then
         ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__12 : mword 64 =>
         returnm ((print_endline
                     (String.append "clint["
                        (String.append (string_of_bits addr)
                           (String.append "] -> " (string_of_bits w__12)))))
          : unit)
       else returnm (tt  : unit)) >>
      ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__13 : mword 64 =>
      returnm ((MemValue
                  (zero_extend (subrange_vec_dec w__13 63 32) _))
       : MemoryOpResult (mword (8 * width)))
    else
      let '_ :=
        (if ((get_config_print_platform tt)) then
           print_endline
             (String.append "clint[" (String.append (string_of_bits addr) "] -> <not-mapped>"))
         else tt)
         : unit in
      returnm ((MemException
                  (E_Load_Access_Fault))
       : MemoryOpResult (mword (8 * width))))
    : M (MemoryOpResult (mword (8 * width))).

Definition clint_dispatch '(tt : unit) 
: M (unit) :=
   
   (if ((get_config_print_platform tt)) then
      ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
      returnm ((print_endline (String.append "clint::tick mtime <- " (string_of_bits w__0)))
       : unit)
    else returnm (tt  : unit)) >>
   (_set_Minterrupts_MTI mip_ref ((bool_to_bits false)  : mword 1)) >>
   ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   (if ((zopz0zIzJ_u w__1 w__2)) then
      (if ((get_config_print_platform tt)) then
         ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__3 : mword 64 =>
         returnm ((print_endline
                     (String.append " clint timer pending at mtime " (string_of_bits w__3)))
          : unit)
       else returnm (tt  : unit)) >>
      (_set_Minterrupts_MTI mip_ref ((bool_to_bits true)  : mword 1))
       : M (unit)
    else returnm (tt  : unit))
    : M (unit).

Definition clint_store (addr : mword 64) (width : Z) (data : mword (8 * width))
`{ArithFact (width > 0)} 
: M (MemoryOpResult bool) :=
   
   let addr := sub_vec addr (plat_clint_base tt) in
   (if sumbool_of_bool ((andb (eq_vec addr MSIP_BASE)
                           (orb (Z.eqb (projT1 (__id width)) 8) (Z.eqb (projT1 (__id width)) 4))))
    then
      (if ((get_config_print_platform tt)) then
         (cast_unit_vec (access_vec_dec data 0)) >>= fun w__0 : mword 1 =>
         returnm ((print_endline
                     (String.append "clint["
                        (String.append (string_of_bits addr)
                           (String.append "] <- "
                              (String.append (string_of_bits data)
                                 (String.append " (mip.MSI <- "
                                    (String.append (string_of_bits w__0) ")")))))))
          : unit)
       else returnm (tt  : unit)) >>
      (cast_unit_vec (access_vec_dec data 0)) >>= fun w__1 : mword 1 =>
      (_set_Minterrupts_MSI mip_ref
         ((bool_to_bits (eq_vec w__1 (vec_of_bits [B1]  : mword 1)))
          : mword 1)) >>
      (clint_dispatch tt) >> returnm ((MemValue (true))  : MemoryOpResult bool)
    else if sumbool_of_bool ((andb (eq_vec addr MTIMECMP_BASE) (Z.eqb (projT1 (__id width)) 8)))
    then
      let '_ :=
        (if ((get_config_print_platform tt)) then
           print_endline
             (String.append "clint<8>["
                (String.append (string_of_bits addr)
                   (String.append "] <- " (String.append (string_of_bits data) " (mtimecmp)"))))
         else tt)
         : unit in
      write_reg mtimecmp_ref (zero_extend data 64) >>
      (clint_dispatch tt) >> returnm ((MemValue (true))  : MemoryOpResult bool)
    else if sumbool_of_bool ((andb (eq_vec addr MTIMECMP_BASE) (Z.eqb (projT1 (__id width)) 4)))
    then
      let '_ :=
        (if ((get_config_print_platform tt)) then
           print_endline
             (String.append "clint<4>["
                (String.append (string_of_bits addr)
                   (String.append "] <- " (String.append (string_of_bits data) " (mtimecmp)"))))
         else tt)
         : unit in
      ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
      write_reg mtimecmp_ref (update_subrange_vec_dec w__2 31 0 (zero_extend data 32)) >>
      (clint_dispatch tt) >> returnm ((MemValue (true))  : MemoryOpResult bool)
    else if sumbool_of_bool ((andb (eq_vec addr MTIMECMP_BASE_HI) (Z.eqb (projT1 (__id width)) 4)))
    then
      let '_ :=
        (if ((get_config_print_platform tt)) then
           print_endline
             (String.append "clint<4>["
                (String.append (string_of_bits addr)
                   (String.append "] <- " (String.append (string_of_bits data) " (mtimecmp)"))))
         else tt)
         : unit in
      ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__3 : mword 64 =>
      write_reg mtimecmp_ref (update_subrange_vec_dec w__3 63 32 (zero_extend data 32)) >>
      (clint_dispatch tt) >> returnm ((MemValue (true))  : MemoryOpResult bool)
    else
      let '_ :=
        (if ((get_config_print_platform tt)) then
           print_endline
             (String.append "clint["
                (String.append (string_of_bits addr)
                   (String.append "] <- " (String.append (string_of_bits data) " (<unmapped>)"))))
         else tt)
         : unit in
      returnm ((MemException
                  (E_SAMO_Access_Fault))
       : MemoryOpResult bool))
    : M (MemoryOpResult bool).

Definition tick_clock '(tt : unit) 
: M (unit) :=
   
   ((read_reg mcycle_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   write_reg mcycle_ref (add_vec_int w__0 1) >>
   ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   write_reg mtime_ref (add_vec_int w__1 1) >> (clint_dispatch tt)  : M (unit).

Axiom plat_term_write : forall  (_ : mword 8) , unit.

Axiom plat_term_read : forall  (_ : unit) , mword 8.

Definition Mk_htif_cmd (v : mword 64) 
: htif_cmd :=
   
   {| htif_cmd_htif_cmd_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_htif_cmd_bits (v : htif_cmd) 
: mword 64 :=
   
   subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 63 0.

Definition _set_htif_cmd_bits (r_ref : register_ref regstate register_value htif_cmd) (v : mword 64)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       htif_cmd_htif_cmd_chunk_0 :=
         (update_subrange_vec_dec r.(htif_cmd_htif_cmd_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : htif_cmd in
   write_reg r_ref r
    : M (unit).

Definition _update_htif_cmd_bits (v : htif_cmd) (x : mword 64) 
: htif_cmd :=
   
   {[ v with
     htif_cmd_htif_cmd_chunk_0 :=
       (update_subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_htif_cmd_device (v : htif_cmd) 
: mword 8 :=
   
   subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 63 56.

Definition _set_htif_cmd_device
(r_ref : register_ref regstate register_value htif_cmd) (v : mword 8) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       htif_cmd_htif_cmd_chunk_0 :=
         (update_subrange_vec_dec r.(htif_cmd_htif_cmd_chunk_0) 63 56 (subrange_vec_dec v 7 0)) ]}
      : htif_cmd in
   write_reg r_ref r
    : M (unit).

Definition _update_htif_cmd_device (v : htif_cmd) (x : mword 8) 
: htif_cmd :=
   
   {[ v with
     htif_cmd_htif_cmd_chunk_0 :=
       (update_subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 63 56 (subrange_vec_dec x 7 0)) ]}.

Definition _get_htif_cmd_cmd (v : htif_cmd) 
: mword 8 :=
   
   subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 55 48.

Definition _set_htif_cmd_cmd (r_ref : register_ref regstate register_value htif_cmd) (v : mword 8) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       htif_cmd_htif_cmd_chunk_0 :=
         (update_subrange_vec_dec r.(htif_cmd_htif_cmd_chunk_0) 55 48 (subrange_vec_dec v 7 0)) ]}
      : htif_cmd in
   write_reg r_ref r
    : M (unit).

Definition _update_htif_cmd_cmd (v : htif_cmd) (x : mword 8) 
: htif_cmd :=
   
   {[ v with
     htif_cmd_htif_cmd_chunk_0 :=
       (update_subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 55 48 (subrange_vec_dec x 7 0)) ]}.

Definition _get_htif_cmd_payload (v : htif_cmd) 
: mword 48 :=
   
   subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 47 0.

Definition _set_htif_cmd_payload
(r_ref : register_ref regstate register_value htif_cmd) (v : mword 48) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       htif_cmd_htif_cmd_chunk_0 :=
         (update_subrange_vec_dec r.(htif_cmd_htif_cmd_chunk_0) 47 0 (subrange_vec_dec v 47 0)) ]}
      : htif_cmd in
   write_reg r_ref r
    : M (unit).

Definition _update_htif_cmd_payload (v : htif_cmd) (x : mword 48) 
: htif_cmd :=
   
   {[ v with
     htif_cmd_htif_cmd_chunk_0 :=
       (update_subrange_vec_dec v.(htif_cmd_htif_cmd_chunk_0) 47 0 (subrange_vec_dec x 47 0)) ]}.

Definition htif_load (addr : mword 64) (width : Z) `{ArithFact (width > 0)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (if ((get_config_print_platform tt)) then
      ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
      returnm ((print_endline
                  (String.append "htif["
                     (String.append (string_of_bits addr)
                        (String.append "] -> " (string_of_bits w__0)))))
       : unit)
    else returnm (tt  : unit)) >>
   (if sumbool_of_bool ((andb (Z.eqb width 8) (eq_vec addr (plat_htif_tohost tt)))) then
      ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
      returnm ((MemValue
                  (zero_extend w__1 _))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (Z.eqb width 4) (eq_vec addr (plat_htif_tohost tt)))) then
      ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
      returnm ((MemValue
                  (zero_extend (subrange_vec_dec w__2 31 0) _))
       : MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (Z.eqb width 4)
                                (eq_vec addr (add_vec_int (plat_htif_tohost tt) 4)))) then
      ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__3 : mword 64 =>
      returnm ((MemValue
                  (zero_extend (subrange_vec_dec w__3 63 32) _))
       : MemoryOpResult (mword (8 * width)))
    else returnm ((MemException (E_Load_Access_Fault))  : MemoryOpResult (mword (8 * width))))
    : M (MemoryOpResult (mword (8 * width))).

Definition htif_store (addr : mword 64) (width : Z) (data : mword (8 * width))
`{ArithFact (0 < width /\ width <= 8)} 
: M (MemoryOpResult bool) :=
   
   let '_ :=
     (if ((get_config_print_platform tt)) then
        print_endline
          (String.append "htif["
             (String.append (string_of_bits addr) (String.append "] <- " (string_of_bits data))))
      else tt)
      : unit in
   (if sumbool_of_bool ((Z.eqb width 8)) then write_reg htif_tohost_ref (EXTZ 64 data)  : M (unit)
    else if sumbool_of_bool ((andb (Z.eqb width 4) (eq_vec addr (plat_htif_tohost tt)))) then
      ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
      write_reg htif_tohost_ref (update_subrange_vec_dec w__0 31 0 (autocast (autocast data)))
       : M (unit)
    else if sumbool_of_bool ((andb (Z.eqb width 4)
                                (eq_vec addr (add_vec_int (plat_htif_tohost tt) 4)))) then
      ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
      write_reg htif_tohost_ref (update_subrange_vec_dec w__1 63 32 (autocast (autocast data)))
       : M (unit)
    else write_reg htif_tohost_ref (EXTZ 64 data)  : M (unit)) >>
   ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   let cmd := Mk_htif_cmd w__2 in
   let b__0 := _get_htif_cmd_device cmd in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8))) then
      let '_ :=
        (if ((get_config_print_platform tt)) then
           print_endline
             (String.append "htif-syscall-proxy cmd: " (string_of_bits (_get_htif_cmd_payload cmd)))
         else tt)
         : unit in
      (cast_unit_vec (access_vec_dec (_get_htif_cmd_payload cmd) 0)) >>= fun w__3 : mword 1 =>
      (if ((eq_vec w__3 (vec_of_bits [B1]  : mword 1))) then
         write_reg htif_done_ref true >>
         write_reg htif_exit_code_ref (shiftr (zero_extend (_get_htif_cmd_payload cmd) 64) 1)
          : M (unit)
       else returnm (tt  : unit))
       : M (unit)
    else
      returnm ((if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1]  : mword 8))) then
                  let '_ :=
                    (if ((get_config_print_platform tt)) then
                       print_endline
                         (String.append "htif-term cmd: "
                            (string_of_bits (_get_htif_cmd_payload cmd)))
                     else tt)
                     : unit in
                  let b__2 := _get_htif_cmd_cmd cmd in
                  if ((eq_vec b__2 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8))) then tt
                  else if ((eq_vec b__2 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B1]  : mword 8))) then
                    plat_term_write (subrange_vec_dec (_get_htif_cmd_payload cmd) 7 0)
                  else print_endline (String.append "Unknown term cmd: " (string_of_bits b__2))
                else print_endline (String.append "htif-???? cmd: " (string_of_bits data)))
       : unit)) >>
   returnm ((MemValue
               (true))
    : MemoryOpResult bool).

Definition htif_tick '(tt : unit) 
: M (unit) :=
   
   (if ((get_config_print_platform tt)) then
      ((read_reg htif_tohost_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
      returnm ((print_endline (String.append "htif::tick " (string_of_bits w__0)))
       : unit)
    else returnm (tt  : unit)) >>
   write_reg htif_tohost_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))
    : M (unit).

Definition within_mmio_readable (addr : mword 64) (width : Z)
`{ArithFact (0 < width /\ width <= 16)} 
: bool :=
   
   orb (within_clint addr width)
     (andb (within_htif_readable addr width) (Z.leb 1 (projT1 (__id width)))).

Definition within_mmio_writable (addr : mword 64) (width : Z)
`{ArithFact (0 < width /\ width <= 16)} 
: bool :=
   
   orb (within_clint addr width)
     (andb (within_htif_writable addr width) (Z.leb (projT1 (__id width)) 8)).

Definition mmio_read (addr : mword 64) (width : Z) `{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (if ((within_clint addr width)) then
      (clint_load addr width)
       : M (MemoryOpResult (mword (8 * width)))
    else if sumbool_of_bool ((andb (within_htif_readable addr width) (Z.leb 1 (projT1 (__id width)))))
    then
      (htif_load addr width)
       : M (MemoryOpResult (mword (8 * width)))
    else returnm ((MemException (E_Load_Access_Fault))  : MemoryOpResult (mword (8 * width))))
    : M (MemoryOpResult (mword (8 * width))).

Definition mmio_write (addr : mword 64) (width : Z) (data : mword (8 * width))
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult bool) :=
   
   (if ((within_clint addr width)) then (clint_store addr width data)  : M (MemoryOpResult bool)
    else if sumbool_of_bool ((andb (within_htif_writable addr width) (Z.leb (projT1 (__id width)) 8)))
    then
      (htif_store addr width data)
       : M (MemoryOpResult bool)
    else returnm ((MemException (E_SAMO_Access_Fault))  : MemoryOpResult bool))
    : M (MemoryOpResult bool).

Definition init_platform '(tt : unit) 
: M (unit) :=
   
   write_reg htif_tohost_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1)) >>
   write_reg htif_done_ref false >>
   write_reg htif_exit_code_ref (EXTZ 64 (vec_of_bits [B0]  : mword 1))
    : M (unit).

Definition tick_platform '(tt : unit)  : M (unit) :=  (htif_tick tt)  : M (unit).

Definition handle_illegal '(tt : unit) 
: M (unit) :=
   
   (if ((plat_mtval_has_illegal_inst_bits tt)) then
      ((read_reg instbits_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
      returnm ((Some
                  (w__0))
       : option (mword 64))
    else returnm (None  : option (mword 64))) >>= fun info =>
   let t : sync_exception :=
     {| sync_exception_trap := E_Illegal_Instr; 
        sync_exception_excinfo := info; 
        sync_exception_ext := None |} in
   read_reg cur_privilege_ref >>= fun w__1 : Privilege =>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   (exception_handler w__1 (CTL_TRAP (t)) w__2) >>= fun w__3 : mword 64 =>
   (set_next_pc w__3)
    : M (unit).

Definition platform_wfi '(tt : unit) 
: M (unit) :=
   
   let '_ := (cancel_reservation tt)  : unit in
   ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
   (if ((zopz0zI_u w__0 w__1)) then
      ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
      write_reg mtime_ref w__2 >>
      ((read_reg mtimecmp_ref)  : M (mword 64)) >>= fun w__3 : mword 64 =>
      write_reg mcycle_ref w__3
       : M (unit)
    else returnm (tt  : unit))
    : M (unit).

Definition is_aligned_addr (addr : mword 64) (width : Z) 
: bool :=
   
   Z.eqb (projT1 (emod_with_eq (projT1 (uint addr)) width)) 0.

Definition phys_mem_read
(t : AccessType) (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (match (aq, rl, res) with
    | (false, false, false) =>
       (read_ram Read_plain addr width) >>= fun w__0 : mword (8 * width) =>
       returnm ((Some
                   (w__0))
        : option (mword (8 * width)))
    | (true, false, false) =>
       (read_ram Read_RISCV_acquire addr width) >>= fun w__1 : mword (8 * width) =>
       returnm ((Some
                   (w__1))
        : option (mword (8 * width)))
    | (true, true, false) =>
       (read_ram Read_RISCV_strong_acquire addr width) >>= fun w__2 : mword (8 * width) =>
       returnm ((Some
                   (w__2))
        : option (mword (8 * width)))
    | (false, false, true) =>
       (read_ram Read_RISCV_reserved addr width) >>= fun w__3 : mword (8 * width) =>
       returnm ((Some
                   (w__3))
        : option (mword (8 * width)))
    | (true, false, true) =>
       (read_ram Read_RISCV_reserved_acquire addr width) >>= fun w__4 : mword (8 * width) =>
       returnm ((Some
                   (w__4))
        : option (mword (8 * width)))
    | (true, true, true) =>
       (read_ram Read_RISCV_reserved_strong_acquire addr width) >>= fun w__5 : mword (8 * width) =>
       returnm ((Some
                   (w__5))
        : option (mword (8 * width)))
    | (false, true, false) => returnm (None  : option (mword (8 * width)))
    | (false, true, true) => returnm (None  : option (mword (8 * width)))
    end) >>= fun w__6 : option (mword (8 * width)) =>
   let result := w__6  : option (bits (8 * width)) in
   returnm ((match (t, result) with
             | (Execute, None) => MemException (E_Fetch_Access_Fault)
             | (Read, None) => MemException (E_Load_Access_Fault)
             | (_, None) => MemException (E_SAMO_Access_Fault)
             | (_, Some (v)) =>
                let '_ :=
                  (if ((get_config_print_mem tt)) then
                     print_endline
                       (String.append "mem["
                          (String.append (accessType_to_str t)
                             (String.append ","
                                (String.append (string_of_bits addr)
                                   (String.append "] -> " (string_of_bits v))))))
                   else tt)
                   : unit in
                MemValue
                  (v)
             end)
    : MemoryOpResult (mword (8 * width))).

Definition checked_mem_read
(t : AccessType) (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (if ((within_mmio_readable addr width)) then
      (mmio_read addr width)
       : M (MemoryOpResult (mword (8 * width)))
    else if ((within_phys_mem addr width)) then
      (phys_mem_read t addr width aq rl res)
       : M (MemoryOpResult (mword (8 * width)))
    else returnm ((MemException (E_Load_Access_Fault))  : MemoryOpResult (mword (8 * width))))
    : M (MemoryOpResult (mword (8 * width))).

Definition pmp_mem_read
(t : AccessType) (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (if ((negb (plat_enable_pmp tt))) then
      (checked_mem_read t addr width aq rl res)
       : M (MemoryOpResult (mword (8 * width)))
    else
      read_reg mstatus_ref >>= fun w__1 : Mstatus =>
      read_reg cur_privilege_ref >>= fun w__2 : Privilege =>
      (effectivePrivilege w__1 w__2) >>= fun w__3 : Privilege =>
      (pmpCheck addr width t w__3) >>= fun w__4 : option ExceptionType =>
      (match w__4 with
       | None => (checked_mem_read t addr width aq rl res)  : M (MemoryOpResult (mword (8 * width)))
       | Some (e) => returnm ((MemException (e))  : MemoryOpResult (mword (8 * width)))
       end)
       : M (MemoryOpResult (mword (8 * width))))
    : M (MemoryOpResult (mword (8 * width))).

Definition rvfi_read (addr : mword 64) (width : Z) (value : MemoryOpResult (mword (8 * width)))
`{ArithFact (width > 0)} 
: unit :=
   
   tt.

Definition mem_read
(typ : AccessType) (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (res : bool)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult (mword (8 * width))) :=
   
   (if sumbool_of_bool ((andb (orb aq res) (negb (is_aligned_addr addr width)))) then
      returnm ((MemException
                  (E_Load_Addr_Align))
       : MemoryOpResult (mword (8 * width)))
    else
      (match (aq, rl, res) with
       | (false, true, false) => throw (Error_not_implemented ("load.rl"))
       | (false, true, true) => throw (Error_not_implemented ("lr.rl"))
       | (_, _, _) =>
          (pmp_mem_read typ addr width aq rl res)  : M (MemoryOpResult (mword (8 * width)))
       end)
       : M (MemoryOpResult (mword (8 * width)))) >>= fun result : MemoryOpResult (bits (8 * width)) =>
   let '_ := (rvfi_read addr width result)  : unit in
   returnm (result
    : MemoryOpResult (mword (8 * width))).

Definition mem_write_ea (addr : mword 64) (width : Z) (aq : bool) (rl : bool) (con : bool)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult unit) :=
   
   (if sumbool_of_bool ((andb (orb rl con) (negb (is_aligned_addr addr width)))) then
      returnm ((MemException
                  (E_SAMO_Addr_Align))
       : MemoryOpResult unit)
    else
      (match (aq, rl, con) with
       | (false, false, false) =>
          (write_ram_ea Write_plain addr width) >> returnm ((MemValue (tt))  : MemoryOpResult unit)
       | (false, true, false) =>
          (write_ram_ea Write_RISCV_release addr width) >>
          returnm ((MemValue
                      (tt))
           : MemoryOpResult unit)
       | (false, false, true) =>
          (write_ram_ea Write_RISCV_conditional addr width) >>
          returnm ((MemValue
                      (tt))
           : MemoryOpResult unit)
       | (false, true, true) =>
          (write_ram_ea Write_RISCV_conditional_release addr width) >>
          returnm ((MemValue
                      (tt))
           : MemoryOpResult unit)
       | (true, false, false) => throw (Error_not_implemented ("store.aq"))
       | (true, true, false) =>
          (write_ram_ea Write_RISCV_strong_release addr width) >>
          returnm ((MemValue
                      (tt))
           : MemoryOpResult unit)
       | (true, false, true) => throw (Error_not_implemented ("sc.aq"))
       | (true, true, true) =>
          (write_ram_ea Write_RISCV_conditional_strong_release addr width) >>
          returnm ((MemValue
                      (tt))
           : MemoryOpResult unit)
       end)
       : M (MemoryOpResult unit))
    : M (MemoryOpResult unit).

Definition rvfi_write (addr : mword 64) (width : Z) (value : mword (8 * width))
`{ArithFact (width > 0)} 
: unit :=
   
   tt.

Definition phys_mem_write
(wk : write_kind) (addr : mword 64) (width : Z) (data : mword (8 * width)) (meta : unit)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult bool) :=
   
   let '_ := (rvfi_write addr width data)  : unit in
   (write_ram wk addr width data meta) >>= fun w__0 : bool =>
   let result := MemValue (w__0) in
   let '_ :=
     (if ((get_config_print_mem tt)) then
        print_endline
          (String.append "mem["
             (String.append (string_of_bits addr) (String.append "] <- " (string_of_bits data))))
      else tt)
      : unit in
   returnm (result
    : MemoryOpResult bool).

Definition checked_mem_write
(wk : write_kind) (addr : mword 64) (width : Z) (data : mword (8 * width)) (meta : unit)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult bool) :=
   
   (if ((within_mmio_writable addr width)) then
      (mmio_write addr width data)
       : M (MemoryOpResult bool)
    else if ((within_phys_mem addr width)) then
      (phys_mem_write wk addr width data meta)
       : M (MemoryOpResult bool)
    else returnm ((MemException (E_SAMO_Access_Fault))  : MemoryOpResult bool))
    : M (MemoryOpResult bool).

Definition pmp_mem_write
(wk : write_kind) (addr : mword 64) (width : Z) (data : mword (8 * width)) (meta : unit)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult bool) :=
   
   (if ((negb (plat_enable_pmp tt))) then
      (checked_mem_write wk addr width data meta)
       : M (MemoryOpResult bool)
    else
      read_reg mstatus_ref >>= fun w__1 : Mstatus =>
      read_reg cur_privilege_ref >>= fun w__2 : Privilege =>
      (effectivePrivilege w__1 w__2) >>= fun w__3 : Privilege =>
      (pmpCheck addr width Write w__3) >>= fun w__4 : option ExceptionType =>
      (match w__4 with
       | None => (checked_mem_write wk addr width data meta)  : M (MemoryOpResult bool)
       | Some (e) => returnm ((MemException (e))  : MemoryOpResult bool)
       end)
       : M (MemoryOpResult bool))
    : M (MemoryOpResult bool).

Definition mem_write_value_meta
(addr : mword 64) (width : Z) (value : mword (8 * width)) (meta : unit) (aq : bool) (rl : bool)
(con : bool) `{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult bool) :=
   
   let '_ := (rvfi_write addr width value)  : unit in
   (if sumbool_of_bool ((andb (orb rl con) (negb (is_aligned_addr addr width)))) then
      returnm ((MemException
                  (E_SAMO_Addr_Align))
       : MemoryOpResult bool)
    else
      (match (aq, rl, con) with
       | (false, false, false) =>
          (pmp_mem_write Write_plain addr width value meta)  : M (MemoryOpResult bool)
       | (false, true, false) =>
          (pmp_mem_write Write_RISCV_release addr width value meta)  : M (MemoryOpResult bool)
       | (false, false, true) =>
          (pmp_mem_write Write_RISCV_conditional addr width value meta)  : M (MemoryOpResult bool)
       | (false, true, true) =>
          (pmp_mem_write Write_RISCV_conditional_release addr width value meta)
           : M (MemoryOpResult bool)
       | (true, true, false) =>
          (pmp_mem_write Write_RISCV_strong_release addr width value meta)
           : M (MemoryOpResult bool)
       | (true, true, true) =>
          (pmp_mem_write Write_RISCV_conditional_strong_release addr width value meta)
           : M (MemoryOpResult bool)
       | (true, false, false) => throw (Error_not_implemented ("store.aq"))
       | (true, false, true) => throw (Error_not_implemented ("sc.aq"))
       end)
       : M (MemoryOpResult bool))
    : M (MemoryOpResult bool).

Definition mem_write_value
(addr : mword 64) (width : Z) (value : mword (8 * width)) (aq : bool) (rl : bool) (con : bool)
`{ArithFact (0 < width /\ width <= 16)} 
: M (MemoryOpResult bool) :=
   
   (mem_write_value_meta addr width value default_meta aq rl con)
    : M (MemoryOpResult bool).

Definition PAGESIZE_BITS := 12.
Hint Unfold PAGESIZE_BITS : sail.
Definition Mk_PTE_Bits (v : mword 8) 
: PTE_Bits :=
   
   {| PTE_Bits_PTE_Bits_chunk_0 := (subrange_vec_dec v 7 0) |}.

Definition _get_PTE_Bits_bits (v : PTE_Bits) 
: mword 8 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 7 0.

Definition _set_PTE_Bits_bits (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 8) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 7 0 (subrange_vec_dec v 7 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_bits (v : PTE_Bits) (x : mword 8) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 7 0 (subrange_vec_dec x 7 0)) ]}.

Definition _get_PTE_Bits_D (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 7 7.

Definition _set_PTE_Bits_D (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 7 7 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_D (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 7 7 (subrange_vec_dec x 0 0)) ]}.

Definition _get_PTE_Bits_A (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 6 6.

Definition _set_PTE_Bits_A (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 6 6 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_A (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 6 6 (subrange_vec_dec x 0 0)) ]}.

Definition _get_PTE_Bits_G (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 5 5.

Definition _set_PTE_Bits_G (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 5 5 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_G (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 5 5 (subrange_vec_dec x 0 0)) ]}.

Definition _get_PTE_Bits_U (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 4 4.

Definition _set_PTE_Bits_U (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 4 4 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_U (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 4 4 (subrange_vec_dec x 0 0)) ]}.

Definition _get_PTE_Bits_X (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 3 3.

Definition _set_PTE_Bits_X (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 3 3 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_X (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 3 3 (subrange_vec_dec x 0 0)) ]}.

Definition _get_PTE_Bits_W (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 2 2.

Definition _set_PTE_Bits_W (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 2 2 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_W (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 2 2 (subrange_vec_dec x 0 0)) ]}.

Definition _get_PTE_Bits_R (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 1 1.

Definition _set_PTE_Bits_R (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 1 1 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_R (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 1 1 (subrange_vec_dec x 0 0)) ]}.

Definition _get_PTE_Bits_V (v : PTE_Bits) 
: mword 1 :=
   
   subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 0 0.

Definition _set_PTE_Bits_V (r_ref : register_ref regstate register_value PTE_Bits) (v : mword 1) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       PTE_Bits_PTE_Bits_chunk_0 :=
         (update_subrange_vec_dec r.(PTE_Bits_PTE_Bits_chunk_0) 0 0 (subrange_vec_dec v 0 0)) ]}
      : PTE_Bits in
   write_reg r_ref r
    : M (unit).

Definition _update_PTE_Bits_V (v : PTE_Bits) (x : mword 1) 
: PTE_Bits :=
   
   {[ v with
     PTE_Bits_PTE_Bits_chunk_0 :=
       (update_subrange_vec_dec v.(PTE_Bits_PTE_Bits_chunk_0) 0 0 (subrange_vec_dec x 0 0)) ]}.

Definition isPTEPtr (p : mword 8) 
: bool :=
   
   let a := Mk_PTE_Bits p in
   andb (eq_vec (_get_PTE_Bits_R a) ((bool_to_bits false)  : mword 1))
     (andb (eq_vec (_get_PTE_Bits_W a) ((bool_to_bits false)  : mword 1))
        (eq_vec (_get_PTE_Bits_X a) ((bool_to_bits false)  : mword 1))).

Definition isInvalidPTE (p : mword 8) 
: bool :=
   
   let a := Mk_PTE_Bits p in
   orb (eq_vec (_get_PTE_Bits_V a) ((bool_to_bits false)  : mword 1))
     (andb (eq_vec (_get_PTE_Bits_W a) ((bool_to_bits true)  : mword 1))
        (eq_vec (_get_PTE_Bits_R a) ((bool_to_bits false)  : mword 1))).

Definition checkPTEPermission
(ac : AccessType) (priv : Privilege) (mxr : bool) (do_sum : bool) (p : PTE_Bits) 
: M (bool) :=
   
   (match (ac, priv) with
    | (Read, User) =>
       returnm (andb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits true)  : mword 1))
                  (orb (eq_vec (_get_PTE_Bits_R p) ((bool_to_bits true)  : mword 1))
                     (andb (eq_vec (_get_PTE_Bits_X p) ((bool_to_bits true)  : mword 1)) mxr)))
    | (Write, User) =>
       returnm ((andb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits true)  : mword 1))
                   (eq_vec (_get_PTE_Bits_W p) ((bool_to_bits true)  : mword 1)))
        : bool)
    | (ReadWrite, User) =>
       returnm (andb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits true)  : mword 1))
                  (andb (eq_vec (_get_PTE_Bits_W p) ((bool_to_bits true)  : mword 1))
                     (orb (eq_vec (_get_PTE_Bits_R p) ((bool_to_bits true)  : mword 1))
                        (andb (eq_vec (_get_PTE_Bits_X p) ((bool_to_bits true)  : mword 1)) mxr))))
    | (Execute, User) =>
       returnm ((andb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits true)  : mword 1))
                   (eq_vec (_get_PTE_Bits_X p) ((bool_to_bits true)  : mword 1)))
        : bool)
    | (Read, Supervisor) =>
       returnm (andb (orb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits false)  : mword 1)) do_sum)
                  (orb (eq_vec (_get_PTE_Bits_R p) ((bool_to_bits true)  : mword 1))
                     (andb (eq_vec (_get_PTE_Bits_X p) ((bool_to_bits true)  : mword 1)) mxr)))
    | (Write, Supervisor) =>
       returnm (andb (orb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits false)  : mword 1)) do_sum)
                  (eq_vec (_get_PTE_Bits_W p) ((bool_to_bits true)  : mword 1)))
    | (ReadWrite, Supervisor) =>
       returnm (andb (orb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits false)  : mword 1)) do_sum)
                  (andb (eq_vec (_get_PTE_Bits_W p) ((bool_to_bits true)  : mword 1))
                     (orb (eq_vec (_get_PTE_Bits_R p) ((bool_to_bits true)  : mword 1))
                        (andb (eq_vec (_get_PTE_Bits_X p) ((bool_to_bits true)  : mword 1)) mxr))))
    | (Execute, Supervisor) =>
       returnm ((andb (eq_vec (_get_PTE_Bits_U p) ((bool_to_bits false)  : mword 1))
                   (eq_vec (_get_PTE_Bits_X p) ((bool_to_bits true)  : mword 1)))
        : bool)
    | (_, Machine) => (internal_error "m-mode mem perm check")  : M (bool)
    end)
    : M (bool).

Definition update_PTE_Bits (p : PTE_Bits) (a : AccessType) 
: option PTE_Bits :=
   
   let update_d :=
     andb (orb (generic_eq a Write) (generic_eq a ReadWrite))
       (eq_vec (_get_PTE_Bits_D p) ((bool_to_bits false)  : mword 1)) in
   let update_a := eq_vec (_get_PTE_Bits_A p) ((bool_to_bits false)  : mword 1) in
   if sumbool_of_bool ((orb update_d update_a)) then
     let np := _update_PTE_Bits_A p ((bool_to_bits true)  : mword 1) in
     let np :=
       if sumbool_of_bool (update_d) then _update_PTE_Bits_D np ((bool_to_bits true)  : mword 1)
       else np in
     Some
       (np)
   else None.

Definition PTW_Error_of_num (arg_ : Z) `{ArithFact (0 <= arg_ /\ arg_ <= 4)} 
: PTW_Error :=
   
   let l__8 := arg_ in
   if sumbool_of_bool ((Z.eqb l__8 0)) then PTW_Access
   else if sumbool_of_bool ((Z.eqb l__8 1)) then PTW_Invalid_PTE
   else if sumbool_of_bool ((Z.eqb l__8 2)) then PTW_No_Permission
   else if sumbool_of_bool ((Z.eqb l__8 3)) then PTW_Misaligned
   else PTW_PTE_Update.

Definition num_of_PTW_Error (arg_ : PTW_Error) 
: {e : Z & ArithFact (0 <= e /\ e <= 4)} :=
   
   build_ex(match arg_ with
            | PTW_Access => 0
            | PTW_Invalid_PTE => 1
            | PTW_No_Permission => 2
            | PTW_Misaligned => 3
            | PTW_PTE_Update => 4
            end).

Definition ptw_error_to_str (e : PTW_Error) 
: string :=
   
   match e with
   | PTW_Access => "mem-access-error"
   | PTW_Invalid_PTE => "invalid-pte"
   | PTW_No_Permission => "no-permission"
   | PTW_Misaligned => "misaligned-superpage"
   | PTW_PTE_Update => "pte-update-needed"
   end.

Definition translationException (a : AccessType) (f : PTW_Error) 
: ExceptionType :=
   
   match (a, f) with
   | (ReadWrite, PTW_Access) => E_SAMO_Access_Fault
   | (ReadWrite, _) => E_SAMO_Page_Fault
   | (Read, PTW_Access) => E_Load_Access_Fault
   | (Read, _) => E_Load_Page_Fault
   | (Write, PTW_Access) => E_SAMO_Access_Fault
   | (Write, _) => E_SAMO_Page_Fault
   | (Fetch, PTW_Access) => E_Fetch_Access_Fault
   | (Fetch, _) => E_Fetch_Page_Fault
   end.

Definition curAsid32 (satp : mword 32) 
: mword 9 :=
   
   let s := Mk_Satp32 satp in
   _get_Satp32_Asid s.

Definition curPTB32 (satp : mword 32) 
: mword 34 :=
   
   let s : Satp32 := Mk_Satp32 satp in
   shiftl (EXTZ 34 (_get_Satp32_PPN s)) PAGESIZE_BITS.

Definition SV32_LEVEL_BITS := 10.
Hint Unfold SV32_LEVEL_BITS : sail.
Definition SV32_LEVELS := 2.
Hint Unfold SV32_LEVELS : sail.
Definition PTE32_LOG_SIZE := 2.
Hint Unfold PTE32_LOG_SIZE : sail.
Definition PTE32_SIZE := 4.
Hint Unfold PTE32_SIZE : sail.
Definition Mk_SV32_Vaddr (v : mword 32) 
: SV32_Vaddr :=
   
   {| SV32_Vaddr_SV32_Vaddr_chunk_0 := (subrange_vec_dec v 31 0) |}.

Definition _get_SV32_Vaddr_bits (v : SV32_Vaddr) 
: mword 32 :=
   
   subrange_vec_dec v.(SV32_Vaddr_SV32_Vaddr_chunk_0) 31 0.

Definition _set_SV32_Vaddr_bits
(r_ref : register_ref regstate register_value SV32_Vaddr) (v : mword 32) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_Vaddr_SV32_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_Vaddr_SV32_Vaddr_chunk_0) 31 0 (subrange_vec_dec v 31 0)) ]}
      : SV32_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_Vaddr_bits (v : SV32_Vaddr) (x : mword 32) 
: SV32_Vaddr :=
   
   {[ v with
     SV32_Vaddr_SV32_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_Vaddr_SV32_Vaddr_chunk_0) 31 0 (subrange_vec_dec x 31 0)) ]}.

Definition _get_SV32_Vaddr_VPNi (v : SV32_Vaddr) 
: mword 20 :=
   
   subrange_vec_dec v.(SV32_Vaddr_SV32_Vaddr_chunk_0) 31 12.

Definition _set_SV32_Vaddr_VPNi
(r_ref : register_ref regstate register_value SV32_Vaddr) (v : mword 20) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_Vaddr_SV32_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_Vaddr_SV32_Vaddr_chunk_0) 31 12 (subrange_vec_dec v 19 0)) ]}
      : SV32_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_Vaddr_VPNi (v : SV32_Vaddr) (x : mword 20) 
: SV32_Vaddr :=
   
   {[ v with
     SV32_Vaddr_SV32_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_Vaddr_SV32_Vaddr_chunk_0) 31 12 (subrange_vec_dec x 19 0)) ]}.

Definition _get_SV32_Vaddr_PgOfs (v : SV32_Vaddr) 
: mword 12 :=
   
   subrange_vec_dec v.(SV32_Vaddr_SV32_Vaddr_chunk_0) 11 0.

Definition _set_SV32_Vaddr_PgOfs
(r_ref : register_ref regstate register_value SV32_Vaddr) (v : mword 12) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_Vaddr_SV32_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_Vaddr_SV32_Vaddr_chunk_0) 11 0 (subrange_vec_dec v 11 0)) ]}
      : SV32_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_Vaddr_PgOfs (v : SV32_Vaddr) (x : mword 12) 
: SV32_Vaddr :=
   
   {[ v with
     SV32_Vaddr_SV32_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_Vaddr_SV32_Vaddr_chunk_0) 11 0 (subrange_vec_dec x 11 0)) ]}.

Definition Mk_SV32_Paddr (v : mword 34) 
: SV32_Paddr :=
   
   {| SV32_Paddr_SV32_Paddr_chunk_0 := (subrange_vec_dec v 33 0) |}.

Definition _get_SV32_Paddr_bits (v : SV32_Paddr) 
: mword 34 :=
   
   subrange_vec_dec v.(SV32_Paddr_SV32_Paddr_chunk_0) 33 0.

Definition _set_SV32_Paddr_bits
(r_ref : register_ref regstate register_value SV32_Paddr) (v : mword 34) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_Paddr_SV32_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_Paddr_SV32_Paddr_chunk_0) 33 0 (subrange_vec_dec v 33 0)) ]}
      : SV32_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_Paddr_bits (v : SV32_Paddr) (x : mword 34) 
: SV32_Paddr :=
   
   {[ v with
     SV32_Paddr_SV32_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_Paddr_SV32_Paddr_chunk_0) 33 0 (subrange_vec_dec x 33 0)) ]}.

Definition _get_SV32_Paddr_PPNi (v : SV32_Paddr) 
: mword 22 :=
   
   subrange_vec_dec v.(SV32_Paddr_SV32_Paddr_chunk_0) 33 12.

Definition _set_SV32_Paddr_PPNi
(r_ref : register_ref regstate register_value SV32_Paddr) (v : mword 22) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_Paddr_SV32_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_Paddr_SV32_Paddr_chunk_0) 33 12 (subrange_vec_dec v 21 0)) ]}
      : SV32_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_Paddr_PPNi (v : SV32_Paddr) (x : mword 22) 
: SV32_Paddr :=
   
   {[ v with
     SV32_Paddr_SV32_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_Paddr_SV32_Paddr_chunk_0) 33 12 (subrange_vec_dec x 21 0)) ]}.

Definition _get_SV32_Paddr_PgOfs (v : SV32_Paddr) 
: mword 12 :=
   
   subrange_vec_dec v.(SV32_Paddr_SV32_Paddr_chunk_0) 11 0.

Definition _set_SV32_Paddr_PgOfs
(r_ref : register_ref regstate register_value SV32_Paddr) (v : mword 12) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_Paddr_SV32_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_Paddr_SV32_Paddr_chunk_0) 11 0 (subrange_vec_dec v 11 0)) ]}
      : SV32_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_Paddr_PgOfs (v : SV32_Paddr) (x : mword 12) 
: SV32_Paddr :=
   
   {[ v with
     SV32_Paddr_SV32_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_Paddr_SV32_Paddr_chunk_0) 11 0 (subrange_vec_dec x 11 0)) ]}.

Definition Mk_SV32_PTE (v : mword 32) 
: SV32_PTE :=
   
   {| SV32_PTE_SV32_PTE_chunk_0 := (subrange_vec_dec v 31 0) |}.

Definition _get_SV32_PTE_bits (v : SV32_PTE) 
: mword 32 :=
   
   subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 31 0.

Definition _set_SV32_PTE_bits (r_ref : register_ref regstate register_value SV32_PTE) (v : mword 32)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_PTE_SV32_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_PTE_SV32_PTE_chunk_0) 31 0 (subrange_vec_dec v 31 0)) ]}
      : SV32_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_PTE_bits (v : SV32_PTE) (x : mword 32) 
: SV32_PTE :=
   
   {[ v with
     SV32_PTE_SV32_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 31 0 (subrange_vec_dec x 31 0)) ]}.

Definition _get_SV32_PTE_PPNi (v : SV32_PTE) 
: mword 22 :=
   
   subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 31 10.

Definition _set_SV32_PTE_PPNi (r_ref : register_ref regstate register_value SV32_PTE) (v : mword 22)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_PTE_SV32_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_PTE_SV32_PTE_chunk_0) 31 10 (subrange_vec_dec v 21 0)) ]}
      : SV32_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_PTE_PPNi (v : SV32_PTE) (x : mword 22) 
: SV32_PTE :=
   
   {[ v with
     SV32_PTE_SV32_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 31 10 (subrange_vec_dec x 21 0)) ]}.

Definition _get_SV32_PTE_RSW (v : SV32_PTE) 
: mword 2 :=
   
   subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 9 8.

Definition _set_SV32_PTE_RSW (r_ref : register_ref regstate register_value SV32_PTE) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_PTE_SV32_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_PTE_SV32_PTE_chunk_0) 9 8 (subrange_vec_dec v 1 0)) ]}
      : SV32_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_PTE_RSW (v : SV32_PTE) (x : mword 2) 
: SV32_PTE :=
   
   {[ v with
     SV32_PTE_SV32_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 9 8 (subrange_vec_dec x 1 0)) ]}.

Definition _get_SV32_PTE_BITS (v : SV32_PTE) 
: mword 8 :=
   
   subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 7 0.

Definition _set_SV32_PTE_BITS (r_ref : register_ref regstate register_value SV32_PTE) (v : mword 8) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV32_PTE_SV32_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV32_PTE_SV32_PTE_chunk_0) 7 0 (subrange_vec_dec v 7 0)) ]}
      : SV32_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV32_PTE_BITS (v : SV32_PTE) (x : mword 8) 
: SV32_PTE :=
   
   {[ v with
     SV32_PTE_SV32_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV32_PTE_SV32_PTE_chunk_0) 7 0 (subrange_vec_dec x 7 0)) ]}.

Definition curAsid64 (satp : mword 64) 
: mword 16 :=
   
   let s := Mk_Satp64 satp in
   _get_Satp64_Asid s.

Definition curPTB64 (satp : mword 64) 
: mword 56 :=
   
   let s := Mk_Satp64 satp in
   shiftl (EXTZ 56 (_get_Satp64_PPN s)) PAGESIZE_BITS.

Definition SV39_LEVEL_BITS := 9.
Hint Unfold SV39_LEVEL_BITS : sail.
Definition SV39_LEVELS := 3.
Hint Unfold SV39_LEVELS : sail.
Definition PTE39_LOG_SIZE := 3.
Hint Unfold PTE39_LOG_SIZE : sail.
Definition PTE39_SIZE := 8.
Hint Unfold PTE39_SIZE : sail.
Definition Mk_SV39_Vaddr (v : mword 39) 
: SV39_Vaddr :=
   
   {| SV39_Vaddr_SV39_Vaddr_chunk_0 := (subrange_vec_dec v 38 0) |}.

Definition _get_SV39_Vaddr_bits (v : SV39_Vaddr) 
: mword 39 :=
   
   subrange_vec_dec v.(SV39_Vaddr_SV39_Vaddr_chunk_0) 38 0.

Definition _set_SV39_Vaddr_bits
(r_ref : register_ref regstate register_value SV39_Vaddr) (v : mword 39) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_Vaddr_SV39_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_Vaddr_SV39_Vaddr_chunk_0) 38 0 (subrange_vec_dec v 38 0)) ]}
      : SV39_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_Vaddr_bits (v : SV39_Vaddr) (x : mword 39) 
: SV39_Vaddr :=
   
   {[ v with
     SV39_Vaddr_SV39_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_Vaddr_SV39_Vaddr_chunk_0) 38 0 (subrange_vec_dec x 38 0)) ]}.

Definition _get_SV39_Vaddr_VPNi (v : SV39_Vaddr) 
: mword 27 :=
   
   subrange_vec_dec v.(SV39_Vaddr_SV39_Vaddr_chunk_0) 38 12.

Definition _set_SV39_Vaddr_VPNi
(r_ref : register_ref regstate register_value SV39_Vaddr) (v : mword 27) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_Vaddr_SV39_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_Vaddr_SV39_Vaddr_chunk_0) 38 12 (subrange_vec_dec v 26 0)) ]}
      : SV39_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_Vaddr_VPNi (v : SV39_Vaddr) (x : mword 27) 
: SV39_Vaddr :=
   
   {[ v with
     SV39_Vaddr_SV39_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_Vaddr_SV39_Vaddr_chunk_0) 38 12 (subrange_vec_dec x 26 0)) ]}.

Definition _get_SV39_Vaddr_PgOfs (v : SV39_Vaddr) 
: mword 12 :=
   
   subrange_vec_dec v.(SV39_Vaddr_SV39_Vaddr_chunk_0) 11 0.

Definition _set_SV39_Vaddr_PgOfs
(r_ref : register_ref regstate register_value SV39_Vaddr) (v : mword 12) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_Vaddr_SV39_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_Vaddr_SV39_Vaddr_chunk_0) 11 0 (subrange_vec_dec v 11 0)) ]}
      : SV39_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_Vaddr_PgOfs (v : SV39_Vaddr) (x : mword 12) 
: SV39_Vaddr :=
   
   {[ v with
     SV39_Vaddr_SV39_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_Vaddr_SV39_Vaddr_chunk_0) 11 0 (subrange_vec_dec x 11 0)) ]}.

Definition Mk_SV39_Paddr (v : mword 56) 
: SV39_Paddr :=
   
   {| SV39_Paddr_SV39_Paddr_chunk_0 := (subrange_vec_dec v 55 0) |}.

Definition _get_SV39_Paddr_bits (v : SV39_Paddr) 
: mword 56 :=
   
   subrange_vec_dec v.(SV39_Paddr_SV39_Paddr_chunk_0) 55 0.

Definition _set_SV39_Paddr_bits
(r_ref : register_ref regstate register_value SV39_Paddr) (v : mword 56) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_Paddr_SV39_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_Paddr_SV39_Paddr_chunk_0) 55 0 (subrange_vec_dec v 55 0)) ]}
      : SV39_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_Paddr_bits (v : SV39_Paddr) (x : mword 56) 
: SV39_Paddr :=
   
   {[ v with
     SV39_Paddr_SV39_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_Paddr_SV39_Paddr_chunk_0) 55 0 (subrange_vec_dec x 55 0)) ]}.

Definition _get_SV39_Paddr_PPNi (v : SV39_Paddr) 
: mword 44 :=
   
   subrange_vec_dec v.(SV39_Paddr_SV39_Paddr_chunk_0) 55 12.

Definition _set_SV39_Paddr_PPNi
(r_ref : register_ref regstate register_value SV39_Paddr) (v : mword 44) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_Paddr_SV39_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_Paddr_SV39_Paddr_chunk_0) 55 12 (subrange_vec_dec v 43 0)) ]}
      : SV39_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_Paddr_PPNi (v : SV39_Paddr) (x : mword 44) 
: SV39_Paddr :=
   
   {[ v with
     SV39_Paddr_SV39_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_Paddr_SV39_Paddr_chunk_0) 55 12 (subrange_vec_dec x 43 0)) ]}.

Definition _get_SV39_Paddr_PgOfs (v : SV39_Paddr) 
: mword 12 :=
   
   subrange_vec_dec v.(SV39_Paddr_SV39_Paddr_chunk_0) 11 0.

Definition _set_SV39_Paddr_PgOfs
(r_ref : register_ref regstate register_value SV39_Paddr) (v : mword 12) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_Paddr_SV39_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_Paddr_SV39_Paddr_chunk_0) 11 0 (subrange_vec_dec v 11 0)) ]}
      : SV39_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_Paddr_PgOfs (v : SV39_Paddr) (x : mword 12) 
: SV39_Paddr :=
   
   {[ v with
     SV39_Paddr_SV39_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_Paddr_SV39_Paddr_chunk_0) 11 0 (subrange_vec_dec x 11 0)) ]}.

Definition Mk_SV39_PTE (v : mword 64) 
: SV39_PTE :=
   
   {| SV39_PTE_SV39_PTE_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_SV39_PTE_bits (v : SV39_PTE) 
: mword 64 :=
   
   subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 63 0.

Definition _set_SV39_PTE_bits (r_ref : register_ref regstate register_value SV39_PTE) (v : mword 64)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_PTE_SV39_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_PTE_SV39_PTE_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : SV39_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_PTE_bits (v : SV39_PTE) (x : mword 64) 
: SV39_PTE :=
   
   {[ v with
     SV39_PTE_SV39_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_SV39_PTE_PPNi (v : SV39_PTE) 
: mword 44 :=
   
   subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 53 10.

Definition _set_SV39_PTE_PPNi (r_ref : register_ref regstate register_value SV39_PTE) (v : mword 44)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_PTE_SV39_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_PTE_SV39_PTE_chunk_0) 53 10 (subrange_vec_dec v 43 0)) ]}
      : SV39_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_PTE_PPNi (v : SV39_PTE) (x : mword 44) 
: SV39_PTE :=
   
   {[ v with
     SV39_PTE_SV39_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 53 10 (subrange_vec_dec x 43 0)) ]}.

Definition _get_SV39_PTE_RSW (v : SV39_PTE) 
: mword 2 :=
   
   subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 9 8.

Definition _set_SV39_PTE_RSW (r_ref : register_ref regstate register_value SV39_PTE) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_PTE_SV39_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_PTE_SV39_PTE_chunk_0) 9 8 (subrange_vec_dec v 1 0)) ]}
      : SV39_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_PTE_RSW (v : SV39_PTE) (x : mword 2) 
: SV39_PTE :=
   
   {[ v with
     SV39_PTE_SV39_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 9 8 (subrange_vec_dec x 1 0)) ]}.

Definition _get_SV39_PTE_BITS (v : SV39_PTE) 
: mword 8 :=
   
   subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 7 0.

Definition _set_SV39_PTE_BITS (r_ref : register_ref regstate register_value SV39_PTE) (v : mword 8) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV39_PTE_SV39_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV39_PTE_SV39_PTE_chunk_0) 7 0 (subrange_vec_dec v 7 0)) ]}
      : SV39_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV39_PTE_BITS (v : SV39_PTE) (x : mword 8) 
: SV39_PTE :=
   
   {[ v with
     SV39_PTE_SV39_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV39_PTE_SV39_PTE_chunk_0) 7 0 (subrange_vec_dec x 7 0)) ]}.

Definition SV48_LEVEL_BITS := 9.
Hint Unfold SV48_LEVEL_BITS : sail.
Definition SV48_LEVELS := 4.
Hint Unfold SV48_LEVELS : sail.
Definition PTE48_LOG_SIZE := 3.
Hint Unfold PTE48_LOG_SIZE : sail.
Definition PTE48_SIZE := 8.
Hint Unfold PTE48_SIZE : sail.
Definition Mk_SV48_Vaddr (v : mword 48) 
: SV48_Vaddr :=
   
   {| SV48_Vaddr_SV48_Vaddr_chunk_0 := (subrange_vec_dec v 47 0) |}.

Definition _get_SV48_Vaddr_bits (v : SV48_Vaddr) 
: mword 48 :=
   
   subrange_vec_dec v.(SV48_Vaddr_SV48_Vaddr_chunk_0) 47 0.

Definition _set_SV48_Vaddr_bits
(r_ref : register_ref regstate register_value SV48_Vaddr) (v : mword 48) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_Vaddr_SV48_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_Vaddr_SV48_Vaddr_chunk_0) 47 0 (subrange_vec_dec v 47 0)) ]}
      : SV48_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_Vaddr_bits (v : SV48_Vaddr) (x : mword 48) 
: SV48_Vaddr :=
   
   {[ v with
     SV48_Vaddr_SV48_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_Vaddr_SV48_Vaddr_chunk_0) 47 0 (subrange_vec_dec x 47 0)) ]}.

Definition _get_SV48_Vaddr_VPNi (v : SV48_Vaddr) 
: mword 27 :=
   
   subrange_vec_dec v.(SV48_Vaddr_SV48_Vaddr_chunk_0) 38 12.

Definition _set_SV48_Vaddr_VPNi
(r_ref : register_ref regstate register_value SV48_Vaddr) (v : mword 27) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_Vaddr_SV48_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_Vaddr_SV48_Vaddr_chunk_0) 38 12 (subrange_vec_dec v 26 0)) ]}
      : SV48_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_Vaddr_VPNi (v : SV48_Vaddr) (x : mword 27) 
: SV48_Vaddr :=
   
   {[ v with
     SV48_Vaddr_SV48_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_Vaddr_SV48_Vaddr_chunk_0) 38 12 (subrange_vec_dec x 26 0)) ]}.

Definition _get_SV48_Vaddr_PgOfs (v : SV48_Vaddr) 
: mword 12 :=
   
   subrange_vec_dec v.(SV48_Vaddr_SV48_Vaddr_chunk_0) 11 0.

Definition _set_SV48_Vaddr_PgOfs
(r_ref : register_ref regstate register_value SV48_Vaddr) (v : mword 12) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_Vaddr_SV48_Vaddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_Vaddr_SV48_Vaddr_chunk_0) 11 0 (subrange_vec_dec v 11 0)) ]}
      : SV48_Vaddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_Vaddr_PgOfs (v : SV48_Vaddr) (x : mword 12) 
: SV48_Vaddr :=
   
   {[ v with
     SV48_Vaddr_SV48_Vaddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_Vaddr_SV48_Vaddr_chunk_0) 11 0 (subrange_vec_dec x 11 0)) ]}.

Definition Mk_SV48_Paddr (v : mword 56) 
: SV48_Paddr :=
   
   {| SV48_Paddr_SV48_Paddr_chunk_0 := (subrange_vec_dec v 55 0) |}.

Definition _get_SV48_Paddr_bits (v : SV48_Paddr) 
: mword 56 :=
   
   subrange_vec_dec v.(SV48_Paddr_SV48_Paddr_chunk_0) 55 0.

Definition _set_SV48_Paddr_bits
(r_ref : register_ref regstate register_value SV48_Paddr) (v : mword 56) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_Paddr_SV48_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_Paddr_SV48_Paddr_chunk_0) 55 0 (subrange_vec_dec v 55 0)) ]}
      : SV48_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_Paddr_bits (v : SV48_Paddr) (x : mword 56) 
: SV48_Paddr :=
   
   {[ v with
     SV48_Paddr_SV48_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_Paddr_SV48_Paddr_chunk_0) 55 0 (subrange_vec_dec x 55 0)) ]}.

Definition _get_SV48_Paddr_PPNi (v : SV48_Paddr) 
: mword 44 :=
   
   subrange_vec_dec v.(SV48_Paddr_SV48_Paddr_chunk_0) 55 12.

Definition _set_SV48_Paddr_PPNi
(r_ref : register_ref regstate register_value SV48_Paddr) (v : mword 44) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_Paddr_SV48_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_Paddr_SV48_Paddr_chunk_0) 55 12 (subrange_vec_dec v 43 0)) ]}
      : SV48_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_Paddr_PPNi (v : SV48_Paddr) (x : mword 44) 
: SV48_Paddr :=
   
   {[ v with
     SV48_Paddr_SV48_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_Paddr_SV48_Paddr_chunk_0) 55 12 (subrange_vec_dec x 43 0)) ]}.

Definition _get_SV48_Paddr_PgOfs (v : SV48_Paddr) 
: mword 12 :=
   
   subrange_vec_dec v.(SV48_Paddr_SV48_Paddr_chunk_0) 11 0.

Definition _set_SV48_Paddr_PgOfs
(r_ref : register_ref regstate register_value SV48_Paddr) (v : mword 12) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_Paddr_SV48_Paddr_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_Paddr_SV48_Paddr_chunk_0) 11 0 (subrange_vec_dec v 11 0)) ]}
      : SV48_Paddr in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_Paddr_PgOfs (v : SV48_Paddr) (x : mword 12) 
: SV48_Paddr :=
   
   {[ v with
     SV48_Paddr_SV48_Paddr_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_Paddr_SV48_Paddr_chunk_0) 11 0 (subrange_vec_dec x 11 0)) ]}.

Definition Mk_SV48_PTE (v : mword 64) 
: SV48_PTE :=
   
   {| SV48_PTE_SV48_PTE_chunk_0 := (subrange_vec_dec v 63 0) |}.

Definition _get_SV48_PTE_bits (v : SV48_PTE) 
: mword 64 :=
   
   subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 63 0.

Definition _set_SV48_PTE_bits (r_ref : register_ref regstate register_value SV48_PTE) (v : mword 64)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_PTE_SV48_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_PTE_SV48_PTE_chunk_0) 63 0 (subrange_vec_dec v 63 0)) ]}
      : SV48_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_PTE_bits (v : SV48_PTE) (x : mword 64) 
: SV48_PTE :=
   
   {[ v with
     SV48_PTE_SV48_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 63 0 (subrange_vec_dec x 63 0)) ]}.

Definition _get_SV48_PTE_PPNi (v : SV48_PTE) 
: mword 44 :=
   
   subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 53 10.

Definition _set_SV48_PTE_PPNi (r_ref : register_ref regstate register_value SV48_PTE) (v : mword 44)

: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_PTE_SV48_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_PTE_SV48_PTE_chunk_0) 53 10 (subrange_vec_dec v 43 0)) ]}
      : SV48_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_PTE_PPNi (v : SV48_PTE) (x : mword 44) 
: SV48_PTE :=
   
   {[ v with
     SV48_PTE_SV48_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 53 10 (subrange_vec_dec x 43 0)) ]}.

Definition _get_SV48_PTE_RSW (v : SV48_PTE) 
: mword 2 :=
   
   subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 9 8.

Definition _set_SV48_PTE_RSW (r_ref : register_ref regstate register_value SV48_PTE) (v : mword 2) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_PTE_SV48_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_PTE_SV48_PTE_chunk_0) 9 8 (subrange_vec_dec v 1 0)) ]}
      : SV48_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_PTE_RSW (v : SV48_PTE) (x : mword 2) 
: SV48_PTE :=
   
   {[ v with
     SV48_PTE_SV48_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 9 8 (subrange_vec_dec x 1 0)) ]}.

Definition _get_SV48_PTE_BITS (v : SV48_PTE) 
: mword 8 :=
   
   subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 7 0.

Definition _set_SV48_PTE_BITS (r_ref : register_ref regstate register_value SV48_PTE) (v : mword 8) 
: M (unit) :=
   
   (reg_deref r_ref) >>= fun r =>
   let r :=
     {[ r with
       SV48_PTE_SV48_PTE_chunk_0 :=
         (update_subrange_vec_dec r.(SV48_PTE_SV48_PTE_chunk_0) 7 0 (subrange_vec_dec v 7 0)) ]}
      : SV48_PTE in
   write_reg r_ref r
    : M (unit).

Definition _update_SV48_PTE_BITS (v : SV48_PTE) (x : mword 8) 
: SV48_PTE :=
   
   {[ v with
     SV48_PTE_SV48_PTE_chunk_0 :=
       (update_subrange_vec_dec v.(SV48_PTE_SV48_PTE_chunk_0) 7 0 (subrange_vec_dec x 7 0)) ]}.

Definition make_TLB_Entry {asidlen : Z} {valen : Z} {palen : Z} {ptelen : Z}
(asid : mword asidlen) (global : bool) (vAddr : mword valen) (pAddr : mword palen)
(pte : mword ptelen) (level : Z) (pteAddr : mword palen) (levelBitSize : Z) `{ArithFact (valen > 0)}
`{ArithFact (0 <= level)} `{ArithFact (0 <= levelBitSize)} 
: M (TLB_Entry asidlen valen palen ptelen) :=
   
   let shift := Z.add PAGESIZE_BITS (Z.mul level levelBitSize) in
   let vAddrMask : bits valen :=
     sub_vec_int
       (shiftl
          (xor_vec vAddr (xor_vec vAddr (EXTZ (length_mword vAddr) (vec_of_bits [B1]  : mword 1))))
          shift) 1 in
   let vMatchMask : bits valen := not_vec vAddrMask in
   ((read_reg mcycle_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   returnm (({| TLB_Entry_asid := asid; 
                TLB_Entry_global := global; 
                TLB_Entry_pte := pte; 
                TLB_Entry_pteAddr := pteAddr; 
                TLB_Entry_vAddrMask := vAddrMask; 
                TLB_Entry_vMatchMask := vMatchMask; 
                TLB_Entry_vAddr := (and_vec vAddr vMatchMask); 
                TLB_Entry_pAddr := (shiftl (shiftr pAddr shift) shift); 
                TLB_Entry_age := w__0 |})
    : TLB_Entry asidlen valen palen ptelen).

Definition match_TLB_Entry {asidlen : Z} {valen : Z} {palen : Z} {ptelen : Z}
(ent : TLB_Entry asidlen valen palen ptelen) (asid : mword asidlen) (vaddr : mword valen) 
: bool :=
   
   andb (orb ent.(TLB_Entry_global) (eq_vec ent.(TLB_Entry_asid) asid))
     (eq_vec ent.(TLB_Entry_vAddr) (and_vec ent.(TLB_Entry_vMatchMask) vaddr)).

Definition flush_TLB_Entry {asidlen : Z} {valen : Z} {palen : Z} {ptelen : Z}
(e : TLB_Entry asidlen valen palen ptelen) (asid : option (mword asidlen))
(addr : option (mword valen)) 
: bool :=
   
   match (asid, addr) with
   | (None, None) => true
   | (None, Some (a)) => eq_vec e.(TLB_Entry_vAddr) (and_vec e.(TLB_Entry_vMatchMask) a)
   | (Some (i), None) => andb (eq_vec e.(TLB_Entry_asid) i) (negb e.(TLB_Entry_global))
   | (Some (i), Some (a)) =>
      andb (eq_vec e.(TLB_Entry_asid) i)
        (andb (eq_vec e.(TLB_Entry_vAddr) (and_vec a e.(TLB_Entry_vMatchMask)))
           (negb e.(TLB_Entry_global)))
   end.

Fixpoint _rec_walk39
(vaddr : mword 39) (ac : AccessType) (priv : Privilege) (mxr : bool) (do_sum : bool)
(ptb : mword 56) (level : Z) (global : bool) (_reclimit : Z) `{ArithFact (0 <= level)} 
(_acc : Acc (Zwf 0) _reclimit)
{struct _acc} : M (PTW_Result (mword 56) SV39_PTE) :=
   
   assert_exp' (Z.geb _reclimit 0) "recursion limit reached" >>= fun _ =>
   let va := Mk_SV39_Vaddr vaddr in
   let pt_ofs : paddr64 :=
     shiftl
       (EXTZ 56
          (subrange_vec_dec (shiftr (_get_SV39_Vaddr_VPNi va) (Z.mul level SV39_LEVEL_BITS))
             (Z.sub SV39_LEVEL_BITS 1) 0)) PTE39_LOG_SIZE in
   let pte_addr := add_vec ptb pt_ofs in
   (mem_read ac (EXTZ 64 pte_addr) 8 false false false) >>= fun w__0 : MemoryOpResult (mword (8 * 8)) =>
   (match w__0 with
    | MemException (_) => returnm ((PTW_Failure (PTW_Access))  : PTW_Result (mword 56) SV39_PTE)
    | MemValue (v) =>
       let pte := Mk_SV39_PTE v in
       let pbits := _get_SV39_PTE_BITS pte in
       let pattr := Mk_PTE_Bits pbits in
       let is_global := orb global (eq_vec (_get_PTE_Bits_G pattr) ((bool_to_bits true)  : mword 1)) in
       (if ((isInvalidPTE pbits)) then
          returnm ((PTW_Failure
                      (PTW_Invalid_PTE))
           : PTW_Result (mword 56) SV39_PTE)
        else if ((isPTEPtr pbits)) then
          (if sumbool_of_bool ((Z.eqb level 0)) then
             returnm ((PTW_Failure
                         (PTW_Invalid_PTE))
              : PTW_Result (mword 56) SV39_PTE)
           else
             (_rec_walk39 vaddr ac priv mxr do_sum
                (shiftl (EXTZ 56 (_get_SV39_PTE_PPNi pte)) PAGESIZE_BITS) (Z.sub level 1) is_global
                (Z.sub _reclimit 1) (_limit_reduces _acc))
              : M (PTW_Result (mword 56) SV39_PTE))
           : M (PTW_Result (mword 56) SV39_PTE)
        else
          (checkPTEPermission ac priv mxr do_sum pattr) >>= fun w__3 : bool =>
          returnm ((if sumbool_of_bool ((negb w__3)) then PTW_Failure (PTW_No_Permission)
                    else if sumbool_of_bool ((Z.gtb level 0)) then
                      let mask :=
                        sub_vec_int
                          (shiftl
                             (xor_vec (_get_SV39_PTE_PPNi pte)
                                (xor_vec (_get_SV39_PTE_PPNi pte)
                                   (EXTZ 44 (vec_of_bits [B1]  : mword 1))))
                             (Z.mul level SV39_LEVEL_BITS)) 1 in
                      if ((neq_vec (and_vec (_get_SV39_PTE_PPNi pte) mask)
                             (EXTZ 44 (vec_of_bits [B0]  : mword 1)))) then
                        PTW_Failure
                          (PTW_Misaligned)
                      else
                        let ppn :=
                          or_vec (_get_SV39_PTE_PPNi pte)
                            (and_vec (EXTZ 44 (_get_SV39_Vaddr_VPNi va)) mask) in
                        PTW_Success
                          ((concat_vec ppn (_get_SV39_Vaddr_PgOfs va), pte, pte_addr, build_ex
                          level, is_global))
                    else
                      PTW_Success
                        ((concat_vec (_get_SV39_PTE_PPNi pte) (_get_SV39_Vaddr_PgOfs va), pte, pte_addr, build_ex
                        level, is_global)))
           : PTW_Result (mword 56) SV39_PTE))
        : M (PTW_Result (mword 56) SV39_PTE)
    end)
    : M (PTW_Result (mword 56) SV39_PTE).

Definition walk39
(_arg0 : mword 39) (_arg1 : AccessType) (_arg2 : Privilege) (_arg3 : bool) (_arg4 : bool)
(_arg5 : mword 56) (level : Z) (_arg7 : bool) `{ArithFact (0 <= level)} 
: M (PTW_Result (mword 56) SV39_PTE) :=
   
   (_rec_walk39 _arg0 _arg1 _arg2 _arg3 _arg4 _arg5 level _arg7 (level  : Z) (Zwf_guarded _))
    : M (PTW_Result (mword 56) SV39_PTE).

Definition lookup_TLB39 (asid : mword 16) (vaddr : mword 39) 
: M (option (({n : Z & ArithFact (n >= 0)} * TLB_Entry 16 39 56 64))) :=
   
   read_reg tlb39_ref >>= fun w__0 : option (TLB_Entry 16 39 56 64) =>
   returnm ((match w__0 with
             | None => None
             | Some (e) => if ((match_TLB_Entry e asid vaddr)) then Some ((build_ex 0, e)) else None
             end)
    : option (({n : Z & ArithFact (n >= 0)} * TLB_Entry 16 39 56 64))).

Definition add_to_TLB39
(asid : mword 16) (vAddr : mword 39) (pAddr : mword 56) (pte : SV39_PTE) (pteAddr : mword 56)
(level : Z) (global : bool) `{ArithFact (0 <= level)} 
: M (unit) :=
   
   (make_TLB_Entry asid global vAddr pAddr (_get_SV39_PTE_bits pte) level pteAddr SV39_LEVEL_BITS) >>= fun ent : TLB39_Entry =>
   write_reg tlb39_ref (Some (ent))
    : M (unit).

Definition write_TLB39 (idx : Z) (ent : TLB_Entry 16 39 56 64) `{ArithFact (0 <= idx)} 
: M (unit) :=
   
   write_reg tlb39_ref (Some (ent))
    : M (unit).

Definition flush_TLB39 (asid : option (mword 16)) (addr : option (mword 39)) 
: M (unit) :=
   
   read_reg tlb39_ref >>= fun w__0 : option (TLB_Entry 16 39 56 64) =>
   (match w__0 with
    | None => returnm (tt  : unit)
    | Some (e) =>
       (if ((flush_TLB_Entry e asid addr)) then write_reg tlb39_ref None  : M (unit)
        else returnm (tt  : unit))
        : M (unit)
    end)
    : M (unit).

Definition translate39
(asid : mword 16) (ptb : mword 56) (vAddr : mword 39) (ac : AccessType) (priv : Privilege)
(mxr : bool) (do_sum : bool) (level : Z) `{ArithFact (0 <= level)} 
: M (TR_Result (mword 56) PTW_Error) :=
   
   (lookup_TLB39 asid vAddr) >>= fun w__0 : option (({n : Z & ArithFact (n >= 0)} * TLB_Entry 16 39 56 64)) =>
   (match w__0 with
    | Some ((existT _ idx _, ent)) =>
       let pte := Mk_SV39_PTE ent.(TLB_Entry_pte) in
       let pteBits := Mk_PTE_Bits (_get_SV39_PTE_BITS pte) in
       (checkPTEPermission ac priv mxr do_sum pteBits) >>= fun w__1 : bool =>
       (if sumbool_of_bool ((negb w__1)) then
          returnm ((TR_Failure
                      (PTW_No_Permission))
           : TR_Result (mword 56) PTW_Error)
        else
          (match (update_PTE_Bits pteBits ac) with
           | None =>
              returnm ((TR_Address
                          (or_vec ent.(TLB_Entry_pAddr)
                             (EXTZ 56 (and_vec vAddr ent.(TLB_Entry_vAddrMask)))))
               : TR_Result (mword 56) PTW_Error)
           | Some (pbits) =>
              (if ((negb (plat_enable_dirty_update tt))) then
                 returnm ((TR_Failure
                             (PTW_PTE_Update))
                  : TR_Result (mword 56) PTW_Error)
               else
                 let n_pte := _update_SV39_PTE_BITS pte (_get_PTE_Bits_bits pbits) in
                 let n_ent : TLB39_Entry := ent in
                 let n_ent :=
                   {[ n_ent with TLB_Entry_pte := (_get_SV39_PTE_bits n_pte) ]}
                    : TLB_Entry 16 39 56 64 in
                 (write_TLB39 idx n_ent) >>
                 (mem_write_value (EXTZ 64 ent.(TLB_Entry_pteAddr)) 8 (_get_SV39_PTE_bits n_pte)
                    false false false) >>= fun w__2 : MemoryOpResult bool =>
                 (match w__2 with
                  | MemValue (_) => returnm (tt  : unit)
                  | MemException (e) =>
                     (internal_error "invalid physical address in TLB")  : M (unit)
                  end) >>
                 returnm ((TR_Address
                             (or_vec ent.(TLB_Entry_pAddr)
                                (EXTZ 56 (and_vec vAddr ent.(TLB_Entry_vAddrMask)))))
                  : TR_Result (mword 56) PTW_Error))
               : M (TR_Result (mword 56) PTW_Error)
           end)
           : M (TR_Result (mword 56) PTW_Error))
        : M (TR_Result (mword 56) PTW_Error)
    | None =>
       (walk39 vAddr ac priv mxr do_sum ptb level false) >>= fun w__6 : PTW_Result (mword 56) SV39_PTE =>
       (match w__6 with
        | PTW_Failure (f) => returnm ((TR_Failure (f))  : TR_Result (mword 56) PTW_Error)
        | PTW_Success ((pAddr, pte, pteAddr, existT _ level _, global)) =>
           (match (update_PTE_Bits (Mk_PTE_Bits (_get_SV39_PTE_BITS pte)) ac) with
            | None =>
               (add_to_TLB39 asid vAddr pAddr pte pteAddr level global) >>
               returnm ((TR_Address
                           (pAddr))
                : TR_Result (mword 56) PTW_Error)
            | Some (pbits) =>
               (if ((negb (plat_enable_dirty_update tt))) then
                  returnm ((TR_Failure
                              (PTW_PTE_Update))
                   : TR_Result (mword 56) PTW_Error)
                else
                  let w_pte : SV39_PTE := _update_SV39_PTE_BITS pte (_get_PTE_Bits_bits pbits) in
                  (mem_write_value (EXTZ 64 pteAddr) 8 (_get_SV39_PTE_bits w_pte) false false false) >>= fun w__7 : MemoryOpResult bool =>
                  (match w__7 with
                   | MemValue (_) =>
                      (add_to_TLB39 asid vAddr pAddr w_pte pteAddr level global) >>
                      returnm ((TR_Address
                                  (pAddr))
                       : TR_Result (mword 56) PTW_Error)
                   | MemException (e) =>
                      returnm ((TR_Failure (PTW_Access))  : TR_Result (mword 56) PTW_Error)
                   end)
                   : M (TR_Result (mword 56) PTW_Error))
                : M (TR_Result (mword 56) PTW_Error)
            end)
            : M (TR_Result (mword 56) PTW_Error)
        end)
        : M (TR_Result (mword 56) PTW_Error)
    end)
    : M (TR_Result (mword 56) PTW_Error).

Definition init_vmem_sv39 '(tt : unit)  : M (unit) :=  write_reg tlb39_ref None  : M (unit).

Fixpoint _rec_walk48
(vaddr : mword 48) (ac : AccessType) (priv : Privilege) (mxr : bool) (do_sum : bool)
(ptb : mword 56) (level : Z) (global : bool) (_reclimit : Z) `{ArithFact (0 <= level)} 
(_acc : Acc (Zwf 0) _reclimit)
{struct _acc} : M (PTW_Result (mword 56) SV48_PTE) :=
   
   assert_exp' (Z.geb _reclimit 0) "recursion limit reached" >>= fun _ =>
   let va := Mk_SV48_Vaddr vaddr in
   let pt_ofs : paddr64 :=
     shiftl
       (EXTZ 56
          (subrange_vec_dec (shiftr (_get_SV48_Vaddr_VPNi va) (Z.mul level SV48_LEVEL_BITS))
             (Z.sub SV48_LEVEL_BITS 1) 0)) PTE48_LOG_SIZE in
   let pte_addr := add_vec ptb pt_ofs in
   (mem_read ac (EXTZ 64 pte_addr) 8 false false false) >>= fun w__0 : MemoryOpResult (mword (8 * 8)) =>
   (match w__0 with
    | MemException (_) => returnm ((PTW_Failure (PTW_Access))  : PTW_Result (mword 56) SV48_PTE)
    | MemValue (v) =>
       let pte := Mk_SV48_PTE v in
       let pbits := _get_SV48_PTE_BITS pte in
       let pattr := Mk_PTE_Bits pbits in
       let is_global := orb global (eq_vec (_get_PTE_Bits_G pattr) ((bool_to_bits true)  : mword 1)) in
       (if ((isInvalidPTE pbits)) then
          returnm ((PTW_Failure
                      (PTW_Invalid_PTE))
           : PTW_Result (mword 56) SV48_PTE)
        else if ((isPTEPtr pbits)) then
          (if sumbool_of_bool ((Z.eqb level 0)) then
             returnm ((PTW_Failure
                         (PTW_Invalid_PTE))
              : PTW_Result (mword 56) SV48_PTE)
           else
             (_rec_walk48 vaddr ac priv mxr do_sum
                (shiftl (EXTZ 56 (_get_SV48_PTE_PPNi pte)) PAGESIZE_BITS) (Z.sub level 1) is_global
                (Z.sub _reclimit 1) (_limit_reduces _acc))
              : M (PTW_Result (mword 56) SV48_PTE))
           : M (PTW_Result (mword 56) SV48_PTE)
        else
          (checkPTEPermission ac priv mxr do_sum pattr) >>= fun w__3 : bool =>
          returnm ((if sumbool_of_bool ((negb w__3)) then PTW_Failure (PTW_No_Permission)
                    else if sumbool_of_bool ((Z.gtb level 0)) then
                      let mask :=
                        sub_vec_int
                          (shiftl
                             (xor_vec (_get_SV48_PTE_PPNi pte)
                                (xor_vec (_get_SV48_PTE_PPNi pte)
                                   (EXTZ 44 (vec_of_bits [B1]  : mword 1))))
                             (Z.mul level SV48_LEVEL_BITS)) 1 in
                      if ((neq_vec (and_vec (_get_SV48_PTE_PPNi pte) mask)
                             (EXTZ 44 (vec_of_bits [B0]  : mword 1)))) then
                        PTW_Failure
                          (PTW_Misaligned)
                      else
                        let ppn :=
                          or_vec (_get_SV48_PTE_PPNi pte)
                            (and_vec (EXTZ 44 (_get_SV48_Vaddr_VPNi va)) mask) in
                        PTW_Success
                          ((concat_vec ppn (_get_SV48_Vaddr_PgOfs va), pte, pte_addr, build_ex
                          level, is_global))
                    else
                      PTW_Success
                        ((concat_vec (_get_SV48_PTE_PPNi pte) (_get_SV48_Vaddr_PgOfs va), pte, pte_addr, build_ex
                        level, is_global)))
           : PTW_Result (mword 56) SV48_PTE))
        : M (PTW_Result (mword 56) SV48_PTE)
    end)
    : M (PTW_Result (mword 56) SV48_PTE).

Definition walk48
(_arg0 : mword 48) (_arg1 : AccessType) (_arg2 : Privilege) (_arg3 : bool) (_arg4 : bool)
(_arg5 : mword 56) (level : Z) (_arg7 : bool) `{ArithFact (0 <= level)} 
: M (PTW_Result (mword 56) SV48_PTE) :=
   
   (_rec_walk48 _arg0 _arg1 _arg2 _arg3 _arg4 _arg5 level _arg7 (level  : Z) (Zwf_guarded _))
    : M (PTW_Result (mword 56) SV48_PTE).

Definition lookup_TLB48 (asid : mword 16) (vaddr : mword 48) 
: M (option (({n : Z & ArithFact (n >= 0)} * TLB_Entry 16 48 56 64))) :=
   
   read_reg tlb48_ref >>= fun w__0 : option (TLB_Entry 16 48 56 64) =>
   returnm ((match w__0 with
             | None => None
             | Some (e) => if ((match_TLB_Entry e asid vaddr)) then Some ((build_ex 0, e)) else None
             end)
    : option (({n : Z & ArithFact (n >= 0)} * TLB_Entry 16 48 56 64))).

Definition add_to_TLB48
(asid : mword 16) (vAddr : mword 48) (pAddr : mword 56) (pte : SV48_PTE) (pteAddr : mword 56)
(level : Z) (global : bool) `{ArithFact (0 <= level)} 
: M (unit) :=
   
   (make_TLB_Entry asid global vAddr pAddr (_get_SV48_PTE_bits pte) level pteAddr SV48_LEVEL_BITS) >>= fun ent : TLB48_Entry =>
   write_reg tlb48_ref (Some (ent))
    : M (unit).

Definition write_TLB48 (idx : Z) (ent : TLB_Entry 16 48 56 64) `{ArithFact (0 <= idx)} 
: M (unit) :=
   
   write_reg tlb48_ref (Some (ent))
    : M (unit).

Definition flush_TLB48 (asid : option (mword 16)) (addr : option (mword 48)) 
: M (unit) :=
   
   read_reg tlb48_ref >>= fun w__0 : option (TLB_Entry 16 48 56 64) =>
   (match w__0 with
    | None => returnm (tt  : unit)
    | Some (e) =>
       (if ((flush_TLB_Entry e asid addr)) then write_reg tlb48_ref None  : M (unit)
        else returnm (tt  : unit))
        : M (unit)
    end)
    : M (unit).

Definition translate48
(asid : mword 16) (ptb : mword 56) (vAddr : mword 48) (ac : AccessType) (priv : Privilege)
(mxr : bool) (do_sum : bool) (level : Z) `{ArithFact (0 <= level)} 
: M (TR_Result (mword 56) PTW_Error) :=
   
   (walk48 vAddr ac priv mxr do_sum ptb level false) >>= fun w__0 : PTW_Result (mword 56) SV48_PTE =>
   (match w__0 with
    | PTW_Failure (f) => returnm ((TR_Failure (f))  : TR_Result (mword 56) PTW_Error)
    | PTW_Success ((pAddr, pte, pteAddr, existT _ level _, global)) =>
       (match (update_PTE_Bits (Mk_PTE_Bits (_get_SV48_PTE_BITS pte)) ac) with
        | None =>
           (add_to_TLB48 asid vAddr pAddr pte pteAddr level global) >>
           returnm ((TR_Address
                       (pAddr))
            : TR_Result (mword 56) PTW_Error)
        | Some (pbits) =>
           (if ((negb (plat_enable_dirty_update tt))) then
              returnm ((TR_Failure
                          (PTW_PTE_Update))
               : TR_Result (mword 56) PTW_Error)
            else
              let w_pte : SV48_PTE := _update_SV48_PTE_BITS pte (_get_PTE_Bits_bits pbits) in
              (mem_write_value (EXTZ 64 pteAddr) 8 (_get_SV48_PTE_bits w_pte) false false false) >>= fun w__1 : MemoryOpResult bool =>
              (match w__1 with
               | MemValue (_) =>
                  (add_to_TLB48 asid vAddr pAddr w_pte pteAddr level global) >>
                  returnm ((TR_Address
                              (pAddr))
                   : TR_Result (mword 56) PTW_Error)
               | MemException (e) =>
                  returnm ((TR_Failure (PTW_Access))  : TR_Result (mword 56) PTW_Error)
               end)
               : M (TR_Result (mword 56) PTW_Error))
            : M (TR_Result (mword 56) PTW_Error)
        end)
        : M (TR_Result (mword 56) PTW_Error)
    end)
    : M (TR_Result (mword 56) PTW_Error).

Definition init_vmem_sv48 '(tt : unit)  : M (unit) :=  write_reg tlb48_ref None  : M (unit).

Definition legalize_satp (a : Architecture) (o : mword 64) (v : mword 64) 
: mword 64 :=
   
   legalize_satp64 a o v.

Definition translationMode (priv : Privilege) 
: M (SATPMode) :=
   
   (if ((eq_vec (privLevel_to_bits priv) ((privLevel_to_bits Machine)  : mword 2))) then
      returnm (Sbare
       : SATPMode)
    else
      read_reg mstatus_ref >>= fun w__0 : Mstatus =>
      let arch := architecture (get_mstatus_SXL w__0) in
      (match arch with
       | Some (RV64) =>
          ((read_reg satp_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
          let mbits : satp_mode := _get_Satp64_Mode (Mk_Satp64 w__1) in
          (match (satp64Mode_of_bits RV64 mbits) with
           | Some (m) => returnm (m  : SATPMode)
           | None => (internal_error "invalid RV64 translation mode in satp")  : M (SATPMode)
           end)
           : M (SATPMode)
       | Some (RV32) =>
          ((read_reg satp_ref)  : M (mword 64)) >>= fun w__4 : mword 64 =>
          let s := Mk_Satp32 (subrange_vec_dec w__4 31 0) in
          returnm ((if ((eq_vec (_get_Satp32_Mode s) ((bool_to_bits false)  : mword 1))) then Sbare
                    else Sv32)
           : SATPMode)
       | _ => (internal_error "unsupported address translation arch")  : M (SATPMode)
       end)
       : M (SATPMode))
    : M (SATPMode).

Definition translateAddr (vAddr : mword 64) (ac : AccessType) 
: M (TR_Result (mword 64) ExceptionType) :=
   
   (match ac with
    | Execute => read_reg cur_privilege_ref  : M (Privilege)
    | _ =>
       read_reg mstatus_ref >>= fun w__1 : Mstatus =>
       read_reg cur_privilege_ref >>= fun w__2 : Privilege =>
       (effectivePrivilege w__1 w__2)
        : M (Privilege)
    end) >>= fun effPriv : Privilege =>
   read_reg mstatus_ref >>= fun w__4 : Mstatus =>
   let mxr : bool := eq_vec (_get_Mstatus_MXR w__4) ((bool_to_bits true)  : mword 1) in
   read_reg mstatus_ref >>= fun w__5 : Mstatus =>
   let do_sum : bool := eq_vec (_get_Mstatus_SUM w__5) ((bool_to_bits true)  : mword 1) in
   (translationMode effPriv) >>= fun mode : SATPMode =>
   ((read_reg satp_ref)  : M (mword 64)) >>= fun w__6 : mword 64 =>
   let asid := curAsid64 w__6 in
   ((read_reg satp_ref)  : M (mword 64)) >>= fun w__7 : mword 64 =>
   let ptb := curPTB64 w__7 in
   (match mode with
    | Sbare => returnm ((TR_Address (vAddr))  : TR_Result (mword 64) ExceptionType)
    | Sv39 =>
       (translate39 asid ptb (subrange_vec_dec vAddr 38 0) ac effPriv mxr do_sum
          (Z.sub SV39_LEVELS 1)) >>= fun w__8 : TR_Result (mword 56) PTW_Error =>
       returnm ((match w__8 with
                 | TR_Address (pa) => TR_Address (EXTZ 64 pa)
                 | TR_Failure (f) => TR_Failure (translationException ac f)
                 end)
        : TR_Result (mword 64) ExceptionType)
    | Sv48 =>
       (translate48 asid ptb (subrange_vec_dec vAddr 47 0) ac effPriv mxr do_sum
          (Z.sub SV48_LEVELS 1)) >>= fun w__9 : TR_Result (mword 56) PTW_Error =>
       returnm ((match w__9 with
                 | TR_Address (pa) => TR_Address (EXTZ 64 pa)
                 | TR_Failure (f) => TR_Failure (translationException ac f)
                 end)
        : TR_Result (mword 64) ExceptionType)
    | _ =>
       (internal_error "unsupported address translation scheme")
        : M (TR_Result (mword 64) ExceptionType)
    end)
    : M (TR_Result (mword 64) ExceptionType).

Definition flush_TLB (asid_xlen : option (mword 64)) (addr_xlen : option (mword 64)) 
: M (unit) :=
   
   let '(addr39, addr48) :=
     (match addr_xlen with
      | None => (None, None)
      | Some (a) => (Some (subrange_vec_dec a 38 0), Some (subrange_vec_dec a 47 0))
      end)
      : (option vaddr39 * option vaddr48) in
   let asid : option asid64 :=
     match asid_xlen with | None => None | Some (a) => Some (subrange_vec_dec a 15 0) end in
   (flush_TLB39 asid addr39) >> (flush_TLB48 asid addr48)  : M (unit).

Definition init_vmem '(tt : unit) 
: M (unit) :=
   
   (init_vmem_sv39 tt) >> (init_vmem_sv48 tt)  : M (unit).

Definition encdec_uop_forwards (arg_ : uop) 
: mword 7 :=
   
   match arg_ with
   | RISCV_LUI => (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  : mword 7)
   | RISCV_AUIPC => (vec_of_bits [B0;B0;B1;B0;B1;B1;B1]  : mword 7)
   end.

Definition encdec_uop_backwards (arg_ : mword 7) 
: M (uop) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  : mword 7))) then
      returnm (RISCV_LUI
       : uop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B1;B1;B1]  : mword 7))) then
      returnm (RISCV_AUIPC
       : uop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (uop).

Definition encdec_uop_forwards_matches (arg_ : uop) 
: bool :=
   
   match arg_ with | RISCV_LUI => true | RISCV_AUIPC => true end.

Definition encdec_uop_backwards_matches (arg_ : mword 7) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  : mword 7))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B1;B1;B1]  : mword 7))) then true
   else false.

Definition utype_mnemonic_forwards (arg_ : uop) 
: string :=
   
   match arg_ with | RISCV_LUI => "lui" | RISCV_AUIPC => "auipc" end.

Definition utype_mnemonic_backwards (arg_ : string) 
: M (uop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "lui")) then returnm (RISCV_LUI  : uop)
    else if ((generic_eq p0_ "auipc")) then returnm (RISCV_AUIPC  : uop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (uop).

Definition utype_mnemonic_forwards_matches (arg_ : uop) 
: bool :=
   
   match arg_ with | RISCV_LUI => true | RISCV_AUIPC => true end.

Definition utype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "lui")) then true
   else if ((generic_eq p0_ "auipc")) then true
   else false.

Definition _s496_ (_s497_ : string) 
: option string :=
   
   let _s498_ := _s497_ in
   if ((string_startswith _s498_ "auipc")) then
     match (string_drop _s498_ (projT1 (string_length "auipc"))) with | s_ => Some (s_) end
   else None.

Definition _s492_ (_s493_ : string) 
: option string :=
   
   let _s494_ := _s493_ in
   if ((string_startswith _s494_ "lui")) then
     match (string_drop _s494_ (projT1 (string_length "lui"))) with | s_ => Some (s_) end
   else None.

Definition utype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((uop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s495_ := arg_ in
   (if ((match (_s492_ _s495_) with | Some (s_) => true | _ => false end)) then
      (match (_s492_ _s495_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_LUI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((uop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s496_ _s495_) with | Some (s_) => true | _ => false end)) then
      (match (_s496_ _s495_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_AUIPC, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((uop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((uop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((uop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((uop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_bop_forwards (arg_ : bop) 
: mword 3 :=
   
   match arg_ with
   | RISCV_BEQ => (vec_of_bits [B0;B0;B0]  : mword 3)
   | RISCV_BNE => (vec_of_bits [B0;B0;B1]  : mword 3)
   | RISCV_BLT => (vec_of_bits [B1;B0;B0]  : mword 3)
   | RISCV_BGE => (vec_of_bits [B1;B0;B1]  : mword 3)
   | RISCV_BLTU => (vec_of_bits [B1;B1;B0]  : mword 3)
   | RISCV_BGEU => (vec_of_bits [B1;B1;B1]  : mword 3)
   end.

Definition encdec_bop_backwards (arg_ : mword 3) 
: M (bop) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then returnm (RISCV_BEQ  : bop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then returnm (RISCV_BNE  : bop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then returnm (RISCV_BLT  : bop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then returnm (RISCV_BGE  : bop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then returnm (RISCV_BLTU  : bop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then returnm (RISCV_BGEU  : bop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bop).

Definition encdec_bop_forwards_matches (arg_ : bop) 
: bool :=
   
   match arg_ with
   | RISCV_BEQ => true
   | RISCV_BNE => true
   | RISCV_BLT => true
   | RISCV_BGE => true
   | RISCV_BLTU => true
   | RISCV_BGEU => true
   end.

Definition encdec_bop_backwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then true
   else false.

Definition btype_mnemonic_forwards (arg_ : bop) 
: string :=
   
   match arg_ with
   | RISCV_BEQ => "beq"
   | RISCV_BNE => "bne"
   | RISCV_BLT => "blt"
   | RISCV_BGE => "bge"
   | RISCV_BLTU => "bltu"
   | RISCV_BGEU => "bgeu"
   end.

Definition btype_mnemonic_backwards (arg_ : string) 
: M (bop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "beq")) then returnm (RISCV_BEQ  : bop)
    else if ((generic_eq p0_ "bne")) then returnm (RISCV_BNE  : bop)
    else if ((generic_eq p0_ "blt")) then returnm (RISCV_BLT  : bop)
    else if ((generic_eq p0_ "bge")) then returnm (RISCV_BGE  : bop)
    else if ((generic_eq p0_ "bltu")) then returnm (RISCV_BLTU  : bop)
    else if ((generic_eq p0_ "bgeu")) then returnm (RISCV_BGEU  : bop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bop).

Definition btype_mnemonic_forwards_matches (arg_ : bop) 
: bool :=
   
   match arg_ with
   | RISCV_BEQ => true
   | RISCV_BNE => true
   | RISCV_BLT => true
   | RISCV_BGE => true
   | RISCV_BLTU => true
   | RISCV_BGEU => true
   end.

Definition btype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "beq")) then true
   else if ((generic_eq p0_ "bne")) then true
   else if ((generic_eq p0_ "blt")) then true
   else if ((generic_eq p0_ "bge")) then true
   else if ((generic_eq p0_ "bltu")) then true
   else if ((generic_eq p0_ "bgeu")) then true
   else false.

Definition _s520_ (_s521_ : string) 
: option string :=
   
   let _s522_ := _s521_ in
   if ((string_startswith _s522_ "bgeu")) then
     match (string_drop _s522_ (projT1 (string_length "bgeu"))) with | s_ => Some (s_) end
   else None.

Definition _s516_ (_s517_ : string) 
: option string :=
   
   let _s518_ := _s517_ in
   if ((string_startswith _s518_ "bltu")) then
     match (string_drop _s518_ (projT1 (string_length "bltu"))) with | s_ => Some (s_) end
   else None.

Definition _s512_ (_s513_ : string) 
: option string :=
   
   let _s514_ := _s513_ in
   if ((string_startswith _s514_ "bge")) then
     match (string_drop _s514_ (projT1 (string_length "bge"))) with | s_ => Some (s_) end
   else None.

Definition _s508_ (_s509_ : string) 
: option string :=
   
   let _s510_ := _s509_ in
   if ((string_startswith _s510_ "blt")) then
     match (string_drop _s510_ (projT1 (string_length "blt"))) with | s_ => Some (s_) end
   else None.

Definition _s504_ (_s505_ : string) 
: option string :=
   
   let _s506_ := _s505_ in
   if ((string_startswith _s506_ "bne")) then
     match (string_drop _s506_ (projT1 (string_length "bne"))) with | s_ => Some (s_) end
   else None.

Definition _s500_ (_s501_ : string) 
: option string :=
   
   let _s502_ := _s501_ in
   if ((string_startswith _s502_ "beq")) then
     match (string_drop _s502_ (projT1 (string_length "beq"))) with | s_ => Some (s_) end
   else None.

Definition btype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((bop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s503_ := arg_ in
   (if ((match (_s500_ _s503_) with | Some (s_) => true | _ => false end)) then
      (match (_s500_ _s503_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BEQ, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s504_ _s503_) with | Some (s_) => true | _ => false end)) then
      (match (_s504_ _s503_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BNE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s508_ _s503_) with | Some (s_) => true | _ => false end)) then
      (match (_s508_ _s503_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BLT, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s512_ _s503_) with | Some (s_) => true | _ => false end)) then
      (match (_s512_ _s503_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BGE, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s516_ _s503_) with | Some (s_) => true | _ => false end)) then
      (match (_s516_ _s503_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BLTU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s520_ _s503_) with | Some (s_) => true | _ => false end)) then
      (match (_s520_ _s503_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_BGEU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_iop_forwards (arg_ : iop) 
: mword 3 :=
   
   match arg_ with
   | RISCV_ADDI => (vec_of_bits [B0;B0;B0]  : mword 3)
   | RISCV_SLTI => (vec_of_bits [B0;B1;B0]  : mword 3)
   | RISCV_SLTIU => (vec_of_bits [B0;B1;B1]  : mword 3)
   | RISCV_ANDI => (vec_of_bits [B1;B1;B1]  : mword 3)
   | RISCV_ORI => (vec_of_bits [B1;B1;B0]  : mword 3)
   | RISCV_XORI => (vec_of_bits [B1;B0;B0]  : mword 3)
   end.

Definition encdec_iop_backwards (arg_ : mword 3) 
: M (iop) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then returnm (RISCV_ADDI  : iop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then returnm (RISCV_SLTI  : iop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then returnm (RISCV_SLTIU  : iop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then returnm (RISCV_ANDI  : iop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then returnm (RISCV_ORI  : iop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then returnm (RISCV_XORI  : iop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (iop).

Definition encdec_iop_forwards_matches (arg_ : iop) 
: bool :=
   
   match arg_ with
   | RISCV_ADDI => true
   | RISCV_SLTI => true
   | RISCV_SLTIU => true
   | RISCV_ANDI => true
   | RISCV_ORI => true
   | RISCV_XORI => true
   end.

Definition encdec_iop_backwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0]  : mword 3))) then true
   else false.

Definition itype_mnemonic_forwards (arg_ : iop) 
: string :=
   
   match arg_ with
   | RISCV_ADDI => "addi"
   | RISCV_SLTI => "slti"
   | RISCV_SLTIU => "sltiu"
   | RISCV_XORI => "xori"
   | RISCV_ORI => "ori"
   | RISCV_ANDI => "andi"
   end.

Definition itype_mnemonic_backwards (arg_ : string) 
: M (iop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "addi")) then returnm (RISCV_ADDI  : iop)
    else if ((generic_eq p0_ "slti")) then returnm (RISCV_SLTI  : iop)
    else if ((generic_eq p0_ "sltiu")) then returnm (RISCV_SLTIU  : iop)
    else if ((generic_eq p0_ "xori")) then returnm (RISCV_XORI  : iop)
    else if ((generic_eq p0_ "ori")) then returnm (RISCV_ORI  : iop)
    else if ((generic_eq p0_ "andi")) then returnm (RISCV_ANDI  : iop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (iop).

Definition itype_mnemonic_forwards_matches (arg_ : iop) 
: bool :=
   
   match arg_ with
   | RISCV_ADDI => true
   | RISCV_SLTI => true
   | RISCV_SLTIU => true
   | RISCV_XORI => true
   | RISCV_ORI => true
   | RISCV_ANDI => true
   end.

Definition itype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "addi")) then true
   else if ((generic_eq p0_ "slti")) then true
   else if ((generic_eq p0_ "sltiu")) then true
   else if ((generic_eq p0_ "xori")) then true
   else if ((generic_eq p0_ "ori")) then true
   else if ((generic_eq p0_ "andi")) then true
   else false.

Definition _s544_ (_s545_ : string) 
: option string :=
   
   let _s546_ := _s545_ in
   if ((string_startswith _s546_ "andi")) then
     match (string_drop _s546_ (projT1 (string_length "andi"))) with | s_ => Some (s_) end
   else None.

Definition _s540_ (_s541_ : string) 
: option string :=
   
   let _s542_ := _s541_ in
   if ((string_startswith _s542_ "ori")) then
     match (string_drop _s542_ (projT1 (string_length "ori"))) with | s_ => Some (s_) end
   else None.

Definition _s536_ (_s537_ : string) 
: option string :=
   
   let _s538_ := _s537_ in
   if ((string_startswith _s538_ "xori")) then
     match (string_drop _s538_ (projT1 (string_length "xori"))) with | s_ => Some (s_) end
   else None.

Definition _s532_ (_s533_ : string) 
: option string :=
   
   let _s534_ := _s533_ in
   if ((string_startswith _s534_ "sltiu")) then
     match (string_drop _s534_ (projT1 (string_length "sltiu"))) with | s_ => Some (s_) end
   else None.

Definition _s528_ (_s529_ : string) 
: option string :=
   
   let _s530_ := _s529_ in
   if ((string_startswith _s530_ "slti")) then
     match (string_drop _s530_ (projT1 (string_length "slti"))) with | s_ => Some (s_) end
   else None.

Definition _s524_ (_s525_ : string) 
: option string :=
   
   let _s526_ := _s525_ in
   if ((string_startswith _s526_ "addi")) then
     match (string_drop _s526_ (projT1 (string_length "addi"))) with | s_ => Some (s_) end
   else None.

Definition itype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((iop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s527_ := arg_ in
   (if ((match (_s524_ _s527_) with | Some (s_) => true | _ => false end)) then
      (match (_s524_ _s527_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ADDI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s528_ _s527_) with | Some (s_) => true | _ => false end)) then
      (match (_s528_ _s527_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLTI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s532_ _s527_) with | Some (s_) => true | _ => false end)) then
      (match (_s532_ _s527_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLTIU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s536_ _s527_) with | Some (s_) => true | _ => false end)) then
      (match (_s536_ _s527_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_XORI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s540_ _s527_) with | Some (s_) => true | _ => false end)) then
      (match (_s540_ _s527_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ORI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s544_ _s527_) with | Some (s_) => true | _ => false end)) then
      (match (_s544_ _s527_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ANDI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((iop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((iop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((iop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((iop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_sop_forwards (arg_ : sop) 
: mword 3 :=
   
   match arg_ with
   | RISCV_SLLI => (vec_of_bits [B0;B0;B1]  : mword 3)
   | RISCV_SRLI => (vec_of_bits [B1;B0;B1]  : mword 3)
   | RISCV_SRAI => (vec_of_bits [B1;B0;B1]  : mword 3)
   end.

Definition encdec_sop_backwards (arg_ : mword 3) 
: M (sop) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then returnm (RISCV_SLLI  : sop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then returnm (RISCV_SRLI  : sop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then returnm (RISCV_SRAI  : sop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (sop).

Definition encdec_sop_forwards_matches (arg_ : sop) 
: bool :=
   
   match arg_ with | RISCV_SLLI => true | RISCV_SRLI => true | RISCV_SRAI => true end.

Definition encdec_sop_backwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1]  : mword 3))) then true
   else false.

Definition shiftiop_mnemonic_forwards (arg_ : sop) 
: string :=
   
   match arg_ with | RISCV_SLLI => "slli" | RISCV_SRLI => "srli" | RISCV_SRAI => "srai" end.

Definition shiftiop_mnemonic_backwards (arg_ : string) 
: M (sop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "slli")) then returnm (RISCV_SLLI  : sop)
    else if ((generic_eq p0_ "srli")) then returnm (RISCV_SRLI  : sop)
    else if ((generic_eq p0_ "srai")) then returnm (RISCV_SRAI  : sop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (sop).

Definition shiftiop_mnemonic_forwards_matches (arg_ : sop) 
: bool :=
   
   match arg_ with | RISCV_SLLI => true | RISCV_SRLI => true | RISCV_SRAI => true end.

Definition shiftiop_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slli")) then true
   else if ((generic_eq p0_ "srli")) then true
   else if ((generic_eq p0_ "srai")) then true
   else false.

Definition _s556_ (_s557_ : string) 
: option string :=
   
   let _s558_ := _s557_ in
   if ((string_startswith _s558_ "srai")) then
     match (string_drop _s558_ (projT1 (string_length "srai"))) with | s_ => Some (s_) end
   else None.

Definition _s552_ (_s553_ : string) 
: option string :=
   
   let _s554_ := _s553_ in
   if ((string_startswith _s554_ "srli")) then
     match (string_drop _s554_ (projT1 (string_length "srli"))) with | s_ => Some (s_) end
   else None.

Definition _s548_ (_s549_ : string) 
: option string :=
   
   let _s550_ := _s549_ in
   if ((string_startswith _s550_ "slli")) then
     match (string_drop _s550_ (projT1 (string_length "slli"))) with | s_ => Some (s_) end
   else None.

Definition shiftiop_mnemonic_matches_prefix (arg_ : string) 
: M (option ((sop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s551_ := arg_ in
   (if ((match (_s548_ _s551_) with | Some (s_) => true | _ => false end)) then
      (match (_s548_ _s551_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s552_ _s551_) with | Some (s_) => true | _ => false end)) then
      (match (_s552_ _s551_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s556_ _s551_) with | Some (s_) => true | _ => false end)) then
      (match (_s556_ _s551_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((sop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((sop * {n : Z & ArithFact (n >= 0)}))).

Definition rtype_mnemonic_forwards (arg_ : rop) 
: string :=
   
   match arg_ with
   | RISCV_ADD => "add"
   | RISCV_SLT => "slt"
   | RISCV_SLTU => "sltu"
   | RISCV_AND => "and"
   | RISCV_OR => "or"
   | RISCV_XOR => "xor"
   | RISCV_SLL => "sll"
   | RISCV_SRL => "srl"
   | RISCV_SUB => "sub"
   | RISCV_SRA => "sra"
   end.

Definition rtype_mnemonic_backwards (arg_ : string) 
: M (rop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "add")) then returnm (RISCV_ADD  : rop)
    else if ((generic_eq p0_ "slt")) then returnm (RISCV_SLT  : rop)
    else if ((generic_eq p0_ "sltu")) then returnm (RISCV_SLTU  : rop)
    else if ((generic_eq p0_ "and")) then returnm (RISCV_AND  : rop)
    else if ((generic_eq p0_ "or")) then returnm (RISCV_OR  : rop)
    else if ((generic_eq p0_ "xor")) then returnm (RISCV_XOR  : rop)
    else if ((generic_eq p0_ "sll")) then returnm (RISCV_SLL  : rop)
    else if ((generic_eq p0_ "srl")) then returnm (RISCV_SRL  : rop)
    else if ((generic_eq p0_ "sub")) then returnm (RISCV_SUB  : rop)
    else if ((generic_eq p0_ "sra")) then returnm (RISCV_SRA  : rop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (rop).

Definition rtype_mnemonic_forwards_matches (arg_ : rop) 
: bool :=
   
   match arg_ with
   | RISCV_ADD => true
   | RISCV_SLT => true
   | RISCV_SLTU => true
   | RISCV_AND => true
   | RISCV_OR => true
   | RISCV_XOR => true
   | RISCV_SLL => true
   | RISCV_SRL => true
   | RISCV_SUB => true
   | RISCV_SRA => true
   end.

Definition rtype_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "add")) then true
   else if ((generic_eq p0_ "slt")) then true
   else if ((generic_eq p0_ "sltu")) then true
   else if ((generic_eq p0_ "and")) then true
   else if ((generic_eq p0_ "or")) then true
   else if ((generic_eq p0_ "xor")) then true
   else if ((generic_eq p0_ "sll")) then true
   else if ((generic_eq p0_ "srl")) then true
   else if ((generic_eq p0_ "sub")) then true
   else if ((generic_eq p0_ "sra")) then true
   else false.

Definition _s596_ (_s597_ : string) 
: option string :=
   
   let _s598_ := _s597_ in
   if ((string_startswith _s598_ "sra")) then
     match (string_drop _s598_ (projT1 (string_length "sra"))) with | s_ => Some (s_) end
   else None.

Definition _s592_ (_s593_ : string) 
: option string :=
   
   let _s594_ := _s593_ in
   if ((string_startswith _s594_ "sub")) then
     match (string_drop _s594_ (projT1 (string_length "sub"))) with | s_ => Some (s_) end
   else None.

Definition _s588_ (_s589_ : string) 
: option string :=
   
   let _s590_ := _s589_ in
   if ((string_startswith _s590_ "srl")) then
     match (string_drop _s590_ (projT1 (string_length "srl"))) with | s_ => Some (s_) end
   else None.

Definition _s584_ (_s585_ : string) 
: option string :=
   
   let _s586_ := _s585_ in
   if ((string_startswith _s586_ "sll")) then
     match (string_drop _s586_ (projT1 (string_length "sll"))) with | s_ => Some (s_) end
   else None.

Definition _s580_ (_s581_ : string) 
: option string :=
   
   let _s582_ := _s581_ in
   if ((string_startswith _s582_ "xor")) then
     match (string_drop _s582_ (projT1 (string_length "xor"))) with | s_ => Some (s_) end
   else None.

Definition _s576_ (_s577_ : string) 
: option string :=
   
   let _s578_ := _s577_ in
   if ((string_startswith _s578_ "or")) then
     match (string_drop _s578_ (projT1 (string_length "or"))) with | s_ => Some (s_) end
   else None.

Definition _s572_ (_s573_ : string) 
: option string :=
   
   let _s574_ := _s573_ in
   if ((string_startswith _s574_ "and")) then
     match (string_drop _s574_ (projT1 (string_length "and"))) with | s_ => Some (s_) end
   else None.

Definition _s568_ (_s569_ : string) 
: option string :=
   
   let _s570_ := _s569_ in
   if ((string_startswith _s570_ "sltu")) then
     match (string_drop _s570_ (projT1 (string_length "sltu"))) with | s_ => Some (s_) end
   else None.

Definition _s564_ (_s565_ : string) 
: option string :=
   
   let _s566_ := _s565_ in
   if ((string_startswith _s566_ "slt")) then
     match (string_drop _s566_ (projT1 (string_length "slt"))) with | s_ => Some (s_) end
   else None.

Definition _s560_ (_s561_ : string) 
: option string :=
   
   let _s562_ := _s561_ in
   if ((string_startswith _s562_ "add")) then
     match (string_drop _s562_ (projT1 (string_length "add"))) with | s_ => Some (s_) end
   else None.

Definition rtype_mnemonic_matches_prefix (arg_ : string) 
: M (option ((rop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s563_ := arg_ in
   (if ((match (_s560_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s560_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ADD, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s564_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s564_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLT, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s568_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s568_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLTU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s572_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s572_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_AND, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s576_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s576_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_OR, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s580_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s580_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_XOR, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s584_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s584_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLL, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s588_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s588_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRL, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s592_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s592_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SUB, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s596_ _s563_) with | Some (s_) => true | _ => false end)) then
      (match (_s596_ _s563_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRA, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((rop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((rop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((rop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((rop * {n : Z & ArithFact (n >= 0)}))).

Definition extend_value {n : Z} (is_unsigned : bool) (value : MemoryOpResult (mword (8 * n)))
`{ArithFact (0 < n /\ n <= 8)} 
: MemoryOpResult (mword 64) :=
   
   match value with
   | MemValue (v) =>
      MemValue (if sumbool_of_bool (is_unsigned) then EXTZ 64 v else (EXTS 64 v)  : xlenbits)
   | MemException (e) => MemException (e)
   end.

Definition process_load {n : Z}
(rd : mword 5) (addr : mword 64) (value : MemoryOpResult (mword (8 * n))) (is_unsigned : bool)
`{ArithFact (0 < n /\ n <= 8)} 
: M (Retired) :=
   
   (match (extend_value is_unsigned value) with
    | MemValue (result) =>
       (wX (projT1 (regidx_to_regno rd)) result) >> returnm (RETIRE_SUCCESS  : Retired)
    | MemException (e) => (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
    end)
    : M (Retired).

Definition check_misaligned (vaddr : mword 64) (width : word_width) 
: M (bool) :=
   
   (if ((plat_enable_misaligned_access tt)) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else
      (match width with
       | BYTE =>
          returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))}))
       | HALF =>
          (bit_to_bool (access_vec_dec vaddr 0)) >>= fun w__0 : bool =>
          returnm ((Bool.eqb w__0 true)
           : bool)
       | WORD =>
          (or_boolM
             ((bit_to_bool (access_vec_dec vaddr 0)) >>= fun w__1 : bool =>
              returnm ((Bool.eqb w__1 true)
               : bool))
             ((bit_to_bool (access_vec_dec vaddr 1)) >>= fun w__2 : bool =>
              returnm ((Bool.eqb w__2 true)
               : bool)))
           : M (bool)
       | DOUBLE =>
          (or_boolM
             ((bit_to_bool (access_vec_dec vaddr 0)) >>= fun w__4 : bool =>
              returnm ((Bool.eqb w__4 true)
               : bool))
             ((or_boolM
                 ((bit_to_bool (access_vec_dec vaddr 1)) >>= fun w__5 : bool =>
                  returnm ((Bool.eqb w__5 true)
                   : bool))
                 ((bit_to_bool (access_vec_dec vaddr 2)) >>= fun w__6 : bool =>
                  returnm ((Bool.eqb w__6 true)
                   : bool)))
              : M (bool)))
           : M (bool)
       end)
       : M (bool))
    : M (bool).

Definition maybe_aq_forwards (arg_ : bool) 
: string :=
   
   match arg_ with | true => ".aq" | false => "" end.

Definition maybe_aq_backwards (arg_ : string) 
: M (bool) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ ".aq")) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((generic_eq p0_ "")) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bool).

Definition maybe_aq_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition maybe_aq_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ ".aq")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s604_ (_s605_ : string) 
: option string :=
   
   let _s606_ := _s605_ in
   if ((string_startswith _s606_ "")) then
     match (string_drop _s606_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s600_ (_s601_ : string) 
: option string :=
   
   let _s602_ := _s601_ in
   if ((string_startswith _s602_ ".aq")) then
     match (string_drop _s602_ (projT1 (string_length ".aq"))) with | s_ => Some (s_) end
   else None.

Definition maybe_aq_matches_prefix (arg_ : string) 
: M (option ((bool * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s603_ := arg_ in
   (if ((match (_s600_ _s603_) with | Some (s_) => true | _ => false end)) then
      (match (_s600_ _s603_) with
       | Some (s_) =>
          returnm ((Some
                      ((true, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s604_ _s603_) with | Some (s_) => true | _ => false end)) then
      (match (_s604_ _s603_) with
       | Some (s_) =>
          returnm ((Some
                      ((false, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bool * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bool * {n : Z & ArithFact (n >= 0)}))).

Definition maybe_rl_forwards (arg_ : bool) 
: string :=
   
   match arg_ with | true => ".rl" | false => "" end.

Definition maybe_rl_backwards (arg_ : string) 
: M (bool) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ ".rl")) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((generic_eq p0_ "")) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bool).

Definition maybe_rl_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition maybe_rl_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ ".rl")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s612_ (_s613_ : string) 
: option string :=
   
   let _s614_ := _s613_ in
   if ((string_startswith _s614_ "")) then
     match (string_drop _s614_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s608_ (_s609_ : string) 
: option string :=
   
   let _s610_ := _s609_ in
   if ((string_startswith _s610_ ".rl")) then
     match (string_drop _s610_ (projT1 (string_length ".rl"))) with | s_ => Some (s_) end
   else None.

Definition maybe_rl_matches_prefix (arg_ : string) 
: M (option ((bool * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s611_ := arg_ in
   (if ((match (_s608_ _s611_) with | Some (s_) => true | _ => false end)) then
      (match (_s608_ _s611_) with
       | Some (s_) =>
          returnm ((Some
                      ((true, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s612_ _s611_) with | Some (s_) => true | _ => false end)) then
      (match (_s612_ _s611_) with
       | Some (s_) =>
          returnm ((Some
                      ((false, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bool * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bool * {n : Z & ArithFact (n >= 0)}))).

Definition maybe_u_forwards (arg_ : bool) 
: string :=
   
   match arg_ with | true => "u" | false => "" end.

Definition maybe_u_backwards (arg_ : string) 
: M (bool) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "u")) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((generic_eq p0_ "")) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bool).

Definition maybe_u_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition maybe_u_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "u")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s620_ (_s621_ : string) 
: option string :=
   
   let _s622_ := _s621_ in
   if ((string_startswith _s622_ "")) then
     match (string_drop _s622_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s616_ (_s617_ : string) 
: option string :=
   
   let _s618_ := _s617_ in
   if ((string_startswith _s618_ "u")) then
     match (string_drop _s618_ (projT1 (string_length "u"))) with | s_ => Some (s_) end
   else None.

Definition maybe_u_matches_prefix (arg_ : string) 
: M (option ((bool * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s619_ := arg_ in
   (if ((match (_s616_ _s619_) with | Some (s_) => true | _ => false end)) then
      (match (_s616_ _s619_) with
       | Some (s_) =>
          returnm ((Some
                      ((true, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s620_ _s619_) with | Some (s_) => true | _ => false end)) then
      (match (_s620_ _s619_) with
       | Some (s_) =>
          returnm ((Some
                      ((false, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bool * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bool * {n : Z & ArithFact (n >= 0)}))).

Definition shiftw_mnemonic_forwards (arg_ : sop) 
: string :=
   
   match arg_ with | RISCV_SLLI => "slli" | RISCV_SRLI => "srli" | RISCV_SRAI => "srai" end.

Definition shiftw_mnemonic_backwards (arg_ : string) 
: M (sop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "slli")) then returnm (RISCV_SLLI  : sop)
    else if ((generic_eq p0_ "srli")) then returnm (RISCV_SRLI  : sop)
    else if ((generic_eq p0_ "srai")) then returnm (RISCV_SRAI  : sop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (sop).

Definition shiftw_mnemonic_forwards_matches (arg_ : sop) 
: bool :=
   
   match arg_ with | RISCV_SLLI => true | RISCV_SRLI => true | RISCV_SRAI => true end.

Definition shiftw_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slli")) then true
   else if ((generic_eq p0_ "srli")) then true
   else if ((generic_eq p0_ "srai")) then true
   else false.

Definition _s632_ (_s633_ : string) 
: option string :=
   
   let _s634_ := _s633_ in
   if ((string_startswith _s634_ "srai")) then
     match (string_drop _s634_ (projT1 (string_length "srai"))) with | s_ => Some (s_) end
   else None.

Definition _s628_ (_s629_ : string) 
: option string :=
   
   let _s630_ := _s629_ in
   if ((string_startswith _s630_ "srli")) then
     match (string_drop _s630_ (projT1 (string_length "srli"))) with | s_ => Some (s_) end
   else None.

Definition _s624_ (_s625_ : string) 
: option string :=
   
   let _s626_ := _s625_ in
   if ((string_startswith _s626_ "slli")) then
     match (string_drop _s626_ (projT1 (string_length "slli"))) with | s_ => Some (s_) end
   else None.

Definition shiftw_mnemonic_matches_prefix (arg_ : string) 
: M (option ((sop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s627_ := arg_ in
   (if ((match (_s624_ _s627_) with | Some (s_) => true | _ => false end)) then
      (match (_s624_ _s627_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s628_ _s627_) with | Some (s_) => true | _ => false end)) then
      (match (_s628_ _s627_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s632_ _s627_) with | Some (s_) => true | _ => false end)) then
      (match (_s632_ _s627_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAI, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((sop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((sop * {n : Z & ArithFact (n >= 0)}))).

Definition rtypew_mnemonic_forwards (arg_ : ropw) 
: string :=
   
   match arg_ with
   | RISCV_ADDW => "addw"
   | RISCV_SUBW => "subw"
   | RISCV_SLLW => "sllw"
   | RISCV_SRLW => "srlw"
   | RISCV_SRAW => "sraw"
   end.

Definition rtypew_mnemonic_backwards (arg_ : string) 
: M (ropw) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "addw")) then returnm (RISCV_ADDW  : ropw)
    else if ((generic_eq p0_ "subw")) then returnm (RISCV_SUBW  : ropw)
    else if ((generic_eq p0_ "sllw")) then returnm (RISCV_SLLW  : ropw)
    else if ((generic_eq p0_ "srlw")) then returnm (RISCV_SRLW  : ropw)
    else if ((generic_eq p0_ "sraw")) then returnm (RISCV_SRAW  : ropw)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (ropw).

Definition rtypew_mnemonic_forwards_matches (arg_ : ropw) 
: bool :=
   
   match arg_ with
   | RISCV_ADDW => true
   | RISCV_SUBW => true
   | RISCV_SLLW => true
   | RISCV_SRLW => true
   | RISCV_SRAW => true
   end.

Definition rtypew_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "addw")) then true
   else if ((generic_eq p0_ "subw")) then true
   else if ((generic_eq p0_ "sllw")) then true
   else if ((generic_eq p0_ "srlw")) then true
   else if ((generic_eq p0_ "sraw")) then true
   else false.

Definition _s652_ (_s653_ : string) 
: option string :=
   
   let _s654_ := _s653_ in
   if ((string_startswith _s654_ "sraw")) then
     match (string_drop _s654_ (projT1 (string_length "sraw"))) with | s_ => Some (s_) end
   else None.

Definition _s648_ (_s649_ : string) 
: option string :=
   
   let _s650_ := _s649_ in
   if ((string_startswith _s650_ "srlw")) then
     match (string_drop _s650_ (projT1 (string_length "srlw"))) with | s_ => Some (s_) end
   else None.

Definition _s644_ (_s645_ : string) 
: option string :=
   
   let _s646_ := _s645_ in
   if ((string_startswith _s646_ "sllw")) then
     match (string_drop _s646_ (projT1 (string_length "sllw"))) with | s_ => Some (s_) end
   else None.

Definition _s640_ (_s641_ : string) 
: option string :=
   
   let _s642_ := _s641_ in
   if ((string_startswith _s642_ "subw")) then
     match (string_drop _s642_ (projT1 (string_length "subw"))) with | s_ => Some (s_) end
   else None.

Definition _s636_ (_s637_ : string) 
: option string :=
   
   let _s638_ := _s637_ in
   if ((string_startswith _s638_ "addw")) then
     match (string_drop _s638_ (projT1 (string_length "addw"))) with | s_ => Some (s_) end
   else None.

Definition rtypew_mnemonic_matches_prefix (arg_ : string) 
: M (option ((ropw * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s639_ := arg_ in
   (if ((match (_s636_ _s639_) with | Some (s_) => true | _ => false end)) then
      (match (_s636_ _s639_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_ADDW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s640_ _s639_) with | Some (s_) => true | _ => false end)) then
      (match (_s640_ _s639_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SUBW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s644_ _s639_) with | Some (s_) => true | _ => false end)) then
      (match (_s644_ _s639_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s648_ _s639_) with | Some (s_) => true | _ => false end)) then
      (match (_s648_ _s639_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s652_ _s639_) with | Some (s_) => true | _ => false end)) then
      (match (_s652_ _s639_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ropw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ropw * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((ropw * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((ropw * {n : Z & ArithFact (n >= 0)}))).

Definition shiftiwop_mnemonic_forwards (arg_ : sopw) 
: string :=
   
   match arg_ with | RISCV_SLLIW => "slliw" | RISCV_SRLIW => "srliw" | RISCV_SRAIW => "sraiw" end.

Definition shiftiwop_mnemonic_backwards (arg_ : string) 
: M (sopw) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "slliw")) then returnm (RISCV_SLLIW  : sopw)
    else if ((generic_eq p0_ "srliw")) then returnm (RISCV_SRLIW  : sopw)
    else if ((generic_eq p0_ "sraiw")) then returnm (RISCV_SRAIW  : sopw)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (sopw).

Definition shiftiwop_mnemonic_forwards_matches (arg_ : sopw) 
: bool :=
   
   match arg_ with | RISCV_SLLIW => true | RISCV_SRLIW => true | RISCV_SRAIW => true end.

Definition shiftiwop_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "slliw")) then true
   else if ((generic_eq p0_ "srliw")) then true
   else if ((generic_eq p0_ "sraiw")) then true
   else false.

Definition _s664_ (_s665_ : string) 
: option string :=
   
   let _s666_ := _s665_ in
   if ((string_startswith _s666_ "sraiw")) then
     match (string_drop _s666_ (projT1 (string_length "sraiw"))) with | s_ => Some (s_) end
   else None.

Definition _s660_ (_s661_ : string) 
: option string :=
   
   let _s662_ := _s661_ in
   if ((string_startswith _s662_ "srliw")) then
     match (string_drop _s662_ (projT1 (string_length "srliw"))) with | s_ => Some (s_) end
   else None.

Definition _s656_ (_s657_ : string) 
: option string :=
   
   let _s658_ := _s657_ in
   if ((string_startswith _s658_ "slliw")) then
     match (string_drop _s658_ (projT1 (string_length "slliw"))) with | s_ => Some (s_) end
   else None.

Definition shiftiwop_mnemonic_matches_prefix (arg_ : string) 
: M (option ((sopw * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s659_ := arg_ in
   (if ((match (_s656_ _s659_) with | Some (s_) => true | _ => false end)) then
      (match (_s656_ _s659_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SLLIW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sopw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s660_ _s659_) with | Some (s_) => true | _ => false end)) then
      (match (_s660_ _s659_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRLIW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sopw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s664_ _s659_) with | Some (s_) => true | _ => false end)) then
      (match (_s664_ _s659_) with
       | Some (s_) =>
          returnm ((Some
                      ((RISCV_SRAIW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((sopw * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((sopw * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((sopw * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((sopw * {n : Z & ArithFact (n >= 0)}))).

Definition bit_maybe_r_forwards (arg_ : mword 1) 
: M (string) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then returnm ("r"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then returnm (""  : string)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (string).

Definition bit_maybe_r_backwards (arg_ : string) 
: M (mword 1) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "r")) then returnm ((vec_of_bits [B1]  : mword 1)  : mword 1)
    else if ((generic_eq p0_ "")) then returnm ((vec_of_bits [B0]  : mword 1)  : mword 1)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 1).

Definition bit_maybe_r_forwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else false.

Definition bit_maybe_r_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "r")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s672_ (_s673_ : string) 
: option string :=
   
   let _s674_ := _s673_ in
   if ((string_startswith _s674_ "")) then
     match (string_drop _s674_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s668_ (_s669_ : string) 
: option string :=
   
   let _s670_ := _s669_ in
   if ((string_startswith _s670_ "r")) then
     match (string_drop _s670_ (projT1 (string_length "r"))) with | s_ => Some (s_) end
   else None.

Definition bit_maybe_r_matches_prefix (arg_ : string) 
: M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s671_ := arg_ in
   (if ((match (_s668_ _s671_) with | Some (s_) => true | _ => false end)) then
      (match (_s668_ _s671_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s672_ _s671_) with | Some (s_) => true | _ => false end)) then
      (match (_s672_ _s671_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 1 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))).

Definition bit_maybe_w_forwards (arg_ : mword 1) 
: M (string) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then returnm ("w"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then returnm (""  : string)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (string).

Definition bit_maybe_w_backwards (arg_ : string) 
: M (mword 1) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "w")) then returnm ((vec_of_bits [B1]  : mword 1)  : mword 1)
    else if ((generic_eq p0_ "")) then returnm ((vec_of_bits [B0]  : mword 1)  : mword 1)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 1).

Definition bit_maybe_w_forwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else false.

Definition bit_maybe_w_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "w")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s680_ (_s681_ : string) 
: option string :=
   
   let _s682_ := _s681_ in
   if ((string_startswith _s682_ "")) then
     match (string_drop _s682_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s676_ (_s677_ : string) 
: option string :=
   
   let _s678_ := _s677_ in
   if ((string_startswith _s678_ "w")) then
     match (string_drop _s678_ (projT1 (string_length "w"))) with | s_ => Some (s_) end
   else None.

Definition bit_maybe_w_matches_prefix (arg_ : string) 
: M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s679_ := arg_ in
   (if ((match (_s676_ _s679_) with | Some (s_) => true | _ => false end)) then
      (match (_s676_ _s679_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s680_ _s679_) with | Some (s_) => true | _ => false end)) then
      (match (_s680_ _s679_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 1 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))).

Definition bit_maybe_i_forwards (arg_ : mword 1) 
: M (string) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then returnm ("i"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then returnm (""  : string)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (string).

Definition bit_maybe_i_backwards (arg_ : string) 
: M (mword 1) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "i")) then returnm ((vec_of_bits [B1]  : mword 1)  : mword 1)
    else if ((generic_eq p0_ "")) then returnm ((vec_of_bits [B0]  : mword 1)  : mword 1)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 1).

Definition bit_maybe_i_forwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else false.

Definition bit_maybe_i_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "i")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s688_ (_s689_ : string) 
: option string :=
   
   let _s690_ := _s689_ in
   if ((string_startswith _s690_ "")) then
     match (string_drop _s690_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s684_ (_s685_ : string) 
: option string :=
   
   let _s686_ := _s685_ in
   if ((string_startswith _s686_ "i")) then
     match (string_drop _s686_ (projT1 (string_length "i"))) with | s_ => Some (s_) end
   else None.

Definition bit_maybe_i_matches_prefix (arg_ : string) 
: M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s687_ := arg_ in
   (if ((match (_s684_ _s687_) with | Some (s_) => true | _ => false end)) then
      (match (_s684_ _s687_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s688_ _s687_) with | Some (s_) => true | _ => false end)) then
      (match (_s688_ _s687_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 1 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))).

Definition bit_maybe_o_forwards (arg_ : mword 1) 
: M (string) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then returnm ("o"  : string)
    else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then returnm (""  : string)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (string).

Definition bit_maybe_o_backwards (arg_ : string) 
: M (mword 1) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "o")) then returnm ((vec_of_bits [B1]  : mword 1)  : mword 1)
    else if ((generic_eq p0_ "")) then returnm ((vec_of_bits [B0]  : mword 1)  : mword 1)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 1).

Definition bit_maybe_o_forwards_matches (arg_ : mword 1) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B1]  : mword 1))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0]  : mword 1))) then true
   else false.

Definition bit_maybe_o_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "o")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s696_ (_s697_ : string) 
: option string :=
   
   let _s698_ := _s697_ in
   if ((string_startswith _s698_ "")) then
     match (string_drop _s698_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s692_ (_s693_ : string) 
: option string :=
   
   let _s694_ := _s693_ in
   if ((string_startswith _s694_ "o")) then
     match (string_drop _s694_ (projT1 (string_length "o"))) with | s_ => Some (s_) end
   else None.

Definition bit_maybe_o_matches_prefix (arg_ : string) 
: M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s695_ := arg_ in
   (if ((match (_s692_ _s695_) with | Some (s_) => true | _ => false end)) then
      (match (_s692_ _s695_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B1]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s696_ _s695_) with | Some (s_) => true | _ => false end)) then
      (match (_s696_ _s695_) with
       | Some (s_) =>
          returnm ((Some
                      (((vec_of_bits [B0]  : mword 1), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 1 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 1 * {n : Z & ArithFact (n >= 0)}))).

Definition fence_bits_forwards (arg_ : mword 4) 
: M (string) :=
   
   (match arg_ with
    | v__0 =>
       let i : bits 1 := subrange_vec_dec v__0 3 3 in
       let w : bits 1 := subrange_vec_dec v__0 0 0 in
       let r : bits 1 := subrange_vec_dec v__0 1 1 in
       let o : bits 1 := subrange_vec_dec v__0 2 2 in
       let i : bits 1 := subrange_vec_dec v__0 3 3 in
       (bit_maybe_i_forwards i) >>= fun w__0 : string =>
       (bit_maybe_o_forwards o) >>= fun w__1 : string =>
       (bit_maybe_r_forwards r) >>= fun w__2 : string =>
       (bit_maybe_w_forwards w) >>= fun w__3 : string =>
       returnm ((string_append w__0
                   (string_append w__1 (string_append w__2 (string_append w__3 ""))))
        : string)
    end)
    : M (string).

Definition _s700_ (_s701_ : string) 
: M (option ((mword 1 * mword 1 * mword 1 * mword 1))) :=
   
   (match _s701_ with
    | _s702_ =>
       (bit_maybe_i_matches_prefix _s702_) >>= fun w__0 : option ((mword 1 * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((i, existT _ _s703_ _)) =>
           (match (string_drop _s702_ _s703_) with
            | _s704_ =>
               (bit_maybe_o_matches_prefix _s704_) >>= fun w__1 : option ((mword 1 * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((o, existT _ _s705_ _)) =>
                   (match (string_drop _s704_ _s705_) with
                    | _s706_ =>
                       (bit_maybe_r_matches_prefix _s706_) >>= fun w__2 : option ((mword 1 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((r, existT _ _s707_ _)) =>
                           (match (string_drop _s706_ _s707_) with
                            | _s708_ =>
                               (bit_maybe_w_matches_prefix _s708_) >>= fun w__3 : option ((mword 1 * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some ((w, existT _ _s709_ _)) =>
                                            let p0_ := string_drop _s708_ _s709_ in
                                            if ((generic_eq p0_ "")) then Some ((i, o, r, w))
                                            else None
                                         | _ => None
                                         end)
                                : option ((mword 1 * mword 1 * mword 1 * mword 1)))
                            end)
                            : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
                        | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1)))
                        end)
                        : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
                    end)
                    : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
                | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1)))
                end)
                : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
            end)
            : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
        | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1)))
        end)
        : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
    end)
    : M (option ((mword 1 * mword 1 * mword 1 * mword 1))).

Definition fence_bits_backwards (arg_ : string) 
: M (mword 4) :=
   
   let _s710_ := arg_ in
   (_s700_ _s710_) >>= fun w__0 : option ((mword 1 * mword 1 * mword 1 * mword 1)) =>
   (if ((match w__0 with | Some ((i, o, r, w)) => true | _ => false end)) then
      (_s700_ _s710_) >>= fun w__1 : option ((mword 1 * mword 1 * mword 1 * mword 1)) =>
      (match w__1 with
       | Some ((i, o, r, w)) =>
          returnm ((concat_vec (i  : bits 1)
                      (concat_vec (o  : bits 1) (concat_vec (r  : bits 1) (w  : bits 1))))
           : mword (1 + (1 + (1 + 1))))
       | _ => exit tt  : M (mword 4)
       end)
       : M (mword 4)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (mword 4).

Definition fence_bits_forwards_matches (arg_ : mword 4) 
: bool :=
   
   match arg_ with | v__1 => true end.

Definition _s711_ (_s712_ : string) 
: M (option ((mword 1 * mword 1 * mword 1 * mword 1))) :=
   
   (match _s712_ with
    | _s713_ =>
       (bit_maybe_i_matches_prefix _s713_) >>= fun w__0 : option ((mword 1 * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((i, existT _ _s714_ _)) =>
           (match (string_drop _s713_ _s714_) with
            | _s715_ =>
               (bit_maybe_o_matches_prefix _s715_) >>= fun w__1 : option ((mword 1 * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((o, existT _ _s716_ _)) =>
                   (match (string_drop _s715_ _s716_) with
                    | _s717_ =>
                       (bit_maybe_r_matches_prefix _s717_) >>= fun w__2 : option ((mword 1 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((r, existT _ _s718_ _)) =>
                           (match (string_drop _s717_ _s718_) with
                            | _s719_ =>
                               (bit_maybe_w_matches_prefix _s719_) >>= fun w__3 : option ((mword 1 * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some ((w, existT _ _s720_ _)) =>
                                            let p0_ := string_drop _s719_ _s720_ in
                                            if ((generic_eq p0_ "")) then Some ((i, o, r, w))
                                            else None
                                         | _ => None
                                         end)
                                : option ((mword 1 * mword 1 * mword 1 * mword 1)))
                            end)
                            : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
                        | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1)))
                        end)
                        : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
                    end)
                    : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
                | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1)))
                end)
                : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
            end)
            : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
        | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1)))
        end)
        : M (option ((mword 1 * mword 1 * mword 1 * mword 1)))
    end)
    : M (option ((mword 1 * mword 1 * mword 1 * mword 1))).

Definition fence_bits_backwards_matches (arg_ : string) 
: M (bool) :=
   
   let _s721_ := arg_ in
   (_s711_ _s721_) >>= fun w__0 : option ((mword 1 * mword 1 * mword 1 * mword 1)) =>
   (if ((match w__0 with | Some ((i, o, r, w)) => true | _ => false end)) then
      (_s711_ _s721_) >>= fun w__1 : option ((mword 1 * mword 1 * mword 1 * mword 1)) =>
      (match w__1 with
       | Some ((i, o, r, w)) =>
          returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
       | _ => exit tt  : M (bool)
       end)
       : M (bool)
    else returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))})))
    : M (bool).

Definition _s722_ (_s723_ : string) 
: M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string))) :=
   
   (match _s723_ with
    | _s724_ =>
       (bit_maybe_i_matches_prefix _s724_) >>= fun w__0 : option ((mword 1 * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((i, existT _ _s725_ _)) =>
           (match (string_drop _s724_ _s725_) with
            | _s726_ =>
               (bit_maybe_o_matches_prefix _s726_) >>= fun w__1 : option ((mword 1 * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((o, existT _ _s727_ _)) =>
                   (match (string_drop _s726_ _s727_) with
                    | _s728_ =>
                       (bit_maybe_r_matches_prefix _s728_) >>= fun w__2 : option ((mword 1 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((r, existT _ _s729_ _)) =>
                           (match (string_drop _s728_ _s729_) with
                            | _s730_ =>
                               (bit_maybe_w_matches_prefix _s730_) >>= fun w__3 : option ((mword 1 * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some ((w, existT _ _s731_ _)) =>
                                            match (string_drop _s730_ _s731_) with
                                            | s_ => Some ((i, o, r, w, s_))
                                            end
                                         | _ => None
                                         end)
                                : option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
                            end)
                            : M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
                        | _ =>
                           returnm (None
                            : option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
                        end)
                        : M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
                    end)
                    : M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
                | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
                end)
                : M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
            end)
            : M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
        | _ => returnm (None  : option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
        end)
        : M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string)))
    end)
    : M (option ((mword 1 * mword 1 * mword 1 * mword 1 * string))).

Definition fence_bits_matches_prefix (arg_ : string) 
: M (option ((mword 4 * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s732_ := arg_ in
   (_s722_ _s732_) >>= fun w__0 : option ((mword 1 * mword 1 * mword 1 * mword 1 * string)) =>
   (if ((match w__0 with | Some ((i, o, r, w, s_)) => true | _ => false end)) then
      (_s722_ _s732_) >>= fun w__1 : option ((mword 1 * mword 1 * mword 1 * mword 1 * string)) =>
      (match w__1 with
       | Some ((i, o, r, w, s_)) =>
          returnm ((Some
                      ((concat_vec (i  : bits 1)
                          (concat_vec (o  : bits 1) (concat_vec (r  : bits 1) (w  : bits 1))), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((mword 4 * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((mword 4 * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((mword 4 * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((mword 4 * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((mword 4 * {n : Z & ArithFact (n >= 0)}))).

Definition aqrl_str (aq : bool) (rl : bool) 
: string :=
   
   match (aq, rl) with
   | (false, false) => ""
   | (false, true) => ".rl"
   | (true, false) => ".aq"
   | (true, true) => ".aqrl"
   end.

Definition lrsc_width_str (width : word_width) 
: string :=
   
   match width with | BYTE => ".b" | HALF => ".h" | WORD => ".w" | DOUBLE => ".d" end.

Definition process_loadres {n : Z}
(rd : mword 5) (addr : mword 64) (value : MemoryOpResult (mword (8 * n))) (is_unsigned : bool)
`{ArithFact (0 < n /\ n <= 8)} 
: M (Retired) :=
   
   (match (extend_value is_unsigned value) with
    | MemValue (result) =>
       let '_ := (load_reservation addr)  : unit in
       (wX (projT1 (regidx_to_regno rd)) result) >> returnm (RETIRE_SUCCESS  : Retired)
    | MemException (e) => (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
    end)
    : M (Retired).

Definition encdec_amoop_forwards (arg_ : amoop) 
: mword 5 :=
   
   match arg_ with
   | AMOSWAP => (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5)
   | AMOADD => (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
   | AMOXOR => (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5)
   | AMOAND => (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5)
   | AMOOR => (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5)
   | AMOMIN => (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5)
   | AMOMAX => (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5)
   | AMOMINU => (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5)
   | AMOMAXU => (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5)
   end.

Definition encdec_amoop_backwards (arg_ : mword 5) 
: M (amoop) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))) then returnm (AMOSWAP  : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))) then returnm (AMOADD  : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))) then returnm (AMOXOR  : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))) then returnm (AMOAND  : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))) then returnm (AMOOR  : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))) then returnm (AMOMIN  : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))) then returnm (AMOMAX  : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))) then
      returnm (AMOMINU
       : amoop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))) then
      returnm (AMOMAXU
       : amoop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (amoop).

Definition encdec_amoop_forwards_matches (arg_ : amoop) 
: bool :=
   
   match arg_ with
   | AMOSWAP => true
   | AMOADD => true
   | AMOXOR => true
   | AMOAND => true
   | AMOOR => true
   | AMOMIN => true
   | AMOMAX => true
   | AMOMINU => true
   | AMOMAXU => true
   end.

Definition encdec_amoop_backwards_matches (arg_ : mword 5) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B1]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0]  : mword 5))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B0;B0]  : mword 5))) then true
   else false.

Definition amo_mnemonic_forwards (arg_ : amoop) 
: string :=
   
   match arg_ with
   | AMOSWAP => "amoswap"
   | AMOADD => "amoadd"
   | AMOXOR => "amoxor"
   | AMOAND => "amoand"
   | AMOOR => "amoor"
   | AMOMIN => "amomin"
   | AMOMAX => "amomax"
   | AMOMINU => "amominu"
   | AMOMAXU => "amomaxu"
   end.

Definition amo_mnemonic_backwards (arg_ : string) 
: M (amoop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "amoswap")) then returnm (AMOSWAP  : amoop)
    else if ((generic_eq p0_ "amoadd")) then returnm (AMOADD  : amoop)
    else if ((generic_eq p0_ "amoxor")) then returnm (AMOXOR  : amoop)
    else if ((generic_eq p0_ "amoand")) then returnm (AMOAND  : amoop)
    else if ((generic_eq p0_ "amoor")) then returnm (AMOOR  : amoop)
    else if ((generic_eq p0_ "amomin")) then returnm (AMOMIN  : amoop)
    else if ((generic_eq p0_ "amomax")) then returnm (AMOMAX  : amoop)
    else if ((generic_eq p0_ "amominu")) then returnm (AMOMINU  : amoop)
    else if ((generic_eq p0_ "amomaxu")) then returnm (AMOMAXU  : amoop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (amoop).

Definition amo_mnemonic_forwards_matches (arg_ : amoop) 
: bool :=
   
   match arg_ with
   | AMOSWAP => true
   | AMOADD => true
   | AMOXOR => true
   | AMOAND => true
   | AMOOR => true
   | AMOMIN => true
   | AMOMAX => true
   | AMOMINU => true
   | AMOMAXU => true
   end.

Definition amo_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "amoswap")) then true
   else if ((generic_eq p0_ "amoadd")) then true
   else if ((generic_eq p0_ "amoxor")) then true
   else if ((generic_eq p0_ "amoand")) then true
   else if ((generic_eq p0_ "amoor")) then true
   else if ((generic_eq p0_ "amomin")) then true
   else if ((generic_eq p0_ "amomax")) then true
   else if ((generic_eq p0_ "amominu")) then true
   else if ((generic_eq p0_ "amomaxu")) then true
   else false.

Definition _s765_ (_s766_ : string) 
: option string :=
   
   let _s767_ := _s766_ in
   if ((string_startswith _s767_ "amomaxu")) then
     match (string_drop _s767_ (projT1 (string_length "amomaxu"))) with | s_ => Some (s_) end
   else None.

Definition _s761_ (_s762_ : string) 
: option string :=
   
   let _s763_ := _s762_ in
   if ((string_startswith _s763_ "amominu")) then
     match (string_drop _s763_ (projT1 (string_length "amominu"))) with | s_ => Some (s_) end
   else None.

Definition _s757_ (_s758_ : string) 
: option string :=
   
   let _s759_ := _s758_ in
   if ((string_startswith _s759_ "amomax")) then
     match (string_drop _s759_ (projT1 (string_length "amomax"))) with | s_ => Some (s_) end
   else None.

Definition _s753_ (_s754_ : string) 
: option string :=
   
   let _s755_ := _s754_ in
   if ((string_startswith _s755_ "amomin")) then
     match (string_drop _s755_ (projT1 (string_length "amomin"))) with | s_ => Some (s_) end
   else None.

Definition _s749_ (_s750_ : string) 
: option string :=
   
   let _s751_ := _s750_ in
   if ((string_startswith _s751_ "amoor")) then
     match (string_drop _s751_ (projT1 (string_length "amoor"))) with | s_ => Some (s_) end
   else None.

Definition _s745_ (_s746_ : string) 
: option string :=
   
   let _s747_ := _s746_ in
   if ((string_startswith _s747_ "amoand")) then
     match (string_drop _s747_ (projT1 (string_length "amoand"))) with | s_ => Some (s_) end
   else None.

Definition _s741_ (_s742_ : string) 
: option string :=
   
   let _s743_ := _s742_ in
   if ((string_startswith _s743_ "amoxor")) then
     match (string_drop _s743_ (projT1 (string_length "amoxor"))) with | s_ => Some (s_) end
   else None.

Definition _s737_ (_s738_ : string) 
: option string :=
   
   let _s739_ := _s738_ in
   if ((string_startswith _s739_ "amoadd")) then
     match (string_drop _s739_ (projT1 (string_length "amoadd"))) with | s_ => Some (s_) end
   else None.

Definition _s733_ (_s734_ : string) 
: option string :=
   
   let _s735_ := _s734_ in
   if ((string_startswith _s735_ "amoswap")) then
     match (string_drop _s735_ (projT1 (string_length "amoswap"))) with | s_ => Some (s_) end
   else None.

Definition amo_mnemonic_matches_prefix (arg_ : string) 
: M (option ((amoop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s736_ := arg_ in
   (if ((match (_s733_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s733_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOSWAP, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s737_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s737_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOADD, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s741_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s741_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOXOR, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s745_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s745_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOAND, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s749_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s749_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOOR, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s753_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s753_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOMIN, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s757_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s757_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOMAX, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s761_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s761_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOMINU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s765_ _s736_) with | Some (s_) => true | _ => false end)) then
      (match (_s765_ _s736_) with
       | Some (s_) =>
          returnm ((Some
                      ((AMOMAXU, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((amoop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((amoop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((amoop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((amoop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_mul_op_forwards (arg_ : (bool * bool * bool)) 
: M (mword 3) :=
   
   (match arg_ with
    | (false, true, true) => returnm ((vec_of_bits [B0;B0;B0]  : mword 3)  : mword 3)
    | (true, true, true) => returnm ((vec_of_bits [B0;B0;B1]  : mword 3)  : mword 3)
    | (true, true, false) => returnm ((vec_of_bits [B0;B1;B0]  : mword 3)  : mword 3)
    | (true, false, false) => returnm ((vec_of_bits [B0;B1;B1]  : mword 3)  : mword 3)
    | _ => exit tt  : M (mword 3)
    end)
    : M (mword 3).

Definition encdec_mul_op_backwards (arg_ : mword 3) 
: M ((bool * bool * bool)) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then returnm (false, true, true)
    else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then returnm (true, true, true)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then returnm (true, true, false)
    else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then returnm (true, false, false)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M ((bool * bool * bool)).

Definition encdec_mul_op_forwards_matches (arg_ : (bool * bool * bool)) 
: bool :=
   
   match arg_ with
   | (false, true, true) => true
   | (true, true, true) => true
   | (true, true, false) => true
   | (true, false, false) => true
   | _ => false
   end.

Definition encdec_mul_op_backwards_matches (arg_ : mword 3) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B0;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B0]  : mword 3))) then true
   else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1]  : mword 3))) then true
   else false.

Definition mul_mnemonic_forwards (arg_ : (bool * bool * bool)) 
: M (string) :=
   
   (match arg_ with
    | (false, true, true) => returnm ("mul"  : string)
    | (true, true, true) => returnm ("mulh"  : string)
    | (true, true, false) => returnm ("mulhsu"  : string)
    | (true, false, false) => returnm ("mulhu"  : string)
    | _ => exit tt  : M (string)
    end)
    : M (string).

Definition mul_mnemonic_backwards (arg_ : string) 
: M ((bool * bool * bool)) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "mul")) then returnm (false, true, true)
    else if ((generic_eq p0_ "mulh")) then returnm (true, true, true)
    else if ((generic_eq p0_ "mulhsu")) then returnm (true, true, false)
    else if ((generic_eq p0_ "mulhu")) then returnm (true, false, false)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M ((bool * bool * bool)).

Definition mul_mnemonic_forwards_matches (arg_ : (bool * bool * bool)) 
: bool :=
   
   match arg_ with
   | (false, true, true) => true
   | (true, true, true) => true
   | (true, true, false) => true
   | (true, false, false) => true
   | _ => false
   end.

Definition mul_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "mul")) then true
   else if ((generic_eq p0_ "mulh")) then true
   else if ((generic_eq p0_ "mulhsu")) then true
   else if ((generic_eq p0_ "mulhu")) then true
   else false.

Definition _s781_ (_s782_ : string) 
: option string :=
   
   let _s783_ := _s782_ in
   if ((string_startswith _s783_ "mulhu")) then
     match (string_drop _s783_ (projT1 (string_length "mulhu"))) with | s_ => Some (s_) end
   else None.

Definition _s777_ (_s778_ : string) 
: option string :=
   
   let _s779_ := _s778_ in
   if ((string_startswith _s779_ "mulhsu")) then
     match (string_drop _s779_ (projT1 (string_length "mulhsu"))) with | s_ => Some (s_) end
   else None.

Definition _s773_ (_s774_ : string) 
: option string :=
   
   let _s775_ := _s774_ in
   if ((string_startswith _s775_ "mulh")) then
     match (string_drop _s775_ (projT1 (string_length "mulh"))) with | s_ => Some (s_) end
   else None.

Definition _s769_ (_s770_ : string) 
: option string :=
   
   let _s771_ := _s770_ in
   if ((string_startswith _s771_ "mul")) then
     match (string_drop _s771_ (projT1 (string_length "mul"))) with | s_ => Some (s_) end
   else None.

Definition mul_mnemonic_matches_prefix (arg_ : string) 
: M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s772_ := arg_ in
   (if ((match (_s769_ _s772_) with | Some (s_) => true | _ => false end)) then
      (match (_s769_ _s772_) with
       | Some (s_) =>
          returnm ((Some
                      (((false, true, true), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s773_ _s772_) with | Some (s_) => true | _ => false end)) then
      (match (_s773_ _s772_) with
       | Some (s_) =>
          returnm ((Some
                      (((true, true, true), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s777_ _s772_) with | Some (s_) => true | _ => false end)) then
      (match (_s777_ _s772_) with
       | Some (s_) =>
          returnm ((Some
                      (((true, true, false), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s781_ _s772_) with | Some (s_) => true | _ => false end)) then
      (match (_s781_ _s772_) with
       | Some (s_) =>
          returnm ((Some
                      (((true, false, false), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)}))))
    : M (option (((bool * bool * bool) * {n : Z & ArithFact (n >= 0)}))).

Definition maybe_not_u_forwards (arg_ : bool) 
: string :=
   
   match arg_ with | false => "u" | true => "" end.

Definition maybe_not_u_backwards (arg_ : string) 
: M (bool) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "u")) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else if ((generic_eq p0_ "")) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bool).

Definition maybe_not_u_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | false => true | true => true end.

Definition maybe_not_u_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "u")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s789_ (_s790_ : string) 
: option string :=
   
   let _s791_ := _s790_ in
   if ((string_startswith _s791_ "")) then
     match (string_drop _s791_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s785_ (_s786_ : string) 
: option string :=
   
   let _s787_ := _s786_ in
   if ((string_startswith _s787_ "u")) then
     match (string_drop _s787_ (projT1 (string_length "u"))) with | s_ => Some (s_) end
   else None.

Definition maybe_not_u_matches_prefix (arg_ : string) 
: M (option ((bool * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s788_ := arg_ in
   (if ((match (_s785_ _s788_) with | Some (s_) => true | _ => false end)) then
      (match (_s785_ _s788_) with
       | Some (s_) =>
          returnm ((Some
                      ((false, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s789_ _s788_) with | Some (s_) => true | _ => false end)) then
      (match (_s789_ _s788_) with
       | Some (s_) =>
          returnm ((Some
                      ((true, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bool * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bool * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_csrop_forwards (arg_ : csrop) 
: mword 2 :=
   
   match arg_ with
   | CSRRW => (vec_of_bits [B0;B1]  : mword 2)
   | CSRRS => (vec_of_bits [B1;B0]  : mword 2)
   | CSRRC => (vec_of_bits [B1;B1]  : mword 2)
   end.

Definition encdec_csrop_backwards (arg_ : mword 2) 
: M (csrop) :=
   
   let b__0 := arg_ in
   (if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then returnm (CSRRW  : csrop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then returnm (CSRRS  : csrop)
    else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then returnm (CSRRC  : csrop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (csrop).

Definition encdec_csrop_forwards_matches (arg_ : csrop) 
: bool :=
   
   match arg_ with | CSRRW => true | CSRRS => true | CSRRC => true end.

Definition encdec_csrop_backwards_matches (arg_ : mword 2) 
: bool :=
   
   let b__0 := arg_ in
   if ((eq_vec b__0 (vec_of_bits [B0;B1]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B0]  : mword 2))) then true
   else if ((eq_vec b__0 (vec_of_bits [B1;B1]  : mword 2))) then true
   else false.

Definition readCSR (csr : mword 12) 
: M (mword 64) :=
   
   (match (csr, 64) with
    | (b__0, g__222) =>
       (if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  : mword 12))) then
          ((read_reg mvendorid_ref)  : M (mword 32)) >>= fun w__0 : mword 32 =>
          returnm ((EXTZ 64 w__0)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  : mword 12))) then
          ((read_reg marchid_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  : mword 12))) then
          ((read_reg mimpid_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  : mword 12))) then
          ((read_reg mhartid_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          read_reg mstatus_ref >>= fun w__4 : Mstatus =>
          returnm ((_get_Mstatus_bits w__4)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          read_reg misa_ref >>= fun w__5 : Misa => returnm ((_get_Misa_bits w__5)  : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          read_reg medeleg_ref >>= fun w__6 : Medeleg =>
          returnm ((_get_Medeleg_bits w__6)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          read_reg mideleg_ref >>= fun w__7 : Minterrupts =>
          returnm ((_get_Minterrupts_bits w__7)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mie_ref >>= fun w__8 : Minterrupts =>
          returnm ((_get_Minterrupts_bits w__8)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
          (get_mtvec tt)
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
          read_reg mcounteren_ref >>= fun w__10 : Counteren =>
          returnm ((EXTZ 64 (_get_Counteren_bits w__10))
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg mscratch_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          (get_xret_target Machine) >>= fun w__12 : mword 64 =>
          (pc_alignment_mask tt) >>= fun w__13 : mword 64 =>
          returnm ((and_vec w__12 w__13)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          read_reg mcause_ref >>= fun w__14 : Mcause =>
          returnm ((_get_Mcause_bits w__14)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          ((read_reg mtval_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mip_ref >>= fun w__16 : Minterrupts =>
          returnm ((_get_Minterrupts_bits w__16)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
          (pmpReadCfgReg 0)
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12))) then
          (pmpReadCfgReg 2)
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg pmpaddr0_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B1]  : mword 12))) then
          ((read_reg pmpaddr1_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B0]  : mword 12))) then
          ((read_reg pmpaddr2_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B1]  : mword 12))) then
          ((read_reg pmpaddr3_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B0]  : mword 12))) then
          ((read_reg pmpaddr4_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B1]  : mword 12))) then
          ((read_reg pmpaddr5_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B0]  : mword 12))) then
          ((read_reg pmpaddr6_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B1]  : mword 12))) then
          ((read_reg pmpaddr7_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B0]  : mword 12))) then
          ((read_reg pmpaddr8_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B1]  : mword 12))) then
          ((read_reg pmpaddr9_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0]  : mword 12))) then
          ((read_reg pmpaddr10_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B1]  : mword 12))) then
          ((read_reg pmpaddr11_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B0]  : mword 12))) then
          ((read_reg pmpaddr12_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B1]  : mword 12))) then
          ((read_reg pmpaddr13_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B0]  : mword 12))) then
          ((read_reg pmpaddr14_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1]  : mword 12))) then
          ((read_reg pmpaddr15_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg mcycle_ref)  : M (mword 64)) >>= fun w__35 : mword 64 =>
          returnm ((subrange_vec_dec w__35 (Z.sub 64 1) 0)
           : mword (63 - 0 + 1))
        else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          ((read_reg minstret_ref)  : M (mword 64)) >>= fun w__36 : mword 64 =>
          returnm ((subrange_vec_dec w__36 (Z.sub 64 1) 0)
           : mword (63 - 0 + 1))
        else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg tselect_ref)  : M (mword 64)) >>= fun w__37 : mword 64 =>
          returnm ((not_vec w__37)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          read_reg mstatus_ref >>= fun w__38 : Mstatus =>
          returnm ((_get_Sstatus_bits (lower_mstatus w__38))
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          read_reg sedeleg_ref >>= fun w__39 : Sedeleg =>
          returnm ((_get_Sedeleg_bits w__39)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          read_reg sideleg_ref >>= fun w__40 : Sinterrupts =>
          returnm ((_get_Sinterrupts_bits w__40)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mie_ref >>= fun w__41 : Minterrupts =>
          read_reg mideleg_ref >>= fun w__42 : Minterrupts =>
          returnm ((_get_Sinterrupts_bits (lower_mie w__41 w__42))
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
          (get_stvec tt)
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
          read_reg scounteren_ref >>= fun w__44 : Counteren =>
          returnm ((EXTZ 64 (_get_Counteren_bits w__44))
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg sscratch_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          (get_xret_target Supervisor) >>= fun w__46 : mword 64 =>
          (pc_alignment_mask tt) >>= fun w__47 : mword 64 =>
          returnm ((and_vec w__46 w__47)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          read_reg scause_ref >>= fun w__48 : Mcause =>
          returnm ((_get_Mcause_bits w__48)
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          ((read_reg stval_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mip_ref >>= fun w__50 : Minterrupts =>
          read_reg mideleg_ref >>= fun w__51 : Minterrupts =>
          returnm ((_get_Sinterrupts_bits (lower_mip w__50 w__51))
           : mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg satp_ref)  : M (mword 64))
           : M (mword 64)
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg mcycle_ref)  : M (mword 64)) >>= fun w__53 : mword 64 =>
          returnm ((subrange_vec_dec w__53 (Z.sub 64 1) 0)
           : mword (63 - 0 + 1))
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          ((read_reg mtime_ref)  : M (mword 64)) >>= fun w__54 : mword 64 =>
          returnm ((subrange_vec_dec w__54 (Z.sub 64 1) 0)
           : mword (63 - 0 + 1))
        else if ((eq_vec b__0 (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          ((read_reg minstret_ref)  : M (mword 64)) >>= fun w__55 : mword 64 =>
          returnm ((subrange_vec_dec w__55 (Z.sub 64 1) 0)
           : mword (63 - 0 + 1))
        else
          (ext_read_CSR csr) >>= fun w__56 : option (mword 64) =>
          returnm ((match w__56 with
                    | Some (res) => res
                    | None =>
                       let '_ := (print_bits "unhandled read to CSR " csr)  : unit in
                       EXTZ 64 (vec_of_bits [B0;B0;B0;B0]  : mword 4)
                    end)
           : mword 64))
        : M (mword 64)
    end) >>= fun res : xlenbits =>
   let '_ :=
     (if ((get_config_print_reg tt)) then
        print_endline
          (String.append "CSR "
             (String.append (csr_name csr) (String.append " -> " (string_of_bits res))))
      else tt)
      : unit in
   returnm (res
    : mword 64).

Definition writeCSR (csr : mword 12) (value : mword 64) 
: M (unit) :=
   
   (match (csr, 64) with
    | (b__0, g__221) =>
       (if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          read_reg mstatus_ref >>= fun w__0 : Mstatus =>
          (legalize_mstatus w__0 value) >>= fun w__1 : Mstatus =>
          write_reg mstatus_ref w__1 >>
          read_reg mstatus_ref >>= fun w__2 : Mstatus =>
          returnm ((Some
                      (_get_Mstatus_bits w__2))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          read_reg misa_ref >>= fun w__3 : Misa =>
          (legalize_misa w__3 value) >>= fun w__4 : Misa =>
          write_reg misa_ref w__4 >>
          read_reg misa_ref >>= fun w__5 : Misa =>
          returnm ((Some
                      (_get_Misa_bits w__5))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          read_reg medeleg_ref >>= fun w__6 : Medeleg =>
          write_reg medeleg_ref (legalize_medeleg w__6 value) >>
          read_reg medeleg_ref >>= fun w__7 : Medeleg =>
          returnm ((Some
                      (_get_Medeleg_bits w__7))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          read_reg mideleg_ref >>= fun w__8 : Minterrupts =>
          write_reg mideleg_ref (legalize_mideleg w__8 value) >>
          read_reg mideleg_ref >>= fun w__9 : Minterrupts =>
          returnm ((Some
                      (_get_Minterrupts_bits w__9))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mie_ref >>= fun w__10 : Minterrupts =>
          (legalize_mie w__10 value) >>= fun w__11 : Minterrupts =>
          write_reg mie_ref w__11 >>
          read_reg mie_ref >>= fun w__12 : Minterrupts =>
          returnm ((Some
                      (_get_Minterrupts_bits w__12))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
          (set_mtvec value) >>= fun w__13 : mword 64 =>
          returnm ((Some
                      (w__13))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
          read_reg mcounteren_ref >>= fun w__14 : Counteren =>
          (legalize_mcounteren w__14 value) >>= fun w__15 : Counteren =>
          write_reg mcounteren_ref w__15 >>
          read_reg mcounteren_ref >>= fun w__16 : Counteren =>
          returnm ((Some
                      (EXTZ 64 (_get_Counteren_bits w__16)))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          write_reg mscratch_ref value >>
          ((read_reg mscratch_ref)  : M (mword 64)) >>= fun w__17 : mword 64 =>
          returnm ((Some
                      (w__17))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          (set_xret_target Machine value) >>= fun w__18 : mword 64 =>
          returnm ((Some
                      (w__18))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          (_set_Mcause_bits mcause_ref value) >>
          read_reg mcause_ref >>= fun w__19 : Mcause =>
          returnm ((Some
                      (_get_Mcause_bits w__19))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          write_reg mtval_ref value >>
          ((read_reg mtval_ref)  : M (mword 64)) >>= fun w__20 : mword 64 =>
          returnm ((Some
                      (w__20))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mip_ref >>= fun w__21 : Minterrupts =>
          (legalize_mip w__21 value) >>= fun w__22 : Minterrupts =>
          write_reg mip_ref w__22 >>
          read_reg mip_ref >>= fun w__23 : Minterrupts =>
          returnm ((Some
                      (_get_Minterrupts_bits w__23))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
          (pmpWriteCfgReg 0 value) >> returnm ((Some (value))  : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B0;B0;B0;B1;B0]  : mword 12))) then
          (pmpWriteCfgReg 2 value) >> returnm ((Some (value))  : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B0]  : mword 12))) then
          read_reg pmp0cfg_ref >>= fun w__24 : Pmpcfg_ent =>
          ((read_reg pmpaddr0_ref)  : M (mword 64)) >>= fun w__25 : mword 64 =>
          write_reg pmpaddr0_ref (pmpWriteAddr w__24 w__25 value) >>
          ((read_reg pmpaddr0_ref)  : M (mword 64)) >>= fun w__26 : mword 64 =>
          returnm ((Some
                      (w__26))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B0;B1]  : mword 12))) then
          read_reg pmp1cfg_ref >>= fun w__27 : Pmpcfg_ent =>
          ((read_reg pmpaddr1_ref)  : M (mword 64)) >>= fun w__28 : mword 64 =>
          write_reg pmpaddr1_ref (pmpWriteAddr w__27 w__28 value) >>
          ((read_reg pmpaddr1_ref)  : M (mword 64)) >>= fun w__29 : mword 64 =>
          returnm ((Some
                      (w__29))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B0]  : mword 12))) then
          read_reg pmp2cfg_ref >>= fun w__30 : Pmpcfg_ent =>
          ((read_reg pmpaddr2_ref)  : M (mword 64)) >>= fun w__31 : mword 64 =>
          write_reg pmpaddr2_ref (pmpWriteAddr w__30 w__31 value) >>
          ((read_reg pmpaddr2_ref)  : M (mword 64)) >>= fun w__32 : mword 64 =>
          returnm ((Some
                      (w__32))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B0;B1;B1]  : mword 12))) then
          read_reg pmp3cfg_ref >>= fun w__33 : Pmpcfg_ent =>
          ((read_reg pmpaddr3_ref)  : M (mword 64)) >>= fun w__34 : mword 64 =>
          write_reg pmpaddr3_ref (pmpWriteAddr w__33 w__34 value) >>
          ((read_reg pmpaddr3_ref)  : M (mword 64)) >>= fun w__35 : mword 64 =>
          returnm ((Some
                      (w__35))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B0]  : mword 12))) then
          read_reg pmp4cfg_ref >>= fun w__36 : Pmpcfg_ent =>
          ((read_reg pmpaddr4_ref)  : M (mword 64)) >>= fun w__37 : mword 64 =>
          write_reg pmpaddr4_ref (pmpWriteAddr w__36 w__37 value) >>
          ((read_reg pmpaddr4_ref)  : M (mword 64)) >>= fun w__38 : mword 64 =>
          returnm ((Some
                      (w__38))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B0;B1]  : mword 12))) then
          read_reg pmp5cfg_ref >>= fun w__39 : Pmpcfg_ent =>
          ((read_reg pmpaddr5_ref)  : M (mword 64)) >>= fun w__40 : mword 64 =>
          write_reg pmpaddr5_ref (pmpWriteAddr w__39 w__40 value) >>
          ((read_reg pmpaddr5_ref)  : M (mword 64)) >>= fun w__41 : mword 64 =>
          returnm ((Some
                      (w__41))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B0]  : mword 12))) then
          read_reg pmp6cfg_ref >>= fun w__42 : Pmpcfg_ent =>
          ((read_reg pmpaddr6_ref)  : M (mword 64)) >>= fun w__43 : mword 64 =>
          write_reg pmpaddr6_ref (pmpWriteAddr w__42 w__43 value) >>
          ((read_reg pmpaddr6_ref)  : M (mword 64)) >>= fun w__44 : mword 64 =>
          returnm ((Some
                      (w__44))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B0;B1;B1;B1]  : mword 12))) then
          read_reg pmp7cfg_ref >>= fun w__45 : Pmpcfg_ent =>
          ((read_reg pmpaddr7_ref)  : M (mword 64)) >>= fun w__46 : mword 64 =>
          write_reg pmpaddr7_ref (pmpWriteAddr w__45 w__46 value) >>
          ((read_reg pmpaddr7_ref)  : M (mword 64)) >>= fun w__47 : mword 64 =>
          returnm ((Some
                      (w__47))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B0]  : mword 12))) then
          read_reg pmp8cfg_ref >>= fun w__48 : Pmpcfg_ent =>
          ((read_reg pmpaddr8_ref)  : M (mword 64)) >>= fun w__49 : mword 64 =>
          write_reg pmpaddr8_ref (pmpWriteAddr w__48 w__49 value) >>
          ((read_reg pmpaddr8_ref)  : M (mword 64)) >>= fun w__50 : mword 64 =>
          returnm ((Some
                      (w__50))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B0;B1]  : mword 12))) then
          read_reg pmp9cfg_ref >>= fun w__51 : Pmpcfg_ent =>
          ((read_reg pmpaddr9_ref)  : M (mword 64)) >>= fun w__52 : mword 64 =>
          write_reg pmpaddr9_ref (pmpWriteAddr w__51 w__52 value) >>
          ((read_reg pmpaddr9_ref)  : M (mword 64)) >>= fun w__53 : mword 64 =>
          returnm ((Some
                      (w__53))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B0]  : mword 12))) then
          read_reg pmp10cfg_ref >>= fun w__54 : Pmpcfg_ent =>
          ((read_reg pmpaddr10_ref)  : M (mword 64)) >>= fun w__55 : mword 64 =>
          write_reg pmpaddr10_ref (pmpWriteAddr w__54 w__55 value) >>
          ((read_reg pmpaddr10_ref)  : M (mword 64)) >>= fun w__56 : mword 64 =>
          returnm ((Some
                      (w__56))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B0;B1;B1]  : mword 12))) then
          read_reg pmp11cfg_ref >>= fun w__57 : Pmpcfg_ent =>
          ((read_reg pmpaddr11_ref)  : M (mword 64)) >>= fun w__58 : mword 64 =>
          write_reg pmpaddr11_ref (pmpWriteAddr w__57 w__58 value) >>
          ((read_reg pmpaddr11_ref)  : M (mword 64)) >>= fun w__59 : mword 64 =>
          returnm ((Some
                      (w__59))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B0]  : mword 12))) then
          read_reg pmp12cfg_ref >>= fun w__60 : Pmpcfg_ent =>
          ((read_reg pmpaddr12_ref)  : M (mword 64)) >>= fun w__61 : mword 64 =>
          write_reg pmpaddr12_ref (pmpWriteAddr w__60 w__61 value) >>
          ((read_reg pmpaddr12_ref)  : M (mword 64)) >>= fun w__62 : mword 64 =>
          returnm ((Some
                      (w__62))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B0;B1]  : mword 12))) then
          read_reg pmp13cfg_ref >>= fun w__63 : Pmpcfg_ent =>
          ((read_reg pmpaddr13_ref)  : M (mword 64)) >>= fun w__64 : mword 64 =>
          write_reg pmpaddr13_ref (pmpWriteAddr w__63 w__64 value) >>
          ((read_reg pmpaddr13_ref)  : M (mword 64)) >>= fun w__65 : mword 64 =>
          returnm ((Some
                      (w__65))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B0]  : mword 12))) then
          read_reg pmp14cfg_ref >>= fun w__66 : Pmpcfg_ent =>
          ((read_reg pmpaddr14_ref)  : M (mword 64)) >>= fun w__67 : mword 64 =>
          write_reg pmpaddr14_ref (pmpWriteAddr w__66 w__67 value) >>
          ((read_reg pmpaddr14_ref)  : M (mword 64)) >>= fun w__68 : mword 64 =>
          returnm ((Some
                      (w__68))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B1;B1;B1;B0;B1;B1;B1;B1;B1;B1]  : mword 12))) then
          read_reg pmp15cfg_ref >>= fun w__69 : Pmpcfg_ent =>
          ((read_reg pmpaddr15_ref)  : M (mword 64)) >>= fun w__70 : mword 64 =>
          write_reg pmpaddr15_ref (pmpWriteAddr w__69 w__70 value) >>
          ((read_reg pmpaddr15_ref)  : M (mword 64)) >>= fun w__71 : mword 64 =>
          returnm ((Some
                      (w__71))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          ((read_reg mcycle_ref)  : M (mword 64)) >>= fun w__72 : mword 64 =>
          write_reg mcycle_ref (update_subrange_vec_dec w__72 (Z.sub 64 1) 0 value) >>
          returnm ((Some
                      (value))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          ((read_reg minstret_ref)  : M (mword 64)) >>= fun w__73 : mword 64 =>
          write_reg minstret_ref (update_subrange_vec_dec w__73 (Z.sub 64 1) 0 value) >>
          write_reg minstret_written_ref true >> returnm ((Some (value))  : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  : mword 12))) then
          write_reg tselect_ref value >>
          ((read_reg tselect_ref)  : M (mword 64)) >>= fun w__74 : mword 64 =>
          returnm ((Some
                      (w__74))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          read_reg mstatus_ref >>= fun w__75 : Mstatus =>
          (legalize_sstatus w__75 value) >>= fun w__76 : Mstatus =>
          write_reg mstatus_ref w__76 >>
          read_reg mstatus_ref >>= fun w__77 : Mstatus =>
          returnm ((Some
                      (_get_Mstatus_bits w__77))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          read_reg sedeleg_ref >>= fun w__78 : Sedeleg =>
          write_reg sedeleg_ref (legalize_sedeleg w__78 value) >>
          read_reg sedeleg_ref >>= fun w__79 : Sedeleg =>
          returnm ((Some
                      (_get_Sedeleg_bits w__79))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          (_set_Sinterrupts_bits sideleg_ref value) >>
          read_reg sideleg_ref >>= fun w__80 : Sinterrupts =>
          returnm ((Some
                      (_get_Sinterrupts_bits w__80))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mie_ref >>= fun w__81 : Minterrupts =>
          read_reg mideleg_ref >>= fun w__82 : Minterrupts =>
          (legalize_sie w__81 w__82 value) >>= fun w__83 : Minterrupts =>
          write_reg mie_ref w__83 >>
          read_reg mie_ref >>= fun w__84 : Minterrupts =>
          returnm ((Some
                      (_get_Minterrupts_bits w__84))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12))) then
          (set_stvec value) >>= fun w__85 : mword 64 =>
          returnm ((Some
                      (w__85))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  : mword 12))) then
          read_reg scounteren_ref >>= fun w__86 : Counteren =>
          (legalize_scounteren w__86 value) >>= fun w__87 : Counteren =>
          write_reg scounteren_ref w__87 >>
          read_reg scounteren_ref >>= fun w__88 : Counteren =>
          returnm ((Some
                      (EXTZ 64 (_get_Counteren_bits w__88)))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          write_reg sscratch_ref value >>
          ((read_reg sscratch_ref)  : M (mword 64)) >>= fun w__89 : mword 64 =>
          returnm ((Some
                      (w__89))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  : mword 12))) then
          (set_xret_target Supervisor value) >>= fun w__90 : mword 64 =>
          returnm ((Some
                      (w__90))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  : mword 12))) then
          (_set_Mcause_bits scause_ref value) >>
          read_reg scause_ref >>= fun w__91 : Mcause =>
          returnm ((Some
                      (_get_Mcause_bits w__91))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  : mword 12))) then
          write_reg stval_ref value >>
          ((read_reg stval_ref)  : M (mword 64)) >>= fun w__92 : mword 64 =>
          returnm ((Some
                      (w__92))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  : mword 12))) then
          read_reg mip_ref >>= fun w__93 : Minterrupts =>
          read_reg mideleg_ref >>= fun w__94 : Minterrupts =>
          (legalize_sip w__93 w__94 value) >>= fun w__95 : Minterrupts =>
          write_reg mip_ref w__95 >>
          read_reg mip_ref >>= fun w__96 : Minterrupts =>
          returnm ((Some
                      (_get_Minterrupts_bits w__96))
           : option (mword 64))
        else if ((eq_vec b__0 (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  : mword 12))) then
          (cur_Architecture tt) >>= fun w__97 : Architecture =>
          ((read_reg satp_ref)  : M (mword 64)) >>= fun w__98 : mword 64 =>
          write_reg satp_ref (legalize_satp w__97 w__98 value) >>
          ((read_reg satp_ref)  : M (mword 64)) >>= fun w__99 : mword 64 =>
          returnm ((Some
                      (w__99))
           : option (mword 64))
        else returnm (None  : option (mword 64)))
        : M (option (mword 64))
    end) >>= fun res : option xlenbits =>
   (match res with
    | Some (v) =>
       returnm ((if ((get_config_print_reg tt)) then
                   print_endline
                     (String.append "CSR "
                        (String.append (csr_name csr)
                           (String.append " <- "
                              (String.append (string_of_bits v)
                                 (String.append " (input: "
                                    (String.append (string_of_bits value) ")"))))))
                 else tt)
        : unit)
    | None =>
       (ext_write_CSR csr value) >>= fun w__145 : bool =>
       returnm ((if sumbool_of_bool (w__145) then tt
                 else print_bits "unhandled write to CSR " csr)
        : unit)
    end)
    : M (unit).

Definition maybe_i_forwards (arg_ : bool) 
: string :=
   
   match arg_ with | true => "i" | false => "" end.

Definition maybe_i_backwards (arg_ : string) 
: M (bool) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "i")) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((generic_eq p0_ "")) then
      returnm (projT1
      (build_ex
      false
       : {_bool : bool & ArithFact (not (_bool = true))}))
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (bool).

Definition maybe_i_forwards_matches (arg_ : bool) 
: bool :=
   
   match arg_ with | true => true | false => true end.

Definition maybe_i_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "i")) then true
   else if ((generic_eq p0_ "")) then true
   else false.

Definition _s797_ (_s798_ : string) 
: option string :=
   
   let _s799_ := _s798_ in
   if ((string_startswith _s799_ "")) then
     match (string_drop _s799_ (projT1 (string_length ""))) with | s_ => Some (s_) end
   else None.

Definition _s793_ (_s794_ : string) 
: option string :=
   
   let _s795_ := _s794_ in
   if ((string_startswith _s795_ "i")) then
     match (string_drop _s795_ (projT1 (string_length "i"))) with | s_ => Some (s_) end
   else None.

Definition maybe_i_matches_prefix (arg_ : string) 
: M (option ((bool * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s796_ := arg_ in
   (if ((match (_s793_ _s796_) with | Some (s_) => true | _ => false end)) then
      (match (_s793_ _s796_) with
       | Some (s_) =>
          returnm ((Some
                      ((true, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s797_ _s796_) with | Some (s_) => true | _ => false end)) then
      (match (_s797_ _s796_) with
       | Some (s_) =>
          returnm ((Some
                      ((false, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((bool * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((bool * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((bool * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((bool * {n : Z & ArithFact (n >= 0)}))).

Definition csr_mnemonic_forwards (arg_ : csrop) 
: string :=
   
   match arg_ with | CSRRW => "csrrw" | CSRRS => "csrrs" | CSRRC => "csrrc" end.

Definition csr_mnemonic_backwards (arg_ : string) 
: M (csrop) :=
   
   let p0_ := arg_ in
   (if ((generic_eq p0_ "csrrw")) then returnm (CSRRW  : csrop)
    else if ((generic_eq p0_ "csrrs")) then returnm (CSRRS  : csrop)
    else if ((generic_eq p0_ "csrrc")) then returnm (CSRRC  : csrop)
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (csrop).

Definition csr_mnemonic_forwards_matches (arg_ : csrop) 
: bool :=
   
   match arg_ with | CSRRW => true | CSRRS => true | CSRRC => true end.

Definition csr_mnemonic_backwards_matches (arg_ : string) 
: bool :=
   
   let p0_ := arg_ in
   if ((generic_eq p0_ "csrrw")) then true
   else if ((generic_eq p0_ "csrrs")) then true
   else if ((generic_eq p0_ "csrrc")) then true
   else false.

Definition _s809_ (_s810_ : string) 
: option string :=
   
   let _s811_ := _s810_ in
   if ((string_startswith _s811_ "csrrc")) then
     match (string_drop _s811_ (projT1 (string_length "csrrc"))) with | s_ => Some (s_) end
   else None.

Definition _s805_ (_s806_ : string) 
: option string :=
   
   let _s807_ := _s806_ in
   if ((string_startswith _s807_ "csrrs")) then
     match (string_drop _s807_ (projT1 (string_length "csrrs"))) with | s_ => Some (s_) end
   else None.

Definition _s801_ (_s802_ : string) 
: option string :=
   
   let _s803_ := _s802_ in
   if ((string_startswith _s803_ "csrrw")) then
     match (string_drop _s803_ (projT1 (string_length "csrrw"))) with | s_ => Some (s_) end
   else None.

Definition csr_mnemonic_matches_prefix (arg_ : string) 
: M (option ((csrop * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s804_ := arg_ in
   (if ((match (_s801_ _s804_) with | Some (s_) => true | _ => false end)) then
      (match (_s801_ _s804_) with
       | Some (s_) =>
          returnm ((Some
                      ((CSRRW, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((csrop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((csrop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((csrop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s805_ _s804_) with | Some (s_) => true | _ => false end)) then
      (match (_s805_ _s804_) with
       | Some (s_) =>
          returnm ((Some
                      ((CSRRS, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((csrop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((csrop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((csrop * {n : Z & ArithFact (n >= 0)})))
    else if ((match (_s809_ _s804_) with | Some (s_) => true | _ => false end)) then
      (match (_s809_ _s804_) with
       | Some (s_) =>
          returnm ((Some
                      ((CSRRC, build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((csrop * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((csrop * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((csrop * {n : Z & ArithFact (n >= 0)})))
    else returnm (None  : option ((csrop * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((csrop * {n : Z & ArithFact (n >= 0)}))).

Definition encdec_forwards (arg_ : ast) 
: M (mword 32) :=
   
   (match arg_ with
    | UTYPE ((imm, rd, op)) =>
       returnm ((concat_vec (imm  : mword 20) (concat_vec (rd  : mword 5) (encdec_uop_forwards op)))
        : mword (20 + (5 + 7)))
    | RISCV_JAL ((v__2, rd)) =>
       (if ((eq_vec (subrange_vec_dec v__2 0 0) (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then
          let imm_19 : bits 1 := subrange_vec_dec v__2 20 20 in
          let imm_8 : bits 1 := subrange_vec_dec v__2 11 11 in
          let imm_7_0 : bits 8 := subrange_vec_dec v__2 19 12 in
          let imm_19 : bits 1 := subrange_vec_dec v__2 20 20 in
          let imm_18_13 : bits 6 := subrange_vec_dec v__2 10 5 in
          let imm_12_9 : bits 4 := subrange_vec_dec v__2 4 1 in
          returnm ((concat_vec (imm_19  : bits 1)
                      (concat_vec (imm_18_13  : bits 6)
                         (concat_vec (imm_12_9  : bits 4)
                            (concat_vec (imm_8  : bits 1)
                               (concat_vec (imm_7_0  : bits 8)
                                  (concat_vec (rd  : mword 5)
                                     (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  : mword 7)))))))
           : mword 32)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | RISCV_JALR ((imm, rs1, rd)) =>
       returnm ((concat_vec (imm  : mword 12)
                   (concat_vec (rs1  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                         (concat_vec (rd  : mword 5) (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | BTYPE ((v__4, rs2, rs1, op)) =>
       (if ((eq_vec (subrange_vec_dec v__4 0 0) (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then
          let imm7_6 : bits 1 := subrange_vec_dec v__4 12 12 in
          let imm7_6 : bits 1 := subrange_vec_dec v__4 12 12 in
          let imm7_5_0 : bits 6 := subrange_vec_dec v__4 10 5 in
          let imm5_4_1 : bits 4 := subrange_vec_dec v__4 4 1 in
          let imm5_0 : bits 1 := subrange_vec_dec v__4 11 11 in
          returnm ((concat_vec (imm7_6  : bits 1)
                      (concat_vec (imm7_5_0  : bits 6)
                         (concat_vec (rs2  : mword 5)
                            (concat_vec (rs1  : mword 5)
                               (concat_vec (encdec_bop_forwards op)
                                  (concat_vec (imm5_4_1  : bits 4)
                                     (concat_vec (imm5_0  : bits 1)
                                        (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  : mword 7))))))))
           : mword 32)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | ITYPE ((imm, rs1, rd, op)) =>
       returnm ((concat_vec (imm  : mword 12)
                   (concat_vec (rs1  : mword 5)
                      (concat_vec (encdec_iop_forwards op)
                         (concat_vec (rd  : mword 5) (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | SHIFTIOP ((shamt, rs1, rd, RISCV_SLLI)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6)
                   (concat_vec (shamt  : mword 6)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (6 + (6 + (5 + (3 + (5 + 7))))))
    | SHIFTIOP ((shamt, rs1, rd, RISCV_SRLI)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6)
                   (concat_vec (shamt  : mword 6)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (6 + (6 + (5 + (3 + (5 + 7))))))
    | SHIFTIOP ((shamt, rs1, rd, RISCV_SRAI)) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0]  : mword 6)
                   (concat_vec (shamt  : mword 6)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (6 + (6 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_ADD)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_SLT)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B1;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_SLTU)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B1;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_AND)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B1;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_OR)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B1;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_XOR)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_SLL)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_SRL)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_SUB)) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | RTYPE ((rs2, rs1, rd, RISCV_SRA)) =>
       returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | LOAD ((imm, rs1, rd, is_unsigned, size, false, false)) =>
       (if sumbool_of_bool ((orb (Z.ltb (projT1 (word_width_bytes size)) 8)
                               (andb (negb is_unsigned)
                                  ((Z.leb (projT1 (word_width_bytes size)) 8)
                                   : bool)))) then
          returnm ((concat_vec (imm  : mword 12)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (bool_bits_forwards is_unsigned)
                            (concat_vec (size_bits_forwards size)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  : mword 7))))))
           : mword (12 + (5 + (1 + (2 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | STORE ((v__6, rs2, rs1, size, false, false)) =>
       (if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then
          let imm7 : bits 7 := subrange_vec_dec v__6 11 5 in
          let imm7 : bits 7 := subrange_vec_dec v__6 11 5 in
          let imm5 : bits 5 := subrange_vec_dec v__6 4 0 in
          returnm ((concat_vec (imm7  : bits 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B0]  : mword 1)
                               (concat_vec (size_bits_forwards size)
                                  (concat_vec (imm5  : bits 5)
                                     (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  : mword 7)))))))
           : mword 32)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | ADDIW ((imm, rs1, rd)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (imm  : mword 12)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7)))))
           : mword (12 + (5 + (3 + (5 + 7)))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | SHIFTW ((shamt, rs1, rd, RISCV_SLLI)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (shamt  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | SHIFTW ((shamt, rs1, rd, RISCV_SRLI)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (shamt  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | SHIFTW ((shamt, rs1, rd, RISCV_SRAI)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (shamt  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | RTYPEW ((rs2, rs1, rd, RISCV_ADDW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | RTYPEW ((rs2, rs1, rd, RISCV_SUBW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | RTYPEW ((rs2, rs1, rd, RISCV_SLLW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | RTYPEW ((rs2, rs1, rd, RISCV_SRLW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | RTYPEW ((rs2, rs1, rd, RISCV_SRAW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | SHIFTIWOP ((shamt, rs1, rd, RISCV_SLLIW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (shamt  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRLIW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (shamt  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRAIW)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword 7)
                      (concat_vec (shamt  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | FENCE ((pred, succ)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0]  : mword 4)
                   (concat_vec (pred  : mword 4)
                      (concat_vec (succ  : mword 4)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                               (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                                  (vec_of_bits [B0;B0;B0;B1;B1;B1;B1]  : mword 7)))))))
        : mword (4 + (4 + (4 + (5 + (3 + (5 + 7)))))))
    | FENCE_TSO ((pred, succ)) =>
       returnm ((concat_vec (vec_of_bits [B1;B0;B0;B0]  : mword 4)
                   (concat_vec (pred  : mword 4)
                      (concat_vec (succ  : mword 4)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                               (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                                  (vec_of_bits [B0;B0;B0;B1;B1;B1;B1]  : mword 7)))))))
        : mword (4 + (4 + (4 + (5 + (3 + (5 + 7)))))))
    | FENCEI (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
                   (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (vec_of_bits [B0;B0;B0;B1;B1;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | ECALL (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)
                   (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | MRET (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B1;B1;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                               (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | SRET (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                               (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | EBREAK (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 12)
                   (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | WFI (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  : mword 12)
                   (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7)))))
        : mword (12 + (5 + (3 + (5 + 7)))))
    | SFENCE_VMA ((rs1, rs2)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                               (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | LOADRES ((aq, rl, rs1, size, rd)) =>
       (if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
                      (concat_vec (bool_bits_forwards aq)
                         (concat_vec (bool_bits_forwards rl)
                            (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                               (concat_vec (rs1  : mword 5)
                                  (concat_vec (vec_of_bits [B0]  : mword 1)
                                     (concat_vec (size_bits_forwards size)
                                        (concat_vec (rd  : mword 5)
                                           (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  : mword 7)))))))))
           : mword (5 + (1 + (1 + (5 + (5 + (1 + (2 + (5 + 7)))))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | STORECON ((aq, rl, rs2, rs1, size, rd)) =>
       (if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B1;B1]  : mword 5)
                      (concat_vec (bool_bits_forwards aq)
                         (concat_vec (bool_bits_forwards rl)
                            (concat_vec (rs2  : mword 5)
                               (concat_vec (rs1  : mword 5)
                                  (concat_vec (vec_of_bits [B0]  : mword 1)
                                     (concat_vec (size_bits_forwards size)
                                        (concat_vec (rd  : mword 5)
                                           (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  : mword 7)))))))))
           : mword (5 + (1 + (1 + (5 + (5 + (1 + (2 + (5 + 7)))))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | AMO ((op, aq, rl, rs2, rs1, size, rd)) =>
       (if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then
          returnm ((concat_vec (encdec_amoop_forwards op)
                      (concat_vec (bool_bits_forwards aq)
                         (concat_vec (bool_bits_forwards rl)
                            (concat_vec (rs2  : mword 5)
                               (concat_vec (rs1  : mword 5)
                                  (concat_vec (vec_of_bits [B0]  : mword 1)
                                     (concat_vec (size_bits_forwards size)
                                        (concat_vec (rd  : mword 5)
                                           (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  : mword 7)))))))))
           : mword (5 + (1 + (1 + (5 + (5 + (1 + (2 + (5 + 7)))))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | MUL ((rs2, rs1, rd, high, signed1, signed2)) =>
       (encdec_mul_op_forwards (high, signed1, signed2)) >>= fun w__38 : mword 3 =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (w__38  : bits 3)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | DIV ((rs2, rs1, rd, s)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B0]  : mword 2)
                            (concat_vec (bool_not_bits_forwards s)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7)))))))
        : mword (7 + (5 + (5 + (2 + (1 + (5 + 7)))))))
    | REM ((rs2, rs1, rd, s)) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  : mword 7)
                   (concat_vec (rs2  : mword 5)
                      (concat_vec (rs1  : mword 5)
                         (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                            (concat_vec (bool_not_bits_forwards s)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword 7)))))))
        : mword (7 + (5 + (5 + (2 + (1 + (5 + 7)))))))
    | MULW ((rs2, rs1, rd)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                               (concat_vec (rd  : mword 5)
                                  (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7))))))
           : mword (7 + (5 + (5 + (3 + (5 + 7))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | DIVW ((rs2, rs1, rd, s)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B0]  : mword 2)
                               (concat_vec (bool_not_bits_forwards s)
                                  (concat_vec (rd  : mword 5)
                                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7)))))))
           : mword (7 + (5 + (5 + (2 + (1 + (5 + 7)))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | REMW ((rs2, rs1, rd, s)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  : mword 7)
                      (concat_vec (rs2  : mword 5)
                         (concat_vec (rs1  : mword 5)
                            (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                               (concat_vec (bool_not_bits_forwards s)
                                  (concat_vec (rd  : mword 5)
                                     (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  : mword 7)))))))
           : mword (7 + (5 + (5 + (2 + (1 + (5 + 7)))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 32)
    | CSR ((csr, rs1, rd, is_imm, op)) =>
       returnm ((concat_vec (csr  : mword 12)
                   (concat_vec (rs1  : mword 5)
                      (concat_vec (bool_bits_forwards is_imm)
                         (concat_vec (encdec_csrop_forwards op)
                            (concat_vec (rd  : mword 5)
                               (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (12 + (5 + (1 + (2 + (5 + 7))))))
    | URET (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword 7)
                   (concat_vec (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
                      (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                            (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                               (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  : mword 7))))))
        : mword (7 + (5 + (5 + (3 + (5 + 7))))))
    | ILLEGAL (s) => returnm (s  : mword 32)
    | _ => assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt
    end)
    : M (mword 32).

Definition encdec_backwards (arg_ : mword 32) 
: M (ast) :=
   
   let v__7 := arg_ in
   let _mappingpatterns_23_ : mword 7 := subrange_vec_dec v__7 6 0 in
   (and_boolM (returnm ((encdec_uop_backwards_matches _mappingpatterns_23_)  : bool))
      ((if ((encdec_uop_backwards_matches _mappingpatterns_23_)) then
          (encdec_uop_backwards _mappingpatterns_23_) >>= fun op => returnm ((true  : bool)  : bool)
        else returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))})))
       : M (bool))) >>= fun w__1 : bool =>
   (if sumbool_of_bool (w__1) then
      let imm : mword 20 := subrange_vec_dec v__7 31 12 in
      let rd : mword 5 := subrange_vec_dec v__7 11 7 in
      let imm : mword 20 := subrange_vec_dec v__7 31 12 in
      let _mappingpatterns_23_ : mword 7 := subrange_vec_dec v__7 6 0 in
      (encdec_uop_backwards _mappingpatterns_23_) >>= fun op =>
      returnm ((UTYPE
                  ((imm, rd, op)))
       : ast)
    else if ((eq_vec (subrange_vec_dec v__7 6 0)
                (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  : mword (6 - 0 + 1)))) then
      let imm_19 : bits 1 := subrange_vec_dec v__7 31 31 in
      let rd : mword 5 := subrange_vec_dec v__7 11 7 in
      let imm_8 : bits 1 := subrange_vec_dec v__7 20 20 in
      let imm_7_0 : bits 8 := subrange_vec_dec v__7 19 12 in
      let imm_19 : bits 1 := subrange_vec_dec v__7 31 31 in
      let imm_18_13 : bits 6 := subrange_vec_dec v__7 30 25 in
      let imm_12_9 : bits 4 := subrange_vec_dec v__7 24 21 in
      returnm ((RISCV_JAL
                  ((concat_vec (imm_19  : bits 1)
                      (concat_vec (imm_7_0  : bits 8)
                         (concat_vec (imm_8  : bits 1)
                            (concat_vec (imm_18_13  : bits 6)
                               (concat_vec (imm_12_9  : bits 4) (vec_of_bits [B0]  : mword 1))))), rd)))
       : ast)
    else if ((andb
                (eq_vec (subrange_vec_dec v__7 14 12)
                   (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__7 6 0)
                   (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  : mword (6 - 0 + 1))))) then
      let imm : mword 12 := subrange_vec_dec v__7 31 20 in
      let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
      let rd : mword 5 := subrange_vec_dec v__7 11 7 in
      let imm : mword 12 := subrange_vec_dec v__7 31 20 in
      returnm ((RISCV_JALR
                  ((imm, rs1, rd)))
       : ast)
    else
      (and_boolM
         (let _mappingpatterns_24_ : mword 3 := subrange_vec_dec v__7 14 12 in
         (and_boolM (returnm ((encdec_bop_backwards_matches _mappingpatterns_24_)  : bool))
            ((if ((encdec_bop_backwards_matches _mappingpatterns_24_)) then
                (encdec_bop_backwards _mappingpatterns_24_) >>= fun op =>
                returnm ((true
                 : bool)
                 : bool)
              else
                returnm (projT1
                (build_ex
                false
                 : {_bool : bool & ArithFact (not (_bool = true))})))
             : M (bool)))
          : M (bool))
         (returnm ((eq_vec (subrange_vec_dec v__7 6 0)
                      (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1)))
           : bool))) >>= fun w__4 : bool =>
      (if sumbool_of_bool (w__4) then
         let imm7_6 : bits 1 := subrange_vec_dec v__7 31 31 in
         let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
         let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
         let imm7_6 : bits 1 := subrange_vec_dec v__7 31 31 in
         let imm7_5_0 : bits 6 := subrange_vec_dec v__7 30 25 in
         let imm5_4_1 : bits 4 := subrange_vec_dec v__7 11 8 in
         let imm5_0 : bits 1 := subrange_vec_dec v__7 7 7 in
         let _mappingpatterns_24_ : mword 3 := subrange_vec_dec v__7 14 12 in
         (encdec_bop_backwards _mappingpatterns_24_) >>= fun op =>
         returnm ((BTYPE
                     ((concat_vec (imm7_6  : bits 1)
                         (concat_vec (imm5_0  : bits 1)
                            (concat_vec (imm7_5_0  : bits 6)
                               (concat_vec (imm5_4_1  : bits 4) (vec_of_bits [B0]  : mword 1)))), rs2, rs1, op)))
          : ast)
       else
         (and_boolM
            (let _mappingpatterns_25_ : mword 3 := subrange_vec_dec v__7 14 12 in
            (and_boolM (returnm ((encdec_iop_backwards_matches _mappingpatterns_25_)  : bool))
               ((if ((encdec_iop_backwards_matches _mappingpatterns_25_)) then
                   (encdec_iop_backwards _mappingpatterns_25_) >>= fun op =>
                   returnm ((true
                    : bool)
                    : bool)
                 else
                   returnm (projT1
                   (build_ex
                   false
                    : {_bool : bool & ArithFact (not (_bool = true))})))
                : M (bool)))
             : M (bool))
            (returnm ((eq_vec (subrange_vec_dec v__7 6 0)
                         (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))
              : bool))) >>= fun w__7 : bool =>
         (if sumbool_of_bool (w__7) then
            let imm : mword 12 := subrange_vec_dec v__7 31 20 in
            let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
            let rd : mword 5 := subrange_vec_dec v__7 11 7 in
            let imm : mword 12 := subrange_vec_dec v__7 31 20 in
            let _mappingpatterns_25_ : mword 3 := subrange_vec_dec v__7 14 12 in
            (encdec_iop_backwards _mappingpatterns_25_) >>= fun op =>
            returnm ((ITYPE
                        ((imm, rs1, rd, op)))
             : ast)
          else
            (and_boolMP
               ((let shamt : mword 6 := subrange_vec_dec v__7 25 20 in
               (or_boolMP
                  ((returnm (build_ex
                    (projT1
                    (build_ex
                    (Z.eqb 64 64)
                     : {_bool : bool & ArithFact (iff (_bool = true) (64 = 64))})))) : M ({_bool : bool & ArithFact (iff (_bool =
                    true) (64 = 64))}))
                  (build_trivial_ex
                  ((bit_to_bool (access_vec_dec shamt 5)) >>= fun w__8 : bool =>
                   returnm ((Bool.eqb w__8 false)
                    : bool))) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 =
                 64 \/
                 simp_0 = true))}))
                : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 = 64 \/
                 simp_0 = true))})) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                 true) (64 = 64 \/ simp_0 = true))}))
               (build_trivial_ex
               (returnm ((andb
                            (eq_vec (subrange_vec_dec v__7 31 26)
                               (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
                            (andb
                               (eq_vec (subrange_vec_dec v__7 14 12)
                                  (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                               (eq_vec (subrange_vec_dec v__7 6 0)
                                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))
                 : bool))) : M ({_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool = true) (simp_0 =
              true /\
              (64 = 64 \/ simp_1 = true)))})) >>= fun '(existT _ w__10 _ : {_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
              true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))}) =>
            (if sumbool_of_bool (w__10) then
               let shamt : mword 6 := subrange_vec_dec v__7 25 20 in
               let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
               let rd : mword 5 := subrange_vec_dec v__7 11 7 in
               returnm ((SHIFTIOP
                           ((shamt, rs1, rd, RISCV_SLLI)))
                : ast)
             else
               (and_boolMP
                  ((let shamt : mword 6 := subrange_vec_dec v__7 25 20 in
                  (or_boolMP
                     ((returnm (build_ex
                       (projT1
                       (build_ex
                       (Z.eqb 64 64)
                        : {_bool : bool & ArithFact (iff (_bool = true) (64 = 64))})))) : M ({_bool : bool & ArithFact (iff (_bool =
                       true) (64 = 64))}))
                     (build_trivial_ex
                     ((bit_to_bool (access_vec_dec shamt 5)) >>= fun w__11 : bool =>
                      returnm ((Bool.eqb w__11 false)
                       : bool))) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 =
                    64 \/
                    simp_0 = true))}))
                   : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 = 64 \/
                    simp_0 = true))})) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                    true) (64 = 64 \/ simp_0 = true))}))
                  (build_trivial_ex
                  (returnm ((andb
                               (eq_vec (subrange_vec_dec v__7 31 26)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))
                    : bool))) : M ({_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                 true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))})) >>= fun '(existT _ w__13 _ : {_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                 true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))}) =>
               (if sumbool_of_bool (w__13) then
                  let shamt : mword 6 := subrange_vec_dec v__7 25 20 in
                  let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                  let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                  returnm ((SHIFTIOP
                              ((shamt, rs1, rd, RISCV_SRLI)))
                   : ast)
                else
                  (and_boolMP
                     ((let shamt : mword 6 := subrange_vec_dec v__7 25 20 in
                     (or_boolMP
                        ((returnm (build_ex
                          (projT1
                          (build_ex
                          (Z.eqb 64 64)
                           : {_bool : bool & ArithFact (iff (_bool = true) (64 = 64))})))) : M ({_bool : bool & ArithFact (iff (_bool =
                          true) (64 = 64))}))
                        (build_trivial_ex
                        ((bit_to_bool (access_vec_dec shamt 5)) >>= fun w__14 : bool =>
                         returnm ((Bool.eqb w__14 false)
                          : bool))) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                       true) (64 = 64 \/ simp_0 = true))}))
                      : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 = 64 \/
                       simp_0 = true))})) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                       true) (64 = 64 \/ simp_0 = true))}))
                     (build_trivial_ex
                     (returnm ((andb
                                  (eq_vec (subrange_vec_dec v__7 31 26)
                                     (vec_of_bits [B0;B1;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
                                  (andb
                                     (eq_vec (subrange_vec_dec v__7 14 12)
                                        (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                     (eq_vec (subrange_vec_dec v__7 6 0)
                                        (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))
                       : bool))) : M ({_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                    true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))})) >>= fun '(existT _ w__16 _ : {_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                    true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))}) =>
                  (if sumbool_of_bool (w__16) then
                     let shamt : mword 6 := subrange_vec_dec v__7 25 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((SHIFTIOP
                                 ((shamt, rs1, rd, RISCV_SRAI)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_ADD)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B0;B1;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_SLT)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B0;B1;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_SLTU)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B1;B1;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_AND)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B1;B1;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_OR)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B1;B0;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_XOR)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_SLL)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_SRL)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_SUB)))
                      : ast)
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__7 31 25)
                                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__7 14 12)
                                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                     let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                     let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                     returnm ((RTYPE
                                 ((rs2, rs1, rd, RISCV_SRA)))
                      : ast)
                   else
                     (and_boolM
                        (let _mappingpatterns_27_ : mword 2 := subrange_vec_dec v__7 13 12 in
                        let _mappingpatterns_26_ : mword 1 := subrange_vec_dec v__7 14 14 in
                        (and_boolM
                           (returnm ((size_bits_backwards_matches _mappingpatterns_27_)
                             : bool))
                           ((if ((size_bits_backwards_matches _mappingpatterns_27_)) then
                               (size_bits_backwards _mappingpatterns_27_) >>= fun size =>
                               (and_boolM
                                  (returnm ((bool_bits_backwards_matches _mappingpatterns_26_)
                                    : bool))
                                  ((if ((bool_bits_backwards_matches _mappingpatterns_26_)) then
                                      (bool_bits_backwards _mappingpatterns_26_) >>= fun is_unsigned =>
                                      returnm (((orb (Z.ltb (projT1 (word_width_bytes size)) 8)
                                                   (andb (negb is_unsigned)
                                                      ((Z.leb (projT1 (word_width_bytes size)) 8)
                                                       : bool)))
                                       : bool)
                                       : bool)
                                    else
                                      returnm (projT1
                                      (build_ex
                                      false
                                       : {_bool : bool & ArithFact (not (_bool = true))})))
                                   : M (bool))) >>= fun w__18 : bool =>
                               returnm ((w__18
                                : bool)
                                : bool)
                             else
                               returnm (projT1
                               (build_ex
                               false
                                : {_bool : bool & ArithFact (not (_bool = true))})))
                            : M (bool)))
                         : M (bool))
                        (returnm ((eq_vec (subrange_vec_dec v__7 6 0)
                                     (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1)))
                          : bool))) >>= fun w__21 : bool =>
                     (if sumbool_of_bool (w__21) then
                        let imm : mword 12 := subrange_vec_dec v__7 31 20 in
                        let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                        let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                        let imm : mword 12 := subrange_vec_dec v__7 31 20 in
                        let _mappingpatterns_27_ : mword 2 := subrange_vec_dec v__7 13 12 in
                        let _mappingpatterns_26_ : mword 1 := subrange_vec_dec v__7 14 14 in
                        (size_bits_backwards _mappingpatterns_27_) >>= fun size =>
                        (bool_bits_backwards _mappingpatterns_26_) >>= fun is_unsigned =>
                        returnm ((LOAD
                                    ((imm, rs1, rd, is_unsigned, size, false, false)))
                         : ast)
                      else
                        (and_boolM
                           (let _mappingpatterns_28_ : mword 2 := subrange_vec_dec v__7 13 12 in
                           (and_boolM
                              (returnm ((size_bits_backwards_matches _mappingpatterns_28_)
                                : bool))
                              ((if ((size_bits_backwards_matches _mappingpatterns_28_)) then
                                  (size_bits_backwards _mappingpatterns_28_) >>= fun size =>
                                  returnm (((Z.leb (projT1 (word_width_bytes size)) 8)
                                   : bool)
                                   : bool)
                                else
                                  returnm (projT1
                                  (build_ex
                                  false
                                   : {_bool : bool & ArithFact (not (_bool = true))})))
                               : M (bool)))
                            : M (bool))
                           (returnm ((andb
                                        (eq_vec (subrange_vec_dec v__7 14 14)
                                           (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                        (eq_vec (subrange_vec_dec v__7 6 0)
                                           (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1))))
                             : bool))) >>= fun w__24 : bool =>
                        (if sumbool_of_bool (w__24) then
                           let imm7 : bits 7 := subrange_vec_dec v__7 31 25 in
                           let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let imm7 : bits 7 := subrange_vec_dec v__7 31 25 in
                           let imm5 : bits 5 := subrange_vec_dec v__7 11 7 in
                           let _mappingpatterns_28_ : mword 2 := subrange_vec_dec v__7 13 12 in
                           (size_bits_backwards _mappingpatterns_28_) >>= fun size =>
                           returnm ((STORE
                                       ((concat_vec (imm7  : bits 7) (imm5  : bits 5), rs2, rs1, size, false, false)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 14 12)
                                                           (vec_of_bits [B0;B0;B0]
                                                             : mword (14 - 12 + 1)))
                                                        (eq_vec (subrange_vec_dec v__7 6 0)
                                                           (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                             : mword (6 - 0 + 1)))))) then
                           let imm : mword 12 := subrange_vec_dec v__7 31 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           let imm : mword 12 := subrange_vec_dec v__7 31 20 in
                           returnm ((ADDIW
                                       ((imm, rs1, rd)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B0;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let shamt : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((SHIFTW
                                       ((shamt, rs1, rd, RISCV_SLLI)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let shamt : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((SHIFTW
                                       ((shamt, rs1, rd, RISCV_SRLI)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let shamt : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((SHIFTW
                                       ((shamt, rs1, rd, RISCV_SRAI)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B0;B0;B0]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((RTYPEW
                                       ((rs2, rs1, rd, RISCV_ADDW)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B0;B0;B0]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((RTYPEW
                                       ((rs2, rs1, rd, RISCV_SUBW)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B0;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((RTYPEW
                                       ((rs2, rs1, rd, RISCV_SLLW)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((RTYPEW
                                       ((rs2, rs1, rd, RISCV_SRLW)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((RTYPEW
                                       ((rs2, rs1, rd, RISCV_SRAW)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B0;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let shamt : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((SHIFTIWOP
                                       ((shamt, rs1, rd, RISCV_SLLIW)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let shamt : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((SHIFTIWOP
                                       ((shamt, rs1, rd, RISCV_SRLIW)))
                            : ast)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__7 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__7 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__7 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           let shamt : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                           returnm ((SHIFTIWOP
                                       ((shamt, rs1, rd, RISCV_SRAIW)))
                            : ast)
                         else if ((andb
                                     (eq_vec (subrange_vec_dec v__7 31 28)
                                        (vec_of_bits [B0;B0;B0;B0]  : mword (31 - 28 + 1)))
                                     (eq_vec (subrange_vec_dec v__7 19 0)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                                          : mword (19 - 0 + 1))))) then
                           let succ : mword 4 := subrange_vec_dec v__7 23 20 in
                           let pred : mword 4 := subrange_vec_dec v__7 27 24 in
                           returnm ((FENCE
                                       ((pred, succ)))
                            : ast)
                         else if ((andb
                                     (eq_vec (subrange_vec_dec v__7 31 28)
                                        (vec_of_bits [B1;B0;B0;B0]  : mword (31 - 28 + 1)))
                                     (eq_vec (subrange_vec_dec v__7 19 0)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                                          : mword (19 - 0 + 1))))) then
                           let succ : mword 4 := subrange_vec_dec v__7 23 20 in
                           let pred : mword 4 := subrange_vec_dec v__7 27 24 in
                           returnm ((FENCE_TSO
                                       ((pred, succ)))
                            : ast)
                         else if ((eq_vec v__7
                                     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;
                                                   B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                                       : mword 32))) then
                           returnm ((FENCEI
                                       (tt))
                            : ast )
                         else if ((eq_vec v__7
                                     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm ((ECALL
                                       (tt))
                            : ast )
                         else if ((eq_vec v__7
                                     (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm ((MRET
                                       (tt))
                            : ast )
                         else if ((eq_vec v__7
                                     (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm ((SRET
                                       (tt))
                            : ast )
                         else if ((eq_vec v__7
                                     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm ((EBREAK
                                       (tt))
                            : ast )
                         else if ((eq_vec v__7
                                     (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm ((WFI
                                       (tt))
                            : ast )
                         else if ((andb
                                     (eq_vec (subrange_vec_dec v__7 31 25)
                                        (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  : mword (31 - 25 + 1)))
                                     (eq_vec (subrange_vec_dec v__7 14 0)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                          : mword (14 - 0 + 1))))) then
                           let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                           let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                           returnm ((SFENCE_VMA
                                       ((rs1, rs2)))
                            : ast)
                         else
                           (and_boolM
                              (let _mappingpatterns_31_ : mword 2 := subrange_vec_dec v__7 13 12 in
                              let _mappingpatterns_30_ : mword 1 := subrange_vec_dec v__7 25 25 in
                              let _mappingpatterns_29_ : mword 1 := subrange_vec_dec v__7 26 26 in
                              (and_boolM
                                 (returnm ((size_bits_backwards_matches _mappingpatterns_31_)
                                   : bool))
                                 ((if ((size_bits_backwards_matches _mappingpatterns_31_)) then
                                     (size_bits_backwards _mappingpatterns_31_) >>= fun size =>
                                     (and_boolM
                                        (returnm ((bool_bits_backwards_matches _mappingpatterns_30_)
                                          : bool))
                                        ((if ((bool_bits_backwards_matches _mappingpatterns_30_))
                                          then
                                            (bool_bits_backwards _mappingpatterns_30_) >>= fun rl =>
                                            (and_boolM
                                               (returnm ((bool_bits_backwards_matches
                                                            _mappingpatterns_29_)
                                                 : bool))
                                               ((if ((bool_bits_backwards_matches
                                                        _mappingpatterns_29_)) then
                                                   (bool_bits_backwards _mappingpatterns_29_) >>= fun aq =>
                                                   returnm (((Z.leb (projT1 (word_width_bytes size))
                                                                8)
                                                    : bool)
                                                    : bool)
                                                 else
                                                   returnm (projT1
                                                   (build_ex
                                                   false
                                                    : {_bool : bool & ArithFact (not (_bool = true))})))
                                                : M (bool))) >>= fun w__26 : bool =>
                                            returnm ((w__26
                                             : bool)
                                             : bool)
                                          else
                                            returnm (projT1
                                            (build_ex
                                            false
                                             : {_bool : bool & ArithFact (not (_bool = true))})))
                                         : M (bool))) >>= fun w__28 : bool =>
                                     returnm ((w__28
                                      : bool)
                                      : bool)
                                   else
                                     returnm (projT1
                                     (build_ex
                                     false
                                      : {_bool : bool & ArithFact (not (_bool = true))})))
                                  : M (bool)))
                               : M (bool))
                              (returnm ((andb
                                           (eq_vec (subrange_vec_dec v__7 31 27)
                                              (vec_of_bits [B0;B0;B0;B1;B0]  : mword (31 - 27 + 1)))
                                           (andb
                                              (eq_vec (subrange_vec_dec v__7 24 20)
                                                 (vec_of_bits [B0;B0;B0;B0;B0]
                                                   : mword (24 - 20 + 1)))
                                              (andb
                                                 (eq_vec (subrange_vec_dec v__7 14 14)
                                                    (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                                 (eq_vec (subrange_vec_dec v__7 6 0)
                                                    (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]
                                                      : mword (6 - 0 + 1))))))
                                : bool))) >>= fun w__31 : bool =>
                           (if sumbool_of_bool (w__31) then
                              let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                              let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                              let _mappingpatterns_31_ : mword 2 := subrange_vec_dec v__7 13 12 in
                              let _mappingpatterns_30_ : mword 1 := subrange_vec_dec v__7 25 25 in
                              let _mappingpatterns_29_ : mword 1 := subrange_vec_dec v__7 26 26 in
                              (size_bits_backwards _mappingpatterns_31_) >>= fun size =>
                              (bool_bits_backwards _mappingpatterns_30_) >>= fun rl =>
                              (bool_bits_backwards _mappingpatterns_29_) >>= fun aq =>
                              returnm ((LOADRES
                                          ((aq, rl, rs1, size, rd)))
                               : ast)
                            else
                              (and_boolM
                                 (let _mappingpatterns_34_ : mword 2 := subrange_vec_dec v__7 13 12 in
                                 let _mappingpatterns_33_ : mword 1 := subrange_vec_dec v__7 25 25 in
                                 let _mappingpatterns_32_ : mword 1 := subrange_vec_dec v__7 26 26 in
                                 (and_boolM
                                    (returnm ((size_bits_backwards_matches _mappingpatterns_34_)
                                      : bool))
                                    ((if ((size_bits_backwards_matches _mappingpatterns_34_)) then
                                        (size_bits_backwards _mappingpatterns_34_) >>= fun size =>
                                        (and_boolM
                                           (returnm ((bool_bits_backwards_matches
                                                        _mappingpatterns_33_)
                                             : bool))
                                           ((if ((bool_bits_backwards_matches _mappingpatterns_33_))
                                             then
                                               (bool_bits_backwards _mappingpatterns_33_) >>= fun rl =>
                                               (and_boolM
                                                  (returnm ((bool_bits_backwards_matches
                                                               _mappingpatterns_32_)
                                                    : bool))
                                                  ((if ((bool_bits_backwards_matches
                                                           _mappingpatterns_32_)) then
                                                      (bool_bits_backwards _mappingpatterns_32_) >>= fun aq =>
                                                      returnm (((Z.leb
                                                                   (projT1
                                                                    (word_width_bytes size)) 8)
                                                       : bool)
                                                       : bool)
                                                    else
                                                      returnm (projT1
                                                      (build_ex
                                                      false
                                                       : {_bool : bool & ArithFact (not (_bool =
                                                        true))})))
                                                   : M (bool))) >>= fun w__33 : bool =>
                                               returnm ((w__33
                                                : bool)
                                                : bool)
                                             else
                                               returnm (projT1
                                               (build_ex
                                               false
                                                : {_bool : bool & ArithFact (not (_bool = true))})))
                                            : M (bool))) >>= fun w__35 : bool =>
                                        returnm ((w__35
                                         : bool)
                                         : bool)
                                      else
                                        returnm (projT1
                                        (build_ex
                                        false
                                         : {_bool : bool & ArithFact (not (_bool = true))})))
                                     : M (bool)))
                                  : M (bool))
                                 (returnm ((andb
                                              (eq_vec (subrange_vec_dec v__7 31 27)
                                                 (vec_of_bits [B0;B0;B0;B1;B1]
                                                   : mword (31 - 27 + 1)))
                                              (andb
                                                 (eq_vec (subrange_vec_dec v__7 14 14)
                                                    (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                                 (eq_vec (subrange_vec_dec v__7 6 0)
                                                    (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]
                                                      : mword (6 - 0 + 1)))))
                                   : bool))) >>= fun w__38 : bool =>
                              (if sumbool_of_bool (w__38) then
                                 let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                 let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                 let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                 let _mappingpatterns_34_ : mword 2 := subrange_vec_dec v__7 13 12 in
                                 let _mappingpatterns_33_ : mword 1 := subrange_vec_dec v__7 25 25 in
                                 let _mappingpatterns_32_ : mword 1 := subrange_vec_dec v__7 26 26 in
                                 (size_bits_backwards _mappingpatterns_34_) >>= fun size =>
                                 (bool_bits_backwards _mappingpatterns_33_) >>= fun rl =>
                                 (bool_bits_backwards _mappingpatterns_32_) >>= fun aq =>
                                 returnm ((STORECON
                                             ((aq, rl, rs2, rs1, size, rd)))
                                  : ast)
                               else
                                 (and_boolM
                                    (let _mappingpatterns_35_ : mword 5 :=
                                      subrange_vec_dec v__7 31 27 in
                                    let _mappingpatterns_38_ : mword 2 :=
                                      subrange_vec_dec v__7 13 12 in
                                    let _mappingpatterns_37_ : mword 1 :=
                                      subrange_vec_dec v__7 25 25 in
                                    let _mappingpatterns_36_ : mword 1 :=
                                      subrange_vec_dec v__7 26 26 in
                                    let _mappingpatterns_35_ : mword 5 :=
                                      subrange_vec_dec v__7 31 27 in
                                    (and_boolM
                                       (returnm ((size_bits_backwards_matches _mappingpatterns_38_)
                                         : bool))
                                       ((if ((size_bits_backwards_matches _mappingpatterns_38_))
                                         then
                                           (size_bits_backwards _mappingpatterns_38_) >>= fun size =>
                                           (and_boolM
                                              (returnm ((bool_bits_backwards_matches
                                                           _mappingpatterns_37_)
                                                : bool))
                                              ((if ((bool_bits_backwards_matches
                                                       _mappingpatterns_37_)) then
                                                  (bool_bits_backwards _mappingpatterns_37_) >>= fun rl =>
                                                  (and_boolM
                                                     (returnm ((bool_bits_backwards_matches
                                                                  _mappingpatterns_36_)
                                                       : bool))
                                                     ((if ((bool_bits_backwards_matches
                                                              _mappingpatterns_36_)) then
                                                         (bool_bits_backwards _mappingpatterns_36_) >>= fun aq =>
                                                         (and_boolM
                                                            (returnm ((encdec_amoop_backwards_matches
                                                                         _mappingpatterns_35_)
                                                              : bool))
                                                            ((if ((encdec_amoop_backwards_matches
                                                                     _mappingpatterns_35_)) then
                                                                (encdec_amoop_backwards
                                                                   _mappingpatterns_35_) >>= fun op =>
                                                                returnm (((Z.leb
                                                                             (projT1
                                                                              (word_width_bytes size))
                                                                             8)
                                                                 : bool)
                                                                 : bool)
                                                              else
                                                                returnm (projT1
                                                                (build_ex
                                                                false
                                                                 : {_bool : bool & ArithFact (not (_bool =
                                                                  true))})))
                                                             : M (bool))) >>= fun w__40 : bool =>
                                                         returnm ((w__40
                                                          : bool)
                                                          : bool)
                                                       else
                                                         returnm (projT1
                                                         (build_ex
                                                         false
                                                          : {_bool : bool & ArithFact (not (_bool =
                                                           true))})))
                                                      : M (bool))) >>= fun w__42 : bool =>
                                                  returnm ((w__42
                                                   : bool)
                                                   : bool)
                                                else
                                                  returnm (projT1
                                                  (build_ex
                                                  false
                                                   : {_bool : bool & ArithFact (not (_bool = true))})))
                                               : M (bool))) >>= fun w__44 : bool =>
                                           returnm ((w__44
                                            : bool)
                                            : bool)
                                         else
                                           returnm (projT1
                                           (build_ex
                                           false
                                            : {_bool : bool & ArithFact (not (_bool = true))})))
                                        : M (bool)))
                                     : M (bool))
                                    (returnm ((andb
                                                 (eq_vec (subrange_vec_dec v__7 14 14)
                                                    (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                                 (eq_vec (subrange_vec_dec v__7 6 0)
                                                    (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]
                                                      : mword (6 - 0 + 1))))
                                      : bool))) >>= fun w__47 : bool =>
                                 (if sumbool_of_bool (w__47) then
                                    let _mappingpatterns_35_ : mword 5 :=
                                      subrange_vec_dec v__7 31 27 in
                                    let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                    let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                    let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                    let _mappingpatterns_38_ : mword 2 :=
                                      subrange_vec_dec v__7 13 12 in
                                    let _mappingpatterns_37_ : mword 1 :=
                                      subrange_vec_dec v__7 25 25 in
                                    let _mappingpatterns_36_ : mword 1 :=
                                      subrange_vec_dec v__7 26 26 in
                                    let _mappingpatterns_35_ : mword 5 :=
                                      subrange_vec_dec v__7 31 27 in
                                    (size_bits_backwards _mappingpatterns_38_) >>= fun size =>
                                    (bool_bits_backwards _mappingpatterns_37_) >>= fun rl =>
                                    (bool_bits_backwards _mappingpatterns_36_) >>= fun aq =>
                                    (encdec_amoop_backwards _mappingpatterns_35_) >>= fun op =>
                                    returnm ((AMO
                                                ((op, aq, rl, rs2, rs1, size, rd)))
                                     : ast)
                                  else
                                    (and_boolM
                                       (let _mappingpatterns_39_ : mword 3 :=
                                         subrange_vec_dec v__7 14 12 in
                                       (and_boolM
                                          (returnm ((encdec_mul_op_backwards_matches
                                                       _mappingpatterns_39_)
                                            : bool))
                                          ((if ((encdec_mul_op_backwards_matches
                                                   _mappingpatterns_39_)) then
                                              (encdec_mul_op_backwards _mappingpatterns_39_) >>= fun '(high, signed1, signed2) =>
                                              returnm ((true
                                               : bool)
                                               : bool)
                                            else
                                              returnm (projT1
                                              (build_ex
                                              false
                                               : {_bool : bool & ArithFact (not (_bool = true))})))
                                           : M (bool)))
                                        : M (bool))
                                       (returnm ((andb
                                                    (eq_vec (subrange_vec_dec v__7 31 25)
                                                       (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                         : mword (31 - 25 + 1)))
                                                    (eq_vec (subrange_vec_dec v__7 6 0)
                                                       (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]
                                                         : mword (6 - 0 + 1))))
                                         : bool))) >>= fun w__50 : bool =>
                                    (if sumbool_of_bool (w__50) then
                                       let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                       let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                       let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                       let _mappingpatterns_39_ : mword 3 :=
                                         subrange_vec_dec v__7 14 12 in
                                       (encdec_mul_op_backwards _mappingpatterns_39_) >>= fun '(high, signed1, signed2) =>
                                       returnm ((MUL
                                                   ((rs2, rs1, rd, high, signed1, signed2)))
                                        : ast)
                                     else
                                       (and_boolM
                                          (let _mappingpatterns_40_ : mword 1 :=
                                            subrange_vec_dec v__7 12 12 in
                                          (and_boolM
                                             (returnm ((bool_not_bits_backwards_matches
                                                          _mappingpatterns_40_)
                                               : bool))
                                             ((if ((bool_not_bits_backwards_matches
                                                      _mappingpatterns_40_)) then
                                                 (bool_not_bits_backwards _mappingpatterns_40_) >>= fun s =>
                                                 returnm ((true
                                                  : bool)
                                                  : bool)
                                               else
                                                 returnm (projT1
                                                 (build_ex
                                                 false
                                                  : {_bool : bool & ArithFact (not (_bool = true))})))
                                              : M (bool)))
                                           : M (bool))
                                          (returnm ((andb
                                                       (eq_vec (subrange_vec_dec v__7 31 25)
                                                          (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                            : mword (31 - 25 + 1)))
                                                       (andb
                                                          (eq_vec (subrange_vec_dec v__7 14 13)
                                                             (vec_of_bits [B1;B0]
                                                               : mword (14 - 13 + 1)))
                                                          (eq_vec (subrange_vec_dec v__7 6 0)
                                                             (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]
                                                               : mword (6 - 0 + 1)))))
                                            : bool))) >>= fun w__53 : bool =>
                                       (if sumbool_of_bool (w__53) then
                                          let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                          let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                          let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                          let _mappingpatterns_40_ : mword 1 :=
                                            subrange_vec_dec v__7 12 12 in
                                          (bool_not_bits_backwards _mappingpatterns_40_) >>= fun s =>
                                          returnm ((DIV
                                                      ((rs2, rs1, rd, s)))
                                           : ast)
                                        else
                                          (and_boolM
                                             (let _mappingpatterns_41_ : mword 1 :=
                                               subrange_vec_dec v__7 12 12 in
                                             (and_boolM
                                                (returnm ((bool_not_bits_backwards_matches
                                                             _mappingpatterns_41_)
                                                  : bool))
                                                ((if ((bool_not_bits_backwards_matches
                                                         _mappingpatterns_41_)) then
                                                    (bool_not_bits_backwards _mappingpatterns_41_) >>= fun s =>
                                                    returnm ((true
                                                     : bool)
                                                     : bool)
                                                  else
                                                    returnm (projT1
                                                    (build_ex
                                                    false
                                                     : {_bool : bool & ArithFact (not (_bool = true))})))
                                                 : M (bool)))
                                              : M (bool))
                                             (returnm ((andb
                                                          (eq_vec (subrange_vec_dec v__7 31 25)
                                                             (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                               : mword (31 - 25 + 1)))
                                                          (andb
                                                             (eq_vec (subrange_vec_dec v__7 14 13)
                                                                (vec_of_bits [B1;B1]
                                                                  : mword (14 - 13 + 1)))
                                                             (eq_vec (subrange_vec_dec v__7 6 0)
                                                                (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]
                                                                  : mword (6 - 0 + 1)))))
                                               : bool))) >>= fun w__56 : bool =>
                                          (if sumbool_of_bool (w__56) then
                                             let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                             let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                             let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                             let _mappingpatterns_41_ : mword 1 :=
                                               subrange_vec_dec v__7 12 12 in
                                             (bool_not_bits_backwards _mappingpatterns_41_) >>= fun s =>
                                             returnm ((REM
                                                         ((rs2, rs1, rd, s)))
                                              : ast)
                                           else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                                       (andb
                                                                          (eq_vec
                                                                             (subrange_vec_dec v__7
                                                                                31 25)
                                                                             (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                                               : mword (31 - 25 + 1)))
                                                                          (andb
                                                                             (eq_vec
                                                                                (subrange_vec_dec
                                                                                   v__7 14 12)
                                                                                (vec_of_bits [B0;B0;B0]
                                                                                  : mword (14 - 12 + 1)))
                                                                             (eq_vec
                                                                                (subrange_vec_dec
                                                                                   v__7 6 0)
                                                                                (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                                  : mword (6 - 0 + 1)))))))
                                           then
                                             let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                             let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                             let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                             returnm ((MULW
                                                         ((rs2, rs1, rd)))
                                              : ast)
                                           else
                                             (and_boolM
                                                (let _mappingpatterns_42_ : mword 1 :=
                                                  subrange_vec_dec v__7 12 12 in
                                                (and_boolM
                                                   (returnm ((bool_not_bits_backwards_matches
                                                                _mappingpatterns_42_)
                                                     : bool))
                                                   ((if ((bool_not_bits_backwards_matches
                                                            _mappingpatterns_42_)) then
                                                       (bool_not_bits_backwards _mappingpatterns_42_) >>= fun s =>
                                                       returnm (((Z.eqb 64 64)
                                                        : bool)
                                                        : bool)
                                                     else
                                                       returnm (projT1
                                                       (build_ex
                                                       false
                                                        : {_bool : bool & ArithFact (not (_bool =
                                                         true))})))
                                                    : M (bool)))
                                                 : M (bool))
                                                (returnm ((andb
                                                             (eq_vec (subrange_vec_dec v__7 31 25)
                                                                (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                                  : mword (31 - 25 + 1)))
                                                             (andb
                                                                (eq_vec
                                                                   (subrange_vec_dec v__7 14 13)
                                                                   (vec_of_bits [B1;B0]
                                                                     : mword (14 - 13 + 1)))
                                                                (eq_vec (subrange_vec_dec v__7 6 0)
                                                                   (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                     : mword (6 - 0 + 1)))))
                                                  : bool))) >>= fun w__59 : bool =>
                                             (if sumbool_of_bool (w__59) then
                                                let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                                let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                                let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                                let _mappingpatterns_42_ : mword 1 :=
                                                  subrange_vec_dec v__7 12 12 in
                                                (bool_not_bits_backwards _mappingpatterns_42_) >>= fun s =>
                                                returnm ((DIVW
                                                            ((rs2, rs1, rd, s)))
                                                 : ast)
                                              else
                                                (and_boolM
                                                   (let _mappingpatterns_43_ : mword 1 :=
                                                     subrange_vec_dec v__7 12 12 in
                                                   (and_boolM
                                                      (returnm ((bool_not_bits_backwards_matches
                                                                   _mappingpatterns_43_)
                                                        : bool))
                                                      ((if ((bool_not_bits_backwards_matches
                                                               _mappingpatterns_43_)) then
                                                          (bool_not_bits_backwards
                                                             _mappingpatterns_43_) >>= fun s =>
                                                          returnm (((Z.eqb 64 64)
                                                           : bool)
                                                           : bool)
                                                        else
                                                          returnm (projT1
                                                          (build_ex
                                                          false
                                                           : {_bool : bool & ArithFact (not (_bool =
                                                            true))})))
                                                       : M (bool)))
                                                    : M (bool))
                                                   (returnm ((andb
                                                                (eq_vec
                                                                   (subrange_vec_dec v__7 31 25)
                                                                   (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                                     : mword (31 - 25 + 1)))
                                                                (andb
                                                                   (eq_vec
                                                                      (subrange_vec_dec v__7 14 13)
                                                                      (vec_of_bits [B1;B1]
                                                                        : mword (14 - 13 + 1)))
                                                                   (eq_vec
                                                                      (subrange_vec_dec v__7 6 0)
                                                                      (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                        : mword (6 - 0 + 1)))))
                                                     : bool))) >>= fun w__62 : bool =>
                                                (if sumbool_of_bool (w__62) then
                                                   let rs2 : mword 5 := subrange_vec_dec v__7 24 20 in
                                                   let rs1 : mword 5 := subrange_vec_dec v__7 19 15 in
                                                   let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                                   let _mappingpatterns_43_ : mword 1 :=
                                                     subrange_vec_dec v__7 12 12 in
                                                   (bool_not_bits_backwards _mappingpatterns_43_) >>= fun s =>
                                                   returnm ((REMW
                                                               ((rs2, rs1, rd, s)))
                                                    : ast)
                                                 else
                                                   (and_boolM
                                                      (let _mappingpatterns_45_ : mword 2 :=
                                                        subrange_vec_dec v__7 13 12 in
                                                      let _mappingpatterns_44_ : mword 1 :=
                                                        subrange_vec_dec v__7 14 14 in
                                                      (and_boolM
                                                         (returnm ((encdec_csrop_backwards_matches
                                                                      _mappingpatterns_45_)
                                                           : bool))
                                                         ((if ((encdec_csrop_backwards_matches
                                                                  _mappingpatterns_45_)) then
                                                             (encdec_csrop_backwards
                                                                _mappingpatterns_45_) >>= fun op =>
                                                             (and_boolM
                                                                (returnm ((bool_bits_backwards_matches
                                                                             _mappingpatterns_44_)
                                                                  : bool))
                                                                ((if ((bool_bits_backwards_matches
                                                                         _mappingpatterns_44_)) then
                                                                    (bool_bits_backwards
                                                                       _mappingpatterns_44_) >>= fun is_imm =>
                                                                    returnm ((true
                                                                     : bool)
                                                                     : bool)
                                                                  else
                                                                    returnm (projT1
                                                                    (build_ex
                                                                    false
                                                                     : {_bool : bool & ArithFact (not (_bool =
                                                                      true))})))
                                                                 : M (bool))) >>= fun w__64 : bool =>
                                                             returnm ((w__64
                                                              : bool)
                                                              : bool)
                                                           else
                                                             returnm (projT1
                                                             (build_ex
                                                             false
                                                              : {_bool : bool & ArithFact (not (_bool =
                                                               true))})))
                                                          : M (bool)))
                                                       : M (bool))
                                                      (returnm ((eq_vec (subrange_vec_dec v__7 6 0)
                                                                   (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]
                                                                     : mword (6 - 0 + 1)))
                                                        : bool))) >>= fun w__67 : bool =>
                                                   (if sumbool_of_bool (w__67) then
                                                      let csr : mword 12 :=
                                                        subrange_vec_dec v__7 31 20 in
                                                      let rs1 : mword 5 :=
                                                        subrange_vec_dec v__7 19 15 in
                                                      let rd : mword 5 := subrange_vec_dec v__7 11 7 in
                                                      let csr : mword 12 :=
                                                        subrange_vec_dec v__7 31 20 in
                                                      let _mappingpatterns_45_ : mword 2 :=
                                                        subrange_vec_dec v__7 13 12 in
                                                      let _mappingpatterns_44_ : mword 1 :=
                                                        subrange_vec_dec v__7 14 14 in
                                                      (encdec_csrop_backwards _mappingpatterns_45_) >>= fun op =>
                                                      (bool_bits_backwards _mappingpatterns_44_) >>= fun is_imm =>
                                                      returnm ((CSR
                                                                  ((csr, rs1, rd, is_imm, op)))
                                                       : ast)
                                                    else
                                                      returnm ((if ((eq_vec v__7
                                                                       (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                                                     B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                                                         : mword 32))) then
                                                                  URET
                                                                    (tt)
                                                                else ILLEGAL (v__7))
                                                       : ast))
                                                    : M (ast))
                                                 : M (ast))
                                              : M (ast))
                                           : M (ast))
                                        : M (ast))
                                     : M (ast))
                                  : M (ast))
                               : M (ast))
                            : M (ast))
                         : M (ast))
                      : M (ast))
                   : M (ast))
                : M (ast))
             : M (ast))
          : M (ast))
       : M (ast))
    : M (ast).

Definition encdec_forwards_matches (arg_ : ast) 
: bool :=
   
   match arg_ with
   | UTYPE ((imm, rd, op)) => true
   | RISCV_JAL ((v__220, rd)) =>
      if ((eq_vec (subrange_vec_dec v__220 0 0) (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then true
      else false
   | RISCV_JALR ((imm, rs1, rd)) => true
   | BTYPE ((v__222, rs2, rs1, op)) =>
      if ((eq_vec (subrange_vec_dec v__222 0 0) (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then true
      else false
   | ITYPE ((imm, rs1, rd, op)) => true
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SLLI)) => true
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SRLI)) => true
   | SHIFTIOP ((shamt, rs1, rd, RISCV_SRAI)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_ADD)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_SLT)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_SLTU)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_AND)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_OR)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_XOR)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_SLL)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_SRL)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_SUB)) => true
   | RTYPE ((rs2, rs1, rd, RISCV_SRA)) => true
   | LOAD ((imm, rs1, rd, is_unsigned, size, false, false)) =>
      if sumbool_of_bool ((orb (Z.ltb (projT1 (word_width_bytes size)) 8)
                             (andb (negb is_unsigned)
                                ((Z.leb (projT1 (word_width_bytes size)) 8)
                                 : bool)))) then
        true
      else false
   | STORE ((v__224, rs2, rs1, size, false, false)) =>
      if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then true else false
   | ADDIW ((imm, rs1, rd)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTW ((shamt, rs1, rd, RISCV_SLLI)) =>
      if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTW ((shamt, rs1, rd, RISCV_SRLI)) =>
      if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTW ((shamt, rs1, rd, RISCV_SRAI)) =>
      if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | RTYPEW ((rs2, rs1, rd, RISCV_ADDW)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | RTYPEW ((rs2, rs1, rd, RISCV_SUBW)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | RTYPEW ((rs2, rs1, rd, RISCV_SLLW)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | RTYPEW ((rs2, rs1, rd, RISCV_SRLW)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | RTYPEW ((rs2, rs1, rd, RISCV_SRAW)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SLLIW)) =>
      if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRLIW)) =>
      if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTIWOP ((shamt, rs1, rd, RISCV_SRAIW)) =>
      if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | FENCE ((pred, succ)) => true
   | FENCE_TSO ((pred, succ)) => true
   | FENCEI (tt) => true
   | ECALL (tt) => true
   | MRET (tt) => true
   | SRET (tt) => true
   | EBREAK (tt) => true
   | WFI (tt) => true
   | SFENCE_VMA ((rs1, rs2)) => true
   | LOADRES ((aq, rl, rs1, size, rd)) =>
      if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then true else false
   | STORECON ((aq, rl, rs2, rs1, size, rd)) =>
      if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then true else false
   | AMO ((op, aq, rl, rs2, rs1, size, rd)) =>
      if sumbool_of_bool ((Z.leb (projT1 (word_width_bytes size)) 8)) then true else false
   | MUL ((rs2, rs1, rd, high, signed1, signed2)) => true
   | DIV ((rs2, rs1, rd, s)) => true
   | REM ((rs2, rs1, rd, s)) => true
   | MULW ((rs2, rs1, rd)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | DIVW ((rs2, rs1, rd, s)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | REMW ((rs2, rs1, rd, s)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | CSR ((csr, rs1, rd, is_imm, op)) => true
   | URET (tt) => true
   | ILLEGAL (s) => true
   | _ => false
   end.

Definition encdec_backwards_matches (arg_ : mword 32) 
: M (bool) :=
   
   let v__225 := arg_ in
   let _mappingpatterns_0_ : mword 7 := subrange_vec_dec v__225 6 0 in
   (and_boolM (returnm ((encdec_uop_backwards_matches _mappingpatterns_0_)  : bool))
      ((if ((encdec_uop_backwards_matches _mappingpatterns_0_)) then
          (encdec_uop_backwards _mappingpatterns_0_) >>= fun op => returnm ((true  : bool)  : bool)
        else returnm (projT1 (build_ex false  : {_bool : bool & ArithFact (not (_bool = true))})))
       : M (bool))) >>= fun w__1 : bool =>
   (if sumbool_of_bool (w__1) then
      let _mappingpatterns_0_ : mword 7 := subrange_vec_dec v__225 6 0 in
      (encdec_uop_backwards _mappingpatterns_0_) >>= fun op => returnm (true  : bool)
    else if ((eq_vec (subrange_vec_dec v__225 6 0)
                (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  : mword (6 - 0 + 1)))) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else if ((andb
                (eq_vec (subrange_vec_dec v__225 14 12)
                   (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__225 6 0)
                   (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  : mword (6 - 0 + 1))))) then
      returnm (projT1
      (build_ex
      true
       : {_bool : bool & ArithFact (_bool = true)}))
    else
      (and_boolM
         (let _mappingpatterns_1_ : mword 3 := subrange_vec_dec v__225 14 12 in
         (and_boolM (returnm ((encdec_bop_backwards_matches _mappingpatterns_1_)  : bool))
            ((if ((encdec_bop_backwards_matches _mappingpatterns_1_)) then
                (encdec_bop_backwards _mappingpatterns_1_) >>= fun op =>
                returnm ((true
                 : bool)
                 : bool)
              else
                returnm (projT1
                (build_ex
                false
                 : {_bool : bool & ArithFact (not (_bool = true))})))
             : M (bool)))
          : M (bool))
         (returnm ((eq_vec (subrange_vec_dec v__225 6 0)
                      (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1)))
           : bool))) >>= fun w__4 : bool =>
      (if sumbool_of_bool (w__4) then
         let _mappingpatterns_1_ : mword 3 := subrange_vec_dec v__225 14 12 in
         (encdec_bop_backwards _mappingpatterns_1_) >>= fun op => returnm (true  : bool)
       else
         (and_boolM
            (let _mappingpatterns_2_ : mword 3 := subrange_vec_dec v__225 14 12 in
            (and_boolM (returnm ((encdec_iop_backwards_matches _mappingpatterns_2_)  : bool))
               ((if ((encdec_iop_backwards_matches _mappingpatterns_2_)) then
                   (encdec_iop_backwards _mappingpatterns_2_) >>= fun op =>
                   returnm ((true
                    : bool)
                    : bool)
                 else
                   returnm (projT1
                   (build_ex
                   false
                    : {_bool : bool & ArithFact (not (_bool = true))})))
                : M (bool)))
             : M (bool))
            (returnm ((eq_vec (subrange_vec_dec v__225 6 0)
                         (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))
              : bool))) >>= fun w__7 : bool =>
         (if sumbool_of_bool (w__7) then
            let _mappingpatterns_2_ : mword 3 := subrange_vec_dec v__225 14 12 in
            (encdec_iop_backwards _mappingpatterns_2_) >>= fun op => returnm (true  : bool)
          else
            (and_boolMP
               ((let shamt : mword 6 := subrange_vec_dec v__225 25 20 in
               (or_boolMP
                  ((returnm (build_ex
                    (projT1
                    (build_ex
                    (Z.eqb 64 64)
                     : {_bool : bool & ArithFact (iff (_bool = true) (64 = 64))})))) : M ({_bool : bool & ArithFact (iff (_bool =
                    true) (64 = 64))}))
                  (build_trivial_ex
                  ((bit_to_bool (access_vec_dec shamt 5)) >>= fun w__8 : bool =>
                   returnm ((Bool.eqb w__8 false)
                    : bool))) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 =
                 64 \/
                 simp_0 = true))}))
                : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 = 64 \/
                 simp_0 = true))})) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                 true) (64 = 64 \/ simp_0 = true))}))
               (build_trivial_ex
               (returnm ((andb
                            (eq_vec (subrange_vec_dec v__225 31 26)
                               (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
                            (andb
                               (eq_vec (subrange_vec_dec v__225 14 12)
                                  (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                               (eq_vec (subrange_vec_dec v__225 6 0)
                                  (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))
                 : bool))) : M ({_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool = true) (simp_0 =
              true /\
              (64 = 64 \/ simp_1 = true)))})) >>= fun '(existT _ w__10 _ : {_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
              true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))}) =>
            (if sumbool_of_bool (w__10) then
               returnm (projT1
               (build_ex
               true
                : {_bool : bool & ArithFact (_bool = true)}))
             else
               (and_boolMP
                  ((let shamt : mword 6 := subrange_vec_dec v__225 25 20 in
                  (or_boolMP
                     ((returnm (build_ex
                       (projT1
                       (build_ex
                       (Z.eqb 64 64)
                        : {_bool : bool & ArithFact (iff (_bool = true) (64 = 64))})))) : M ({_bool : bool & ArithFact (iff (_bool =
                       true) (64 = 64))}))
                     (build_trivial_ex
                     ((bit_to_bool (access_vec_dec shamt 5)) >>= fun w__11 : bool =>
                      returnm ((Bool.eqb w__11 false)
                       : bool))) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 =
                    64 \/
                    simp_0 = true))}))
                   : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 = 64 \/
                    simp_0 = true))})) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                    true) (64 = 64 \/ simp_0 = true))}))
                  (build_trivial_ex
                  (returnm ((andb
                               (eq_vec (subrange_vec_dec v__225 31 26)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))
                    : bool))) : M ({_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                 true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))})) >>= fun '(existT _ w__13 _ : {_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                 true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))}) =>
               (if sumbool_of_bool (w__13) then
                  returnm (projT1
                  (build_ex
                  true
                   : {_bool : bool & ArithFact (_bool = true)}))
                else
                  (and_boolMP
                     ((let shamt : mword 6 := subrange_vec_dec v__225 25 20 in
                     (or_boolMP
                        ((returnm (build_ex
                          (projT1
                          (build_ex
                          (Z.eqb 64 64)
                           : {_bool : bool & ArithFact (iff (_bool = true) (64 = 64))})))) : M ({_bool : bool & ArithFact (iff (_bool =
                          true) (64 = 64))}))
                        (build_trivial_ex
                        ((bit_to_bool (access_vec_dec shamt 5)) >>= fun w__14 : bool =>
                         returnm ((Bool.eqb w__14 false)
                          : bool))) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                       true) (64 = 64 \/ simp_0 = true))}))
                      : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool = true) (64 = 64 \/
                       simp_0 = true))})) : M ({_bool : bool & ArithFact (exists simp_0 , iff (_bool =
                       true) (64 = 64 \/ simp_0 = true))}))
                     (build_trivial_ex
                     (returnm ((andb
                                  (eq_vec (subrange_vec_dec v__225 31 26)
                                     (vec_of_bits [B0;B1;B0;B0;B0;B0]  : mword (31 - 26 + 1)))
                                  (andb
                                     (eq_vec (subrange_vec_dec v__225 14 12)
                                        (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                     (eq_vec (subrange_vec_dec v__225 6 0)
                                        (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1)))))
                       : bool))) : M ({_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                    true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))})) >>= fun '(existT _ w__16 _ : {_bool : bool & ArithFact (exists simp_0 simp_1 , iff (_bool =
                    true) (simp_0 = true /\ (64 = 64 \/ simp_1 = true)))}) =>
                  (if sumbool_of_bool (w__16) then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B0;B1;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B0;B1;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B1;B1;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B1;B1;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B1;B0;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B0;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B0;B0;B0]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else if ((andb
                               (eq_vec (subrange_vec_dec v__225 31 25)
                                  (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  : mword (31 - 25 + 1)))
                               (andb
                                  (eq_vec (subrange_vec_dec v__225 14 12)
                                     (vec_of_bits [B1;B0;B1]  : mword (14 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  : mword (6 - 0 + 1))))))
                   then
                     returnm (projT1
                     (build_ex
                     true
                      : {_bool : bool & ArithFact (_bool = true)}))
                   else
                     (and_boolM
                        (let _mappingpatterns_4_ : mword 2 := subrange_vec_dec v__225 13 12 in
                        let _mappingpatterns_3_ : mword 1 := subrange_vec_dec v__225 14 14 in
                        (and_boolM
                           (returnm ((size_bits_backwards_matches _mappingpatterns_4_)
                             : bool))
                           ((if ((size_bits_backwards_matches _mappingpatterns_4_)) then
                               (size_bits_backwards _mappingpatterns_4_) >>= fun size =>
                               (and_boolM
                                  (returnm ((bool_bits_backwards_matches _mappingpatterns_3_)
                                    : bool))
                                  ((if ((bool_bits_backwards_matches _mappingpatterns_3_)) then
                                      (bool_bits_backwards _mappingpatterns_3_) >>= fun is_unsigned =>
                                      returnm (((orb (Z.ltb (projT1 (word_width_bytes size)) 8)
                                                   (andb (negb is_unsigned)
                                                      ((Z.leb (projT1 (word_width_bytes size)) 8)
                                                       : bool)))
                                       : bool)
                                       : bool)
                                    else
                                      returnm (projT1
                                      (build_ex
                                      false
                                       : {_bool : bool & ArithFact (not (_bool = true))})))
                                   : M (bool))) >>= fun w__18 : bool =>
                               returnm ((w__18
                                : bool)
                                : bool)
                             else
                               returnm (projT1
                               (build_ex
                               false
                                : {_bool : bool & ArithFact (not (_bool = true))})))
                            : M (bool)))
                         : M (bool))
                        (returnm ((eq_vec (subrange_vec_dec v__225 6 0)
                                     (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1)))
                          : bool))) >>= fun w__21 : bool =>
                     (if sumbool_of_bool (w__21) then
                        let _mappingpatterns_4_ : mword 2 := subrange_vec_dec v__225 13 12 in
                        let _mappingpatterns_3_ : mword 1 := subrange_vec_dec v__225 14 14 in
                        (size_bits_backwards _mappingpatterns_4_) >>= fun size =>
                        (bool_bits_backwards _mappingpatterns_3_) >>= fun is_unsigned =>
                        returnm (true
                         : bool)
                      else
                        (and_boolM
                           (let _mappingpatterns_5_ : mword 2 := subrange_vec_dec v__225 13 12 in
                           (and_boolM
                              (returnm ((size_bits_backwards_matches _mappingpatterns_5_)
                                : bool))
                              ((if ((size_bits_backwards_matches _mappingpatterns_5_)) then
                                  (size_bits_backwards _mappingpatterns_5_) >>= fun size =>
                                  returnm (((Z.leb (projT1 (word_width_bytes size)) 8)
                                   : bool)
                                   : bool)
                                else
                                  returnm (projT1
                                  (build_ex
                                  false
                                   : {_bool : bool & ArithFact (not (_bool = true))})))
                               : M (bool)))
                            : M (bool))
                           (returnm ((andb
                                        (eq_vec (subrange_vec_dec v__225 14 14)
                                           (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                        (eq_vec (subrange_vec_dec v__225 6 0)
                                           (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  : mword (6 - 0 + 1))))
                             : bool))) >>= fun w__24 : bool =>
                        (if sumbool_of_bool (w__24) then
                           let _mappingpatterns_5_ : mword 2 := subrange_vec_dec v__225 13 12 in
                           (size_bits_backwards _mappingpatterns_5_) >>= fun size =>
                           returnm (true
                            : bool)
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 14 12)
                                                           (vec_of_bits [B0;B0;B0]
                                                             : mword (14 - 12 + 1)))
                                                        (eq_vec (subrange_vec_dec v__225 6 0)
                                                           (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                             : mword (6 - 0 + 1)))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B0;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B0;B0;B0]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B0;B0;B0]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B0;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B0;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                     (andb
                                                        (eq_vec (subrange_vec_dec v__225 31 25)
                                                           (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]
                                                             : mword (31 - 25 + 1)))
                                                        (andb
                                                           (eq_vec (subrange_vec_dec v__225 14 12)
                                                              (vec_of_bits [B1;B0;B1]
                                                                : mword (14 - 12 + 1)))
                                                           (eq_vec (subrange_vec_dec v__225 6 0)
                                                              (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]
                                                                : mword (6 - 0 + 1))))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((andb
                                     (eq_vec (subrange_vec_dec v__225 31 28)
                                        (vec_of_bits [B0;B0;B0;B0]  : mword (31 - 28 + 1)))
                                     (eq_vec (subrange_vec_dec v__225 19 0)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                                          : mword (19 - 0 + 1))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((andb
                                     (eq_vec (subrange_vec_dec v__225 31 28)
                                        (vec_of_bits [B1;B0;B0;B0]  : mword (31 - 28 + 1)))
                                     (eq_vec (subrange_vec_dec v__225 19 0)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                                          : mword (19 - 0 + 1))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((eq_vec v__225
                                     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;
                                                   B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                                       : mword 32))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((eq_vec v__225
                                     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((eq_vec v__225
                                     (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((eq_vec v__225
                                     (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((eq_vec v__225
                                     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((eq_vec v__225
                                     (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                   B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                       : mword 32))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else if ((andb
                                     (eq_vec (subrange_vec_dec v__225 31 25)
                                        (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  : mword (31 - 25 + 1)))
                                     (eq_vec (subrange_vec_dec v__225 14 0)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                          : mword (14 - 0 + 1))))) then
                           returnm (projT1
                           (build_ex
                           true
                            : {_bool : bool & ArithFact (_bool = true)}))
                         else
                           (and_boolM
                              (let _mappingpatterns_8_ : mword 2 := subrange_vec_dec v__225 13 12 in
                              let _mappingpatterns_7_ : mword 1 := subrange_vec_dec v__225 25 25 in
                              let _mappingpatterns_6_ : mword 1 := subrange_vec_dec v__225 26 26 in
                              (and_boolM
                                 (returnm ((size_bits_backwards_matches _mappingpatterns_8_)
                                   : bool))
                                 ((if ((size_bits_backwards_matches _mappingpatterns_8_)) then
                                     (size_bits_backwards _mappingpatterns_8_) >>= fun size =>
                                     (and_boolM
                                        (returnm ((bool_bits_backwards_matches _mappingpatterns_7_)
                                          : bool))
                                        ((if ((bool_bits_backwards_matches _mappingpatterns_7_))
                                          then
                                            (bool_bits_backwards _mappingpatterns_7_) >>= fun rl =>
                                            (and_boolM
                                               (returnm ((bool_bits_backwards_matches
                                                            _mappingpatterns_6_)
                                                 : bool))
                                               ((if ((bool_bits_backwards_matches
                                                        _mappingpatterns_6_)) then
                                                   (bool_bits_backwards _mappingpatterns_6_) >>= fun aq =>
                                                   returnm (((Z.leb (projT1 (word_width_bytes size))
                                                                8)
                                                    : bool)
                                                    : bool)
                                                 else
                                                   returnm (projT1
                                                   (build_ex
                                                   false
                                                    : {_bool : bool & ArithFact (not (_bool = true))})))
                                                : M (bool))) >>= fun w__26 : bool =>
                                            returnm ((w__26
                                             : bool)
                                             : bool)
                                          else
                                            returnm (projT1
                                            (build_ex
                                            false
                                             : {_bool : bool & ArithFact (not (_bool = true))})))
                                         : M (bool))) >>= fun w__28 : bool =>
                                     returnm ((w__28
                                      : bool)
                                      : bool)
                                   else
                                     returnm (projT1
                                     (build_ex
                                     false
                                      : {_bool : bool & ArithFact (not (_bool = true))})))
                                  : M (bool)))
                               : M (bool))
                              (returnm ((andb
                                           (eq_vec (subrange_vec_dec v__225 31 27)
                                              (vec_of_bits [B0;B0;B0;B1;B0]  : mword (31 - 27 + 1)))
                                           (andb
                                              (eq_vec (subrange_vec_dec v__225 24 20)
                                                 (vec_of_bits [B0;B0;B0;B0;B0]
                                                   : mword (24 - 20 + 1)))
                                              (andb
                                                 (eq_vec (subrange_vec_dec v__225 14 14)
                                                    (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                                 (eq_vec (subrange_vec_dec v__225 6 0)
                                                    (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]
                                                      : mword (6 - 0 + 1))))))
                                : bool))) >>= fun w__31 : bool =>
                           (if sumbool_of_bool (w__31) then
                              let _mappingpatterns_8_ : mword 2 := subrange_vec_dec v__225 13 12 in
                              let _mappingpatterns_7_ : mword 1 := subrange_vec_dec v__225 25 25 in
                              let _mappingpatterns_6_ : mword 1 := subrange_vec_dec v__225 26 26 in
                              (size_bits_backwards _mappingpatterns_8_) >>= fun size =>
                              (bool_bits_backwards _mappingpatterns_7_) >>= fun rl =>
                              (bool_bits_backwards _mappingpatterns_6_) >>= fun aq =>
                              returnm (true
                               : bool)
                            else
                              (and_boolM
                                 (let _mappingpatterns_9_ : mword 1 := subrange_vec_dec v__225 26 26 in
                                 let _mappingpatterns_11_ : mword 2 := subrange_vec_dec v__225 13 12 in
                                 let _mappingpatterns_10_ : mword 1 := subrange_vec_dec v__225 25 25 in
                                 (and_boolM
                                    (returnm ((size_bits_backwards_matches _mappingpatterns_11_)
                                      : bool))
                                    ((if ((size_bits_backwards_matches _mappingpatterns_11_)) then
                                        (size_bits_backwards _mappingpatterns_11_) >>= fun size =>
                                        (and_boolM
                                           (returnm ((bool_bits_backwards_matches
                                                        _mappingpatterns_10_)
                                             : bool))
                                           ((if ((bool_bits_backwards_matches _mappingpatterns_10_))
                                             then
                                               (bool_bits_backwards _mappingpatterns_10_) >>= fun rl =>
                                               (and_boolM
                                                  (returnm ((bool_bits_backwards_matches
                                                               _mappingpatterns_9_)
                                                    : bool))
                                                  ((if ((bool_bits_backwards_matches
                                                           _mappingpatterns_9_)) then
                                                      (bool_bits_backwards _mappingpatterns_9_) >>= fun aq =>
                                                      returnm (((Z.leb
                                                                   (projT1
                                                                    (word_width_bytes size)) 8)
                                                       : bool)
                                                       : bool)
                                                    else
                                                      returnm (projT1
                                                      (build_ex
                                                      false
                                                       : {_bool : bool & ArithFact (not (_bool =
                                                        true))})))
                                                   : M (bool))) >>= fun w__33 : bool =>
                                               returnm ((w__33
                                                : bool)
                                                : bool)
                                             else
                                               returnm (projT1
                                               (build_ex
                                               false
                                                : {_bool : bool & ArithFact (not (_bool = true))})))
                                            : M (bool))) >>= fun w__35 : bool =>
                                        returnm ((w__35
                                         : bool)
                                         : bool)
                                      else
                                        returnm (projT1
                                        (build_ex
                                        false
                                         : {_bool : bool & ArithFact (not (_bool = true))})))
                                     : M (bool)))
                                  : M (bool))
                                 (returnm ((andb
                                              (eq_vec (subrange_vec_dec v__225 31 27)
                                                 (vec_of_bits [B0;B0;B0;B1;B1]
                                                   : mword (31 - 27 + 1)))
                                              (andb
                                                 (eq_vec (subrange_vec_dec v__225 14 14)
                                                    (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                                 (eq_vec (subrange_vec_dec v__225 6 0)
                                                    (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]
                                                      : mword (6 - 0 + 1)))))
                                   : bool))) >>= fun w__38 : bool =>
                              (if sumbool_of_bool (w__38) then
                                 let _mappingpatterns_9_ : mword 1 := subrange_vec_dec v__225 26 26 in
                                 let _mappingpatterns_11_ : mword 2 := subrange_vec_dec v__225 13 12 in
                                 let _mappingpatterns_10_ : mword 1 := subrange_vec_dec v__225 25 25 in
                                 (size_bits_backwards _mappingpatterns_11_) >>= fun size =>
                                 (bool_bits_backwards _mappingpatterns_10_) >>= fun rl =>
                                 (bool_bits_backwards _mappingpatterns_9_) >>= fun aq =>
                                 returnm (true
                                  : bool)
                               else
                                 (and_boolM
                                    (let _mappingpatterns_12_ : mword 5 :=
                                      subrange_vec_dec v__225 31 27 in
                                    let _mappingpatterns_15_ : mword 2 :=
                                      subrange_vec_dec v__225 13 12 in
                                    let _mappingpatterns_14_ : mword 1 :=
                                      subrange_vec_dec v__225 25 25 in
                                    let _mappingpatterns_13_ : mword 1 :=
                                      subrange_vec_dec v__225 26 26 in
                                    let _mappingpatterns_12_ : mword 5 :=
                                      subrange_vec_dec v__225 31 27 in
                                    (and_boolM
                                       (returnm ((size_bits_backwards_matches _mappingpatterns_15_)
                                         : bool))
                                       ((if ((size_bits_backwards_matches _mappingpatterns_15_))
                                         then
                                           (size_bits_backwards _mappingpatterns_15_) >>= fun size =>
                                           (and_boolM
                                              (returnm ((bool_bits_backwards_matches
                                                           _mappingpatterns_14_)
                                                : bool))
                                              ((if ((bool_bits_backwards_matches
                                                       _mappingpatterns_14_)) then
                                                  (bool_bits_backwards _mappingpatterns_14_) >>= fun rl =>
                                                  (and_boolM
                                                     (returnm ((bool_bits_backwards_matches
                                                                  _mappingpatterns_13_)
                                                       : bool))
                                                     ((if ((bool_bits_backwards_matches
                                                              _mappingpatterns_13_)) then
                                                         (bool_bits_backwards _mappingpatterns_13_) >>= fun aq =>
                                                         (and_boolM
                                                            (returnm ((encdec_amoop_backwards_matches
                                                                         _mappingpatterns_12_)
                                                              : bool))
                                                            ((if ((encdec_amoop_backwards_matches
                                                                     _mappingpatterns_12_)) then
                                                                (encdec_amoop_backwards
                                                                   _mappingpatterns_12_) >>= fun op =>
                                                                returnm (((Z.leb
                                                                             (projT1
                                                                              (word_width_bytes size))
                                                                             8)
                                                                 : bool)
                                                                 : bool)
                                                              else
                                                                returnm (projT1
                                                                (build_ex
                                                                false
                                                                 : {_bool : bool & ArithFact (not (_bool =
                                                                  true))})))
                                                             : M (bool))) >>= fun w__40 : bool =>
                                                         returnm ((w__40
                                                          : bool)
                                                          : bool)
                                                       else
                                                         returnm (projT1
                                                         (build_ex
                                                         false
                                                          : {_bool : bool & ArithFact (not (_bool =
                                                           true))})))
                                                      : M (bool))) >>= fun w__42 : bool =>
                                                  returnm ((w__42
                                                   : bool)
                                                   : bool)
                                                else
                                                  returnm (projT1
                                                  (build_ex
                                                  false
                                                   : {_bool : bool & ArithFact (not (_bool = true))})))
                                               : M (bool))) >>= fun w__44 : bool =>
                                           returnm ((w__44
                                            : bool)
                                            : bool)
                                         else
                                           returnm (projT1
                                           (build_ex
                                           false
                                            : {_bool : bool & ArithFact (not (_bool = true))})))
                                        : M (bool)))
                                     : M (bool))
                                    (returnm ((andb
                                                 (eq_vec (subrange_vec_dec v__225 14 14)
                                                    (vec_of_bits [B0]  : mword (14 - 14 + 1)))
                                                 (eq_vec (subrange_vec_dec v__225 6 0)
                                                    (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]
                                                      : mword (6 - 0 + 1))))
                                      : bool))) >>= fun w__47 : bool =>
                                 (if sumbool_of_bool (w__47) then
                                    let _mappingpatterns_12_ : mword 5 :=
                                      subrange_vec_dec v__225 31 27 in
                                    let _mappingpatterns_15_ : mword 2 :=
                                      subrange_vec_dec v__225 13 12 in
                                    let _mappingpatterns_14_ : mword 1 :=
                                      subrange_vec_dec v__225 25 25 in
                                    let _mappingpatterns_13_ : mword 1 :=
                                      subrange_vec_dec v__225 26 26 in
                                    let _mappingpatterns_12_ : mword 5 :=
                                      subrange_vec_dec v__225 31 27 in
                                    (size_bits_backwards _mappingpatterns_15_) >>= fun size =>
                                    (bool_bits_backwards _mappingpatterns_14_) >>= fun rl =>
                                    (bool_bits_backwards _mappingpatterns_13_) >>= fun aq =>
                                    (encdec_amoop_backwards _mappingpatterns_12_) >>= fun op =>
                                    returnm (true
                                     : bool)
                                  else
                                    (and_boolM
                                       (let _mappingpatterns_16_ : mword 3 :=
                                         subrange_vec_dec v__225 14 12 in
                                       (and_boolM
                                          (returnm ((encdec_mul_op_backwards_matches
                                                       _mappingpatterns_16_)
                                            : bool))
                                          ((if ((encdec_mul_op_backwards_matches
                                                   _mappingpatterns_16_)) then
                                              (encdec_mul_op_backwards _mappingpatterns_16_) >>= fun '(high, signed1, signed2) =>
                                              returnm ((true
                                               : bool)
                                               : bool)
                                            else
                                              returnm (projT1
                                              (build_ex
                                              false
                                               : {_bool : bool & ArithFact (not (_bool = true))})))
                                           : M (bool)))
                                        : M (bool))
                                       (returnm ((andb
                                                    (eq_vec (subrange_vec_dec v__225 31 25)
                                                       (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                         : mword (31 - 25 + 1)))
                                                    (eq_vec (subrange_vec_dec v__225 6 0)
                                                       (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]
                                                         : mword (6 - 0 + 1))))
                                         : bool))) >>= fun w__50 : bool =>
                                    (if sumbool_of_bool (w__50) then
                                       let _mappingpatterns_16_ : mword 3 :=
                                         subrange_vec_dec v__225 14 12 in
                                       (encdec_mul_op_backwards _mappingpatterns_16_) >>= fun '(high, signed1, signed2) =>
                                       returnm (true
                                        : bool)
                                     else
                                       (and_boolM
                                          (let _mappingpatterns_17_ : mword 1 :=
                                            subrange_vec_dec v__225 12 12 in
                                          (and_boolM
                                             (returnm ((bool_not_bits_backwards_matches
                                                          _mappingpatterns_17_)
                                               : bool))
                                             ((if ((bool_not_bits_backwards_matches
                                                      _mappingpatterns_17_)) then
                                                 (bool_not_bits_backwards _mappingpatterns_17_) >>= fun s =>
                                                 returnm ((true
                                                  : bool)
                                                  : bool)
                                               else
                                                 returnm (projT1
                                                 (build_ex
                                                 false
                                                  : {_bool : bool & ArithFact (not (_bool = true))})))
                                              : M (bool)))
                                           : M (bool))
                                          (returnm ((andb
                                                       (eq_vec (subrange_vec_dec v__225 31 25)
                                                          (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                            : mword (31 - 25 + 1)))
                                                       (andb
                                                          (eq_vec (subrange_vec_dec v__225 14 13)
                                                             (vec_of_bits [B1;B0]
                                                               : mword (14 - 13 + 1)))
                                                          (eq_vec (subrange_vec_dec v__225 6 0)
                                                             (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]
                                                               : mword (6 - 0 + 1)))))
                                            : bool))) >>= fun w__53 : bool =>
                                       (if sumbool_of_bool (w__53) then
                                          let _mappingpatterns_17_ : mword 1 :=
                                            subrange_vec_dec v__225 12 12 in
                                          (bool_not_bits_backwards _mappingpatterns_17_) >>= fun s =>
                                          returnm (true
                                           : bool)
                                        else
                                          (and_boolM
                                             (let _mappingpatterns_18_ : mword 1 :=
                                               subrange_vec_dec v__225 12 12 in
                                             (and_boolM
                                                (returnm ((bool_not_bits_backwards_matches
                                                             _mappingpatterns_18_)
                                                  : bool))
                                                ((if ((bool_not_bits_backwards_matches
                                                         _mappingpatterns_18_)) then
                                                    (bool_not_bits_backwards _mappingpatterns_18_) >>= fun s =>
                                                    returnm ((true
                                                     : bool)
                                                     : bool)
                                                  else
                                                    returnm (projT1
                                                    (build_ex
                                                    false
                                                     : {_bool : bool & ArithFact (not (_bool = true))})))
                                                 : M (bool)))
                                              : M (bool))
                                             (returnm ((andb
                                                          (eq_vec (subrange_vec_dec v__225 31 25)
                                                             (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                               : mword (31 - 25 + 1)))
                                                          (andb
                                                             (eq_vec (subrange_vec_dec v__225 14 13)
                                                                (vec_of_bits [B1;B1]
                                                                  : mword (14 - 13 + 1)))
                                                             (eq_vec (subrange_vec_dec v__225 6 0)
                                                                (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]
                                                                  : mword (6 - 0 + 1)))))
                                               : bool))) >>= fun w__56 : bool =>
                                          (if sumbool_of_bool (w__56) then
                                             let _mappingpatterns_18_ : mword 1 :=
                                               subrange_vec_dec v__225 12 12 in
                                             (bool_not_bits_backwards _mappingpatterns_18_) >>= fun s =>
                                             returnm (true
                                              : bool)
                                           else if sumbool_of_bool ((andb (Z.eqb 64 64)
                                                                       (andb
                                                                          (eq_vec
                                                                             (subrange_vec_dec
                                                                                v__225 31 25)
                                                                             (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                                               : mword (31 - 25 + 1)))
                                                                          (andb
                                                                             (eq_vec
                                                                                (subrange_vec_dec
                                                                                   v__225 14 12)
                                                                                (vec_of_bits [B0;B0;B0]
                                                                                  : mword (14 - 12 + 1)))
                                                                             (eq_vec
                                                                                (subrange_vec_dec
                                                                                   v__225 6 0)
                                                                                (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                                  : mword (6 - 0 + 1)))))))
                                           then
                                             returnm (projT1
                                             (build_ex
                                             true
                                              : {_bool : bool & ArithFact (_bool = true)}))
                                           else
                                             (and_boolM
                                                (let _mappingpatterns_19_ : mword 1 :=
                                                  subrange_vec_dec v__225 12 12 in
                                                (and_boolM
                                                   (returnm ((bool_not_bits_backwards_matches
                                                                _mappingpatterns_19_)
                                                     : bool))
                                                   ((if ((bool_not_bits_backwards_matches
                                                            _mappingpatterns_19_)) then
                                                       (bool_not_bits_backwards _mappingpatterns_19_) >>= fun s =>
                                                       returnm (((Z.eqb 64 64)
                                                        : bool)
                                                        : bool)
                                                     else
                                                       returnm (projT1
                                                       (build_ex
                                                       false
                                                        : {_bool : bool & ArithFact (not (_bool =
                                                         true))})))
                                                    : M (bool)))
                                                 : M (bool))
                                                (returnm ((andb
                                                             (eq_vec (subrange_vec_dec v__225 31 25)
                                                                (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                                  : mword (31 - 25 + 1)))
                                                             (andb
                                                                (eq_vec
                                                                   (subrange_vec_dec v__225 14 13)
                                                                   (vec_of_bits [B1;B0]
                                                                     : mword (14 - 13 + 1)))
                                                                (eq_vec
                                                                   (subrange_vec_dec v__225 6 0)
                                                                   (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                     : mword (6 - 0 + 1)))))
                                                  : bool))) >>= fun w__59 : bool =>
                                             (if sumbool_of_bool (w__59) then
                                                let _mappingpatterns_19_ : mword 1 :=
                                                  subrange_vec_dec v__225 12 12 in
                                                (bool_not_bits_backwards _mappingpatterns_19_) >>= fun s =>
                                                returnm (true
                                                 : bool)
                                              else
                                                (and_boolM
                                                   (let _mappingpatterns_20_ : mword 1 :=
                                                     subrange_vec_dec v__225 12 12 in
                                                   (and_boolM
                                                      (returnm ((bool_not_bits_backwards_matches
                                                                   _mappingpatterns_20_)
                                                        : bool))
                                                      ((if ((bool_not_bits_backwards_matches
                                                               _mappingpatterns_20_)) then
                                                          (bool_not_bits_backwards
                                                             _mappingpatterns_20_) >>= fun s =>
                                                          returnm (((Z.eqb 64 64)
                                                           : bool)
                                                           : bool)
                                                        else
                                                          returnm (projT1
                                                          (build_ex
                                                          false
                                                           : {_bool : bool & ArithFact (not (_bool =
                                                            true))})))
                                                       : M (bool)))
                                                    : M (bool))
                                                   (returnm ((andb
                                                                (eq_vec
                                                                   (subrange_vec_dec v__225 31 25)
                                                                   (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]
                                                                     : mword (31 - 25 + 1)))
                                                                (andb
                                                                   (eq_vec
                                                                      (subrange_vec_dec v__225 14 13)
                                                                      (vec_of_bits [B1;B1]
                                                                        : mword (14 - 13 + 1)))
                                                                   (eq_vec
                                                                      (subrange_vec_dec v__225 6 0)
                                                                      (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]
                                                                        : mword (6 - 0 + 1)))))
                                                     : bool))) >>= fun w__62 : bool =>
                                                (if sumbool_of_bool (w__62) then
                                                   let _mappingpatterns_20_ : mword 1 :=
                                                     subrange_vec_dec v__225 12 12 in
                                                   (bool_not_bits_backwards _mappingpatterns_20_) >>= fun s =>
                                                   returnm (true
                                                    : bool)
                                                 else
                                                   (and_boolM
                                                      (let _mappingpatterns_22_ : mword 2 :=
                                                        subrange_vec_dec v__225 13 12 in
                                                      let _mappingpatterns_21_ : mword 1 :=
                                                        subrange_vec_dec v__225 14 14 in
                                                      (and_boolM
                                                         (returnm ((encdec_csrop_backwards_matches
                                                                      _mappingpatterns_22_)
                                                           : bool))
                                                         ((if ((encdec_csrop_backwards_matches
                                                                  _mappingpatterns_22_)) then
                                                             (encdec_csrop_backwards
                                                                _mappingpatterns_22_) >>= fun op =>
                                                             (and_boolM
                                                                (returnm ((bool_bits_backwards_matches
                                                                             _mappingpatterns_21_)
                                                                  : bool))
                                                                ((if ((bool_bits_backwards_matches
                                                                         _mappingpatterns_21_)) then
                                                                    (bool_bits_backwards
                                                                       _mappingpatterns_21_) >>= fun is_imm =>
                                                                    returnm ((true
                                                                     : bool)
                                                                     : bool)
                                                                  else
                                                                    returnm (projT1
                                                                    (build_ex
                                                                    false
                                                                     : {_bool : bool & ArithFact (not (_bool =
                                                                      true))})))
                                                                 : M (bool))) >>= fun w__64 : bool =>
                                                             returnm ((w__64
                                                              : bool)
                                                              : bool)
                                                           else
                                                             returnm (projT1
                                                             (build_ex
                                                             false
                                                              : {_bool : bool & ArithFact (not (_bool =
                                                               true))})))
                                                          : M (bool)))
                                                       : M (bool))
                                                      (returnm ((eq_vec
                                                                   (subrange_vec_dec v__225 6 0)
                                                                   (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]
                                                                     : mword (6 - 0 + 1)))
                                                        : bool))) >>= fun w__67 : bool =>
                                                   (if sumbool_of_bool (w__67) then
                                                      let _mappingpatterns_22_ : mword 2 :=
                                                        subrange_vec_dec v__225 13 12 in
                                                      let _mappingpatterns_21_ : mword 1 :=
                                                        subrange_vec_dec v__225 14 14 in
                                                      (encdec_csrop_backwards _mappingpatterns_22_) >>= fun op =>
                                                      (bool_bits_backwards _mappingpatterns_21_) >>= fun is_imm =>
                                                      returnm (true
                                                       : bool)
                                                    else
                                                      returnm ((if ((eq_vec v__225
                                                                       (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                                                                     B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                                                                         : mword 32))) then
                                                                  true
                                                                else true)
                                                       : bool))
                                                    : M (bool))
                                                 : M (bool))
                                              : M (bool))
                                           : M (bool))
                                        : M (bool))
                                     : M (bool))
                                  : M (bool))
                               : M (bool))
                            : M (bool))
                         : M (bool))
                      : M (bool))
                   : M (bool))
                : M (bool))
             : M (bool))
          : M (bool))
       : M (bool))
    : M (bool).

Definition encdec_compressed_forwards (arg_ : ast) 
: M (mword 16) :=
   
   (match arg_ with
    | C_NOP (tt) =>
       returnm ((concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                   (concat_vec (vec_of_bits [B0]  : mword 1)
                      (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (vec_of_bits [B0;B1]  : mword 2)))))
        : mword (3 + (1 + (5 + (5 + 2)))))
    | C_ADDI4SPN ((rd, v__438)) =>
       (if ((let nz96 : bits 4 := subrange_vec_dec v__438 7 4 in
          let nz96 : bits 4 := subrange_vec_dec v__438 7 4 in
          let nz54 : bits 2 := subrange_vec_dec v__438 3 2 in
          let nz3 : bits 1 := subrange_vec_dec v__438 1 1 in
          let nz2 : bits 1 := subrange_vec_dec v__438 0 0 in
          neq_vec (concat_vec nz96 (concat_vec nz54 (concat_vec nz3 nz2)))
            (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword (4 + (2 + (1 + 1)))))) then
          let nz96 : bits 4 := subrange_vec_dec v__438 7 4 in
          let nz96 : bits 4 := subrange_vec_dec v__438 7 4 in
          let nz54 : bits 2 := subrange_vec_dec v__438 3 2 in
          let nz3 : bits 1 := subrange_vec_dec v__438 1 1 in
          let nz2 : bits 1 := subrange_vec_dec v__438 0 0 in
          returnm ((concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                      (concat_vec (nz54  : bits 2)
                         (concat_vec (nz96  : bits 4)
                            (concat_vec (nz2  : bits 1)
                               (concat_vec (nz3  : bits 1)
                                  (concat_vec (rd  : cregidx) (vec_of_bits [B0;B0]  : mword 2)))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_LW ((v__439, rs1, rd)) =>
       let ui6 : bits 1 := subrange_vec_dec v__439 4 4 in
       let ui6 : bits 1 := subrange_vec_dec v__439 4 4 in
       let ui53 : bits 3 := subrange_vec_dec v__439 3 1 in
       let ui2 : bits 1 := subrange_vec_dec v__439 0 0 in
       returnm ((concat_vec (vec_of_bits [B0;B1;B0]  : mword 3)
                   (concat_vec (ui53  : bits 3)
                      (concat_vec (rs1  : cregidx)
                         (concat_vec (ui2  : bits 1)
                            (concat_vec (ui6  : bits 1)
                               (concat_vec (rd  : cregidx) (vec_of_bits [B0;B0]  : mword 2)))))))
        : mword 16)
    | C_LD ((v__440, rs1, rd)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          let ui76 : bits 2 := subrange_vec_dec v__440 4 3 in
          let ui76 : bits 2 := subrange_vec_dec v__440 4 3 in
          let ui53 : bits 3 := subrange_vec_dec v__440 2 0 in
          returnm ((concat_vec (vec_of_bits [B0;B1;B1]  : mword 3)
                      (concat_vec (ui53  : bits 3)
                         (concat_vec (rs1  : cregidx)
                            (concat_vec (ui76  : bits 2)
                               (concat_vec (rd  : cregidx) (vec_of_bits [B0;B0]  : mword 2))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_SW ((v__441, rs1, rs2)) =>
       let ui6 : bits 1 := subrange_vec_dec v__441 4 4 in
       let ui6 : bits 1 := subrange_vec_dec v__441 4 4 in
       let ui53 : bits 3 := subrange_vec_dec v__441 3 1 in
       let ui2 : bits 1 := subrange_vec_dec v__441 0 0 in
       returnm ((concat_vec (vec_of_bits [B1;B1;B0]  : mword 3)
                   (concat_vec (ui53  : bits 3)
                      (concat_vec (rs1  : cregidx)
                         (concat_vec (ui2  : bits 1)
                            (concat_vec (ui6  : bits 1)
                               (concat_vec (rs2  : cregidx) (vec_of_bits [B0;B0]  : mword 2)))))))
        : mword 16)
    | C_SD ((v__442, rs1, rs2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          let ui76 : bits 2 := subrange_vec_dec v__442 4 3 in
          let ui76 : bits 2 := subrange_vec_dec v__442 4 3 in
          let ui53 : bits 3 := subrange_vec_dec v__442 2 0 in
          returnm ((concat_vec (vec_of_bits [B1;B1;B1]  : mword 3)
                      (concat_vec (ui53  : bits 3)
                         (concat_vec (rs1  : bits 3)
                            (concat_vec (ui76  : bits 2)
                               (concat_vec (rs2  : bits 3) (vec_of_bits [B0;B0]  : mword 2))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_ADDI ((v__443, rsd)) =>
       (if ((let nzi5 : bits 1 := subrange_vec_dec v__443 5 5 in
          let nzi5 : bits 1 := subrange_vec_dec v__443 5 5 in
          let nzi40 : bits 5 := subrange_vec_dec v__443 4 0 in
          andb (neq_vec (concat_vec nzi5 nzi40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
            ((projT1
              (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
             : bool))) then
          let nzi5 : bits 1 := subrange_vec_dec v__443 5 5 in
          let nzi5 : bits 1 := subrange_vec_dec v__443 5 5 in
          let nzi40 : bits 5 := subrange_vec_dec v__443 4 0 in
          returnm ((concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                      (concat_vec (nzi5  : bits 1)
                         (concat_vec (rsd  : regidx)
                            (concat_vec (nzi40  : bits 5) (vec_of_bits [B0;B1]  : mword 2)))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_JAL (v__444) =>
       (if sumbool_of_bool ((Z.eqb 64 32)) then
          let i11 : bits 1 := subrange_vec_dec v__444 10 10 in
          let i98 : bits 2 := subrange_vec_dec v__444 8 7 in
          let i7 : bits 1 := subrange_vec_dec v__444 6 6 in
          let i6 : bits 1 := subrange_vec_dec v__444 5 5 in
          let i5 : bits 1 := subrange_vec_dec v__444 4 4 in
          let i4 : bits 1 := subrange_vec_dec v__444 3 3 in
          let i31 : bits 3 := subrange_vec_dec v__444 2 0 in
          let i11 : bits 1 := subrange_vec_dec v__444 10 10 in
          let i10 : bits 1 := subrange_vec_dec v__444 9 9 in
          returnm ((concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                      (concat_vec (i11  : bits 1)
                         (concat_vec (i4  : bits 1)
                            (concat_vec (i98  : bits 2)
                               (concat_vec (i10  : bits 1)
                                  (concat_vec (i6  : bits 1)
                                     (concat_vec (i7  : bits 1)
                                        (concat_vec (i31  : bits 3)
                                           (concat_vec (i5  : bits 1)
                                              (vec_of_bits [B0;B1]  : mword 2))))))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_ADDIW ((v__445, rsd)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rsd))
                                   (projT1
                                    (regidx_to_regno zreg)))) (Z.eqb 64 64))) then
          let imm5 : bits 1 := subrange_vec_dec v__445 5 5 in
          let imm5 : bits 1 := subrange_vec_dec v__445 5 5 in
          let imm40 : bits 5 := subrange_vec_dec v__445 4 0 in
          returnm ((concat_vec (vec_of_bits [B0;B0;B1]  : mword 3)
                      (concat_vec (imm5  : bits 1)
                         (concat_vec (rsd  : regidx)
                            (concat_vec (imm40  : bits 5) (vec_of_bits [B0;B1]  : mword 2)))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_LI ((v__446, rd)) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
        then
          let imm5 : bits 1 := subrange_vec_dec v__446 5 5 in
          let imm5 : bits 1 := subrange_vec_dec v__446 5 5 in
          let imm40 : bits 5 := subrange_vec_dec v__446 4 0 in
          returnm ((concat_vec (vec_of_bits [B0;B1;B0]  : mword 3)
                      (concat_vec (imm5  : bits 1)
                         (concat_vec (rd  : regidx)
                            (concat_vec (imm40  : bits 5) (vec_of_bits [B0;B1]  : mword 2)))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_ADDI16SP (v__447) =>
       (if ((let nzi9 : bits 1 := subrange_vec_dec v__447 5 5 in
          let nzi9 : bits 1 := subrange_vec_dec v__447 5 5 in
          let nzi87 : bits 2 := subrange_vec_dec v__447 4 3 in
          let nzi6 : bits 1 := subrange_vec_dec v__447 2 2 in
          let nzi5 : bits 1 := subrange_vec_dec v__447 1 1 in
          let nzi4 : bits 1 := subrange_vec_dec v__447 0 0 in
          neq_vec (concat_vec nzi9 (concat_vec nzi87 (concat_vec nzi6 (concat_vec nzi5 nzi4))))
            (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + (2 + (1 + (1 + 1))))))) then
          let nzi9 : bits 1 := subrange_vec_dec v__447 5 5 in
          let nzi9 : bits 1 := subrange_vec_dec v__447 5 5 in
          let nzi87 : bits 2 := subrange_vec_dec v__447 4 3 in
          let nzi6 : bits 1 := subrange_vec_dec v__447 2 2 in
          let nzi5 : bits 1 := subrange_vec_dec v__447 1 1 in
          let nzi4 : bits 1 := subrange_vec_dec v__447 0 0 in
          returnm ((concat_vec (vec_of_bits [B0;B1;B1]  : mword 3)
                      (concat_vec (nzi9  : bits 1)
                         (concat_vec (vec_of_bits [B0;B0;B0;B1;B0]  : mword 5)
                            (concat_vec (nzi4  : bits 1)
                               (concat_vec (nzi6  : bits 1)
                                  (concat_vec (nzi87  : bits 2)
                                     (concat_vec (nzi5  : bits 1) (vec_of_bits [B0;B1]  : mword 2))))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_LUI ((v__448, rd)) =>
       (if sumbool_of_bool ((let imm17 : bits 1 := subrange_vec_dec v__448 5 5 in
          let imm17 : bits 1 := subrange_vec_dec v__448 5 5 in
          let imm1612 : bits 5 := subrange_vec_dec v__448 4 0 in
          andb (projT1 (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg))))
            ((andb (projT1 (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno sp))))
                (neq_vec (concat_vec imm17 imm1612)
                   (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5))))
             : bool))) then
          let imm17 : bits 1 := subrange_vec_dec v__448 5 5 in
          let imm17 : bits 1 := subrange_vec_dec v__448 5 5 in
          let imm1612 : bits 5 := subrange_vec_dec v__448 4 0 in
          returnm ((concat_vec (vec_of_bits [B0;B1;B1]  : mword 3)
                      (concat_vec (imm17  : bits 1)
                         (concat_vec (rd  : regidx)
                            (concat_vec (imm1612  : bits 5) (vec_of_bits [B0;B1]  : mword 2)))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_SRLI ((v__449, rsd)) =>
       (if ((let nzui5 : bits 1 := subrange_vec_dec v__449 5 5 in
          let nzui5 : bits 1 := subrange_vec_dec v__449 5 5 in
          let nzui40 : bits 5 := subrange_vec_dec v__449 4 0 in
          neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5))))
        then
          let nzui5 : bits 1 := subrange_vec_dec v__449 5 5 in
          let nzui5 : bits 1 := subrange_vec_dec v__449 5 5 in
          let nzui40 : bits 5 := subrange_vec_dec v__449 4 0 in
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (nzui5  : bits 1)
                         (concat_vec (vec_of_bits [B0;B0]  : mword 2)
                            (concat_vec (rsd  : cregidx)
                               (concat_vec (nzui40  : bits 5) (vec_of_bits [B0;B1]  : mword 2))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_SRAI ((v__450, rsd)) =>
       (if ((let nzui5 : bits 1 := subrange_vec_dec v__450 5 5 in
          let nzui5 : bits 1 := subrange_vec_dec v__450 5 5 in
          let nzui40 : bits 5 := subrange_vec_dec v__450 4 0 in
          neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5))))
        then
          let nzui5 : bits 1 := subrange_vec_dec v__450 5 5 in
          let nzui5 : bits 1 := subrange_vec_dec v__450 5 5 in
          let nzui40 : bits 5 := subrange_vec_dec v__450 4 0 in
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (nzui5  : bits 1)
                         (concat_vec (vec_of_bits [B0;B1]  : mword 2)
                            (concat_vec (rsd  : cregidx)
                               (concat_vec (nzui40  : bits 5) (vec_of_bits [B0;B1]  : mword 2))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_ANDI ((v__451, rsd)) =>
       let i5 : bits 1 := subrange_vec_dec v__451 5 5 in
       let i5 : bits 1 := subrange_vec_dec v__451 5 5 in
       let i40 : bits 5 := subrange_vec_dec v__451 4 0 in
       returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                   (concat_vec (i5  : bits 1)
                      (concat_vec (vec_of_bits [B1;B0]  : mword 2)
                         (concat_vec (rsd  : cregidx)
                            (concat_vec (i40  : bits 5) (vec_of_bits [B0;B1]  : mword 2))))))
        : mword 16)
    | C_SUB ((rsd, rs2)) =>
       returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                   (concat_vec (vec_of_bits [B0]  : mword 1)
                      (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                         (concat_vec (rsd  : cregidx)
                            (concat_vec (vec_of_bits [B0;B0]  : mword 2)
                               (concat_vec (rs2  : cregidx) (vec_of_bits [B0;B1]  : mword 2)))))))
        : mword (3 + (1 + (2 + (3 + (2 + (3 + 2)))))))
    | C_XOR ((rsd, rs2)) =>
       returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                   (concat_vec (vec_of_bits [B0]  : mword 1)
                      (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                         (concat_vec (rsd  : cregidx)
                            (concat_vec (vec_of_bits [B0;B1]  : mword 2)
                               (concat_vec (rs2  : cregidx) (vec_of_bits [B0;B1]  : mword 2)))))))
        : mword (3 + (1 + (2 + (3 + (2 + (3 + 2)))))))
    | C_OR ((rsd, rs2)) =>
       returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                   (concat_vec (vec_of_bits [B0]  : mword 1)
                      (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                         (concat_vec (rsd  : cregidx)
                            (concat_vec (vec_of_bits [B1;B0]  : mword 2)
                               (concat_vec (rs2  : cregidx) (vec_of_bits [B0;B1]  : mword 2)))))))
        : mword (3 + (1 + (2 + (3 + (2 + (3 + 2)))))))
    | C_AND ((rsd, rs2)) =>
       returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                   (concat_vec (vec_of_bits [B0]  : mword 1)
                      (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                         (concat_vec (rsd  : cregidx)
                            (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                               (concat_vec (rs2  : cregidx) (vec_of_bits [B0;B1]  : mword 2)))))))
        : mword (3 + (1 + (2 + (3 + (2 + (3 + 2)))))))
    | C_SUBW ((rsd, rs2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (vec_of_bits [B1]  : mword 1)
                         (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                            (concat_vec (rsd  : cregidx)
                               (concat_vec (vec_of_bits [B0;B0]  : mword 2)
                                  (concat_vec (rs2  : cregidx) (vec_of_bits [B0;B1]  : mword 2)))))))
           : mword (3 + (1 + (2 + (3 + (2 + (3 + 2)))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_ADDW ((rsd, rs2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (vec_of_bits [B1]  : mword 1)
                         (concat_vec (vec_of_bits [B1;B1]  : mword 2)
                            (concat_vec (rsd  : cregidx)
                               (concat_vec (vec_of_bits [B0;B1]  : mword 2)
                                  (concat_vec (rs2  : cregidx) (vec_of_bits [B0;B1]  : mword 2)))))))
           : mword (3 + (1 + (2 + (3 + (2 + (3 + 2)))))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_J (v__452) =>
       let i11 : bits 1 := subrange_vec_dec v__452 10 10 in
       let i98 : bits 2 := subrange_vec_dec v__452 8 7 in
       let i7 : bits 1 := subrange_vec_dec v__452 6 6 in
       let i6 : bits 1 := subrange_vec_dec v__452 5 5 in
       let i5 : bits 1 := subrange_vec_dec v__452 4 4 in
       let i4 : bits 1 := subrange_vec_dec v__452 3 3 in
       let i31 : bits 3 := subrange_vec_dec v__452 2 0 in
       let i11 : bits 1 := subrange_vec_dec v__452 10 10 in
       let i10 : bits 1 := subrange_vec_dec v__452 9 9 in
       returnm ((concat_vec (vec_of_bits [B1;B0;B1]  : mword 3)
                   (concat_vec (i11  : bits 1)
                      (concat_vec (i4  : bits 1)
                         (concat_vec (i98  : bits 2)
                            (concat_vec (i10  : bits 1)
                               (concat_vec (i6  : bits 1)
                                  (concat_vec (i7  : bits 1)
                                     (concat_vec (i31  : bits 3)
                                        (concat_vec (i5  : bits 1) (vec_of_bits [B0;B1]  : mword 2))))))))))
        : mword 16)
    | C_BEQZ ((v__453, rs)) =>
       let i8 : bits 1 := subrange_vec_dec v__453 7 7 in
       let i8 : bits 1 := subrange_vec_dec v__453 7 7 in
       let i76 : bits 2 := subrange_vec_dec v__453 6 5 in
       let i5 : bits 1 := subrange_vec_dec v__453 4 4 in
       let i43 : bits 2 := subrange_vec_dec v__453 3 2 in
       let i21 : bits 2 := subrange_vec_dec v__453 1 0 in
       returnm ((concat_vec (vec_of_bits [B1;B1;B0]  : mword 3)
                   (concat_vec (i8  : bits 1)
                      (concat_vec (i43  : bits 2)
                         (concat_vec (rs  : cregidx)
                            (concat_vec (i76  : bits 2)
                               (concat_vec (i21  : bits 2)
                                  (concat_vec (i5  : bits 1) (vec_of_bits [B0;B1]  : mword 2))))))))
        : mword 16)
    | C_BNEZ ((v__454, rs)) =>
       let i8 : bits 1 := subrange_vec_dec v__454 7 7 in
       let i8 : bits 1 := subrange_vec_dec v__454 7 7 in
       let i76 : bits 2 := subrange_vec_dec v__454 6 5 in
       let i5 : bits 1 := subrange_vec_dec v__454 4 4 in
       let i43 : bits 2 := subrange_vec_dec v__454 3 2 in
       let i21 : bits 2 := subrange_vec_dec v__454 1 0 in
       returnm ((concat_vec (vec_of_bits [B1;B1;B1]  : mword 3)
                   (concat_vec (i8  : bits 1)
                      (concat_vec (i43  : bits 2)
                         (concat_vec (rs  : cregidx)
                            (concat_vec (i76  : bits 2)
                               (concat_vec (i21  : bits 2)
                                  (concat_vec (i5  : bits 1) (vec_of_bits [B0;B1]  : mword 2))))))))
        : mword 16)
    | C_SLLI ((v__455, rsd)) =>
       (if ((let nzui5 : bits 1 := subrange_vec_dec v__455 5 5 in
          let nzui5 : bits 1 := subrange_vec_dec v__455 5 5 in
          let nzui40 : bits 5 := subrange_vec_dec v__455 4 0 in
          andb
            (neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
            ((andb (projT1 (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
                (orb (Z.eqb 64 64) (eq_vec nzui5 ((bool_to_bits false)  : mword 1))))
             : bool))) then
          let nzui5 : bits 1 := subrange_vec_dec v__455 5 5 in
          let nzui5 : bits 1 := subrange_vec_dec v__455 5 5 in
          let nzui40 : bits 5 := subrange_vec_dec v__455 4 0 in
          returnm ((concat_vec (vec_of_bits [B0;B0;B0]  : mword 3)
                      (concat_vec (nzui5  : bits 1)
                         (concat_vec (rsd  : regidx)
                            (concat_vec (nzui40  : bits 5) (vec_of_bits [B1;B0]  : mword 2)))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_LWSP ((v__456, rd)) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
        then
          let ui76 : bits 2 := subrange_vec_dec v__456 5 4 in
          let ui76 : bits 2 := subrange_vec_dec v__456 5 4 in
          let ui5 : bits 1 := subrange_vec_dec v__456 3 3 in
          let ui42 : bits 3 := subrange_vec_dec v__456 2 0 in
          returnm ((concat_vec (vec_of_bits [B0;B1;B0]  : mword 3)
                      (concat_vec (ui5  : bits 1)
                         (concat_vec (rd  : regidx)
                            (concat_vec (ui42  : bits 3)
                               (concat_vec (ui76  : bits 2) (vec_of_bits [B1;B0]  : mword 2))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_LDSP ((v__457, rd)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rd))
                                   (projT1
                                    (regidx_to_regno zreg)))) (Z.eqb 64 64))) then
          let ui86 : bits 3 := subrange_vec_dec v__457 5 3 in
          let ui86 : bits 3 := subrange_vec_dec v__457 5 3 in
          let ui5 : bits 1 := subrange_vec_dec v__457 2 2 in
          let ui43 : bits 2 := subrange_vec_dec v__457 1 0 in
          returnm ((concat_vec (vec_of_bits [B0;B1;B1]  : mword 3)
                      (concat_vec (ui5  : bits 1)
                         (concat_vec (rd  : regidx)
                            (concat_vec (ui43  : bits 2)
                               (concat_vec (ui86  : bits 3) (vec_of_bits [B1;B0]  : mword 2))))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_SWSP ((v__458, rs2)) =>
       let ui76 : bits 2 := subrange_vec_dec v__458 5 4 in
       let ui76 : bits 2 := subrange_vec_dec v__458 5 4 in
       let ui52 : bits 4 := subrange_vec_dec v__458 3 0 in
       returnm ((concat_vec (vec_of_bits [B1;B1;B0]  : mword 3)
                   (concat_vec (ui52  : bits 4)
                      (concat_vec (ui76  : bits 2)
                         (concat_vec (rs2  : regidx) (vec_of_bits [B1;B0]  : mword 2)))))
        : mword 16)
    | C_SDSP ((v__459, rs2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          let ui86 : bits 3 := subrange_vec_dec v__459 5 3 in
          let ui86 : bits 3 := subrange_vec_dec v__459 5 3 in
          let ui53 : bits 3 := subrange_vec_dec v__459 2 0 in
          returnm ((concat_vec (vec_of_bits [B1;B1;B1]  : mword 3)
                      (concat_vec (ui53  : bits 3)
                         (concat_vec (ui86  : bits 3)
                            (concat_vec (rs2  : regidx) (vec_of_bits [B1;B0]  : mword 2)))))
           : mword 16)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_JR (rs1) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
        then
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (vec_of_bits [B0]  : mword 1)
                         (concat_vec (rs1  : regidx)
                            (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                               (vec_of_bits [B1;B0]  : mword 2)))))
           : mword (3 + (1 + (5 + (5 + 2)))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_JALR (rs1) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
        then
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (vec_of_bits [B1]  : mword 1)
                         (concat_vec (rs1  : regidx)
                            (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                               (vec_of_bits [B1;B0]  : mword 2)))))
           : mword (3 + (1 + (5 + (5 + 2)))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_MV ((rd, rs2)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rd))
                                   (projT1
                                    (regidx_to_regno zreg))))
                               ((projT1
                                 (neq_int (projT1 (regidx_to_regno rs2))
                                    (projT1
                                     (regidx_to_regno zreg))))
                                : bool))) then
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (vec_of_bits [B0]  : mword 1)
                         (concat_vec (rd  : regidx)
                            (concat_vec (rs2  : regidx) (vec_of_bits [B1;B0]  : mword 2)))))
           : mword (3 + (1 + (5 + (5 + 2)))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_EBREAK (tt) =>
       returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                   (concat_vec (vec_of_bits [B1]  : mword 1)
                      (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                         (concat_vec (vec_of_bits [B0;B0;B0;B0;B0]  : mword 5)
                            (vec_of_bits [B1;B0]  : mword 2)))))
        : mword (3 + (1 + (5 + (5 + 2)))))
    | C_ADD ((rsd, rs2)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rsd))
                                   (projT1
                                    (regidx_to_regno zreg))))
                               ((projT1
                                 (neq_int (projT1 (regidx_to_regno rs2))
                                    (projT1
                                     (regidx_to_regno zreg))))
                                : bool))) then
          returnm ((concat_vec (vec_of_bits [B1;B0;B0]  : mword 3)
                      (concat_vec (vec_of_bits [B1]  : mword 1)
                         (concat_vec (rsd  : regidx)
                            (concat_vec (rs2  : regidx) (vec_of_bits [B1;B0]  : mword 2)))))
           : mword (3 + (1 + (5 + (5 + 2)))))
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (mword 16)
    | C_ILLEGAL (s) => returnm (s  : mword 16)
    | _ => assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt
    end)
    : M (mword 16).

Definition encdec_compressed_backwards (arg_ : mword 16) 
: ast :=
   
   let v__460 := arg_ in
   if ((eq_vec v__460 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 16)))
   then
     C_NOP
       (tt)
   else if ((andb
               (let nz96 : bits 4 := subrange_vec_dec v__460 10 7 in
               let nz54 : bits 2 := subrange_vec_dec v__460 12 11 in
               let nz3 : bits 1 := subrange_vec_dec v__460 5 5 in
               let nz2 : bits 1 := subrange_vec_dec v__460 6 6 in
               neq_vec (concat_vec nz96 (concat_vec nz54 (concat_vec nz3 nz2)))
                 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword (4 + (2 + (1 + 1)))))
               (andb
                  (eq_vec (subrange_vec_dec v__460 15 13)
                     (vec_of_bits [B0;B0;B0]  : mword (15 - 13 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))))
   then
     let rd : cregidx := subrange_vec_dec v__460 4 2 in
     let nz96 : bits 4 := subrange_vec_dec v__460 10 7 in
     let nz54 : bits 2 := subrange_vec_dec v__460 12 11 in
     let nz3 : bits 1 := subrange_vec_dec v__460 5 5 in
     let nz2 : bits 1 := subrange_vec_dec v__460 6 6 in
     C_ADDI4SPN
       ((rd, concat_vec (nz96  : bits 4)
               (concat_vec (nz54  : bits 2) (concat_vec (nz3  : bits 1) (nz2  : bits 1)))))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 13)
                  (vec_of_bits [B0;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))
   then
     let ui6 : bits 1 := subrange_vec_dec v__460 5 5 in
     let ui53 : bits 3 := subrange_vec_dec v__460 12 10 in
     let ui2 : bits 1 := subrange_vec_dec v__460 6 6 in
     let rs1 : cregidx := subrange_vec_dec v__460 9 7 in
     let rd : cregidx := subrange_vec_dec v__460 4 2 in
     C_LW
       ((concat_vec (ui6  : bits 1) (concat_vec (ui53  : bits 3) (ui2  : bits 1)), rs1, rd))
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))) then
     let ui76 : bits 2 := subrange_vec_dec v__460 6 5 in
     let ui53 : bits 3 := subrange_vec_dec v__460 12 10 in
     let rs1 : cregidx := subrange_vec_dec v__460 9 7 in
     let rd : cregidx := subrange_vec_dec v__460 4 2 in
     C_LD
       ((concat_vec (ui76  : bits 2) (ui53  : bits 3), rs1, rd))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 13)
                  (vec_of_bits [B1;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))
   then
     let ui6 : bits 1 := subrange_vec_dec v__460 5 5 in
     let ui53 : bits 3 := subrange_vec_dec v__460 12 10 in
     let ui2 : bits 1 := subrange_vec_dec v__460 6 6 in
     let rs2 : cregidx := subrange_vec_dec v__460 4 2 in
     let rs1 : cregidx := subrange_vec_dec v__460 9 7 in
     C_SW
       ((concat_vec (ui6  : bits 1) (concat_vec (ui53  : bits 3) (ui2  : bits 1)), rs1, rs2))
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B1;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))) then
     let ui76 : bits 2 := subrange_vec_dec v__460 6 5 in
     let ui53 : bits 3 := subrange_vec_dec v__460 12 10 in
     let rs2 : bits 3 := subrange_vec_dec v__460 4 2 in
     let rs1 : bits 3 := subrange_vec_dec v__460 9 7 in
     C_SD
       ((concat_vec (ui76  : bits 2) (ui53  : bits 3), rs1, rs2))
   else if ((andb
               (let rsd : regidx := subrange_vec_dec v__460 11 7 in
               let nzi5 : bits 1 := subrange_vec_dec v__460 12 12 in
               let nzi40 : bits 5 := subrange_vec_dec v__460 6 2 in
               andb
                 (neq_vec (concat_vec nzi5 nzi40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
                 ((projT1
                   (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
                  : bool))
               (andb
                  (eq_vec (subrange_vec_dec v__460 15 13)
                     (vec_of_bits [B0;B0;B0]  : mword (15 - 13 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     let rsd : regidx := subrange_vec_dec v__460 11 7 in
     let nzi5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let nzi40 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_ADDI
       ((concat_vec (nzi5  : bits 1) (nzi40  : bits 5), rsd))
   else if sumbool_of_bool ((andb (Z.eqb 64 32)
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B0;B0;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     let i98 : bits 2 := subrange_vec_dec v__460 10 9 in
     let i7 : bits 1 := subrange_vec_dec v__460 6 6 in
     let i6 : bits 1 := subrange_vec_dec v__460 7 7 in
     let i5 : bits 1 := subrange_vec_dec v__460 2 2 in
     let i4 : bits 1 := subrange_vec_dec v__460 11 11 in
     let i31 : bits 3 := subrange_vec_dec v__460 5 3 in
     let i11 : bits 1 := subrange_vec_dec v__460 12 12 in
     let i10 : bits 1 := subrange_vec_dec v__460 8 8 in
     C_JAL
       (concat_vec (i11  : bits 1)
          (concat_vec (i10  : bits 1)
             (concat_vec (i98  : bits 2)
                (concat_vec (i7  : bits 1)
                   (concat_vec (i6  : bits 1)
                      (concat_vec (i5  : bits 1) (concat_vec (i4  : bits 1) (i31  : bits 3))))))))
   else if sumbool_of_bool ((andb
                               (let rsd : regidx := subrange_vec_dec v__460 11 7 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rsd))
                                     (projT1
                                      (regidx_to_regno zreg)))) (Z.eqb 64 64))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B0;B0;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     let rsd : regidx := subrange_vec_dec v__460 11 7 in
     let imm5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let imm40 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_ADDIW
       ((concat_vec (imm5  : bits 1) (imm40  : bits 5), rsd))
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__460 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rd))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B0;B1;B0]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     let rd : regidx := subrange_vec_dec v__460 11 7 in
     let imm5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let imm40 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_LI
       ((concat_vec (imm5  : bits 1) (imm40  : bits 5), rd))
   else if ((andb
               (let nzi9 : bits 1 := subrange_vec_dec v__460 12 12 in
               let nzi87 : bits 2 := subrange_vec_dec v__460 4 3 in
               let nzi6 : bits 1 := subrange_vec_dec v__460 5 5 in
               let nzi5 : bits 1 := subrange_vec_dec v__460 2 2 in
               let nzi4 : bits 1 := subrange_vec_dec v__460 6 6 in
               neq_vec (concat_vec nzi9 (concat_vec nzi87 (concat_vec nzi6 (concat_vec nzi5 nzi4))))
                 (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + (2 + (1 + (1 + 1))))))
               (andb
                  (eq_vec (subrange_vec_dec v__460 15 13)
                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                  (andb
                     (eq_vec (subrange_vec_dec v__460 11 7)
                        (vec_of_bits [B0;B0;B0;B1;B0]  : mword (11 - 7 + 1)))
                     (eq_vec (subrange_vec_dec v__460 1 0)
                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     let nzi9 : bits 1 := subrange_vec_dec v__460 12 12 in
     let nzi87 : bits 2 := subrange_vec_dec v__460 4 3 in
     let nzi6 : bits 1 := subrange_vec_dec v__460 5 5 in
     let nzi5 : bits 1 := subrange_vec_dec v__460 2 2 in
     let nzi4 : bits 1 := subrange_vec_dec v__460 6 6 in
     C_ADDI16SP
       (concat_vec (nzi9  : bits 1)
          (concat_vec (nzi87  : bits 2)
             (concat_vec (nzi6  : bits 1) (concat_vec (nzi5  : bits 1) (nzi4  : bits 1)))))
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__460 11 7 in
                               let imm17 : bits 1 := subrange_vec_dec v__460 12 12 in
                               let imm1612 : bits 5 := subrange_vec_dec v__460 6 2 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rd))
                                     (projT1
                                      (regidx_to_regno zreg))))
                                 ((andb
                                     (projT1
                                      (neq_int (projT1 (regidx_to_regno rd))
                                         (projT1
                                          (regidx_to_regno sp))))
                                     (neq_vec (concat_vec imm17 imm1612)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5))))
                                  : bool))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     let rd : regidx := subrange_vec_dec v__460 11 7 in
     let imm17 : bits 1 := subrange_vec_dec v__460 12 12 in
     let imm1612 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_LUI
       ((concat_vec (imm17  : bits 1) (imm1612  : bits 5), rd))
   else if ((andb
               (let nzui5 : bits 1 := subrange_vec_dec v__460 12 12 in
               let nzui40 : bits 5 := subrange_vec_dec v__460 6 2 in
               neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
               (andb
                  (eq_vec (subrange_vec_dec v__460 15 13)
                     (vec_of_bits [B1;B0;B0]  : mword (15 - 13 + 1)))
                  (andb
                     (eq_vec (subrange_vec_dec v__460 11 10)
                        (vec_of_bits [B0;B0]  : mword (11 - 10 + 1)))
                     (eq_vec (subrange_vec_dec v__460 1 0)
                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let nzui5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let nzui40 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_SRLI
       ((concat_vec (nzui5  : bits 1) (nzui40  : bits 5), rsd))
   else if ((andb
               (let nzui5 : bits 1 := subrange_vec_dec v__460 12 12 in
               let nzui40 : bits 5 := subrange_vec_dec v__460 6 2 in
               neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
               (andb
                  (eq_vec (subrange_vec_dec v__460 15 13)
                     (vec_of_bits [B1;B0;B0]  : mword (15 - 13 + 1)))
                  (andb
                     (eq_vec (subrange_vec_dec v__460 11 10)
                        (vec_of_bits [B0;B1]  : mword (11 - 10 + 1)))
                     (eq_vec (subrange_vec_dec v__460 1 0)
                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let nzui5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let nzui40 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_SRAI
       ((concat_vec (nzui5  : bits 1) (nzui40  : bits 5), rsd))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 13)
                  (vec_of_bits [B1;B0;B0]  : mword (15 - 13 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__460 11 10)
                     (vec_of_bits [B1;B0]  : mword (11 - 10 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let i5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let i40 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_ANDI
       ((concat_vec (i5  : bits 1) (i40  : bits 5), rsd))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__460 6 5) (vec_of_bits [B0;B0]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let rs2 : cregidx := subrange_vec_dec v__460 4 2 in
     C_SUB
       ((rsd, rs2))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__460 6 5) (vec_of_bits [B0;B1]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let rs2 : cregidx := subrange_vec_dec v__460 4 2 in
     C_XOR
       ((rsd, rs2))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__460 6 5) (vec_of_bits [B1;B0]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let rs2 : cregidx := subrange_vec_dec v__460 4 2 in
     C_OR
       ((rsd, rs2))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__460 6 5) (vec_of_bits [B1;B1]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let rs2 : cregidx := subrange_vec_dec v__460 4 2 in
     C_AND
       ((rsd, rs2))
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 10)
                                     (vec_of_bits [B1;B0;B0;B1;B1;B1]  : mword (15 - 10 + 1)))
                                  (andb
                                     (eq_vec (subrange_vec_dec v__460 6 5)
                                        (vec_of_bits [B0;B0]  : mword (6 - 5 + 1)))
                                     (eq_vec (subrange_vec_dec v__460 1 0)
                                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let rs2 : cregidx := subrange_vec_dec v__460 4 2 in
     C_SUBW
       ((rsd, rs2))
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 10)
                                     (vec_of_bits [B1;B0;B0;B1;B1;B1]  : mword (15 - 10 + 1)))
                                  (andb
                                     (eq_vec (subrange_vec_dec v__460 6 5)
                                        (vec_of_bits [B0;B1]  : mword (6 - 5 + 1)))
                                     (eq_vec (subrange_vec_dec v__460 1 0)
                                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     let rsd : cregidx := subrange_vec_dec v__460 9 7 in
     let rs2 : cregidx := subrange_vec_dec v__460 4 2 in
     C_ADDW
       ((rsd, rs2))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 13)
                  (vec_of_bits [B1;B0;B1]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
   then
     let i98 : bits 2 := subrange_vec_dec v__460 10 9 in
     let i7 : bits 1 := subrange_vec_dec v__460 6 6 in
     let i6 : bits 1 := subrange_vec_dec v__460 7 7 in
     let i5 : bits 1 := subrange_vec_dec v__460 2 2 in
     let i4 : bits 1 := subrange_vec_dec v__460 11 11 in
     let i31 : bits 3 := subrange_vec_dec v__460 5 3 in
     let i11 : bits 1 := subrange_vec_dec v__460 12 12 in
     let i10 : bits 1 := subrange_vec_dec v__460 8 8 in
     C_J
       (concat_vec (i11  : bits 1)
          (concat_vec (i10  : bits 1)
             (concat_vec (i98  : bits 2)
                (concat_vec (i7  : bits 1)
                   (concat_vec (i6  : bits 1)
                      (concat_vec (i5  : bits 1) (concat_vec (i4  : bits 1) (i31  : bits 3))))))))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 13)
                  (vec_of_bits [B1;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
   then
     let rs : cregidx := subrange_vec_dec v__460 9 7 in
     let i8 : bits 1 := subrange_vec_dec v__460 12 12 in
     let i76 : bits 2 := subrange_vec_dec v__460 6 5 in
     let i5 : bits 1 := subrange_vec_dec v__460 2 2 in
     let i43 : bits 2 := subrange_vec_dec v__460 11 10 in
     let i21 : bits 2 := subrange_vec_dec v__460 4 3 in
     C_BEQZ
       ((concat_vec (i8  : bits 1)
           (concat_vec (i76  : bits 2)
              (concat_vec (i5  : bits 1) (concat_vec (i43  : bits 2) (i21  : bits 2)))), rs))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 13)
                  (vec_of_bits [B1;B1;B1]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
   then
     let rs : cregidx := subrange_vec_dec v__460 9 7 in
     let i8 : bits 1 := subrange_vec_dec v__460 12 12 in
     let i76 : bits 2 := subrange_vec_dec v__460 6 5 in
     let i5 : bits 1 := subrange_vec_dec v__460 2 2 in
     let i43 : bits 2 := subrange_vec_dec v__460 11 10 in
     let i21 : bits 2 := subrange_vec_dec v__460 4 3 in
     C_BNEZ
       ((concat_vec (i8  : bits 1)
           (concat_vec (i76  : bits 2)
              (concat_vec (i5  : bits 1) (concat_vec (i43  : bits 2) (i21  : bits 2)))), rs))
   else if ((andb
               (let rsd : regidx := subrange_vec_dec v__460 11 7 in
               let nzui5 : bits 1 := subrange_vec_dec v__460 12 12 in
               let nzui40 : bits 5 := subrange_vec_dec v__460 6 2 in
               andb
                 (neq_vec (concat_vec nzui5 nzui40)
                    (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
                 ((andb
                     (projT1
                      (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
                     (orb (Z.eqb 64 64) (eq_vec nzui5 ((bool_to_bits false)  : mword 1))))
                  : bool))
               (andb
                  (eq_vec (subrange_vec_dec v__460 15 13)
                     (vec_of_bits [B0;B0;B0]  : mword (15 - 13 + 1)))
                  (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1))))))
   then
     let rsd : regidx := subrange_vec_dec v__460 11 7 in
     let nzui5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let nzui40 : bits 5 := subrange_vec_dec v__460 6 2 in
     C_SLLI
       ((concat_vec (nzui5  : bits 1) (nzui40  : bits 5), rsd))
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__460 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rd))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B0;B1;B0]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     let ui76 : bits 2 := subrange_vec_dec v__460 3 2 in
     let ui5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let ui42 : bits 3 := subrange_vec_dec v__460 6 4 in
     let rd : regidx := subrange_vec_dec v__460 11 7 in
     C_LWSP
       ((concat_vec (ui76  : bits 2) (concat_vec (ui5  : bits 1) (ui42  : bits 3)), rd))
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__460 11 7 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rd))
                                     (projT1
                                      (regidx_to_regno zreg)))) (Z.eqb 64 64))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     let ui86 : bits 3 := subrange_vec_dec v__460 4 2 in
     let ui5 : bits 1 := subrange_vec_dec v__460 12 12 in
     let ui43 : bits 2 := subrange_vec_dec v__460 6 5 in
     let rd : regidx := subrange_vec_dec v__460 11 7 in
     C_LDSP
       ((concat_vec (ui86  : bits 3) (concat_vec (ui5  : bits 1) (ui43  : bits 2)), rd))
   else if ((andb
               (eq_vec (subrange_vec_dec v__460 15 13)
                  (vec_of_bits [B1;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__460 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))
   then
     let ui76 : bits 2 := subrange_vec_dec v__460 8 7 in
     let ui52 : bits 4 := subrange_vec_dec v__460 12 9 in
     let rs2 : regidx := subrange_vec_dec v__460 6 2 in
     C_SWSP
       ((concat_vec (ui76  : bits 2) (ui52  : bits 4), rs2))
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 13)
                                     (vec_of_bits [B1;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     let ui86 : bits 3 := subrange_vec_dec v__460 9 7 in
     let ui53 : bits 3 := subrange_vec_dec v__460 12 10 in
     let rs2 : regidx := subrange_vec_dec v__460 6 2 in
     C_SDSP
       ((concat_vec (ui86  : bits 3) (ui53  : bits 3), rs2))
   else if sumbool_of_bool ((andb
                               (let rs1 : regidx := subrange_vec_dec v__460 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rs1))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 12)
                                     (vec_of_bits [B1;B0;B0;B0]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 6 0)
                                     (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  : mword (6 - 0 + 1))))))
   then
     let rs1 : regidx := subrange_vec_dec v__460 11 7 in
     C_JR
       (rs1)
   else if sumbool_of_bool ((andb
                               (let rs1 : regidx := subrange_vec_dec v__460 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rs1))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 12)
                                     (vec_of_bits [B1;B0;B0;B1]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 6 0)
                                     (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  : mword (6 - 0 + 1))))))
   then
     let rs1 : regidx := subrange_vec_dec v__460 11 7 in
     C_JALR
       (rs1)
   else if sumbool_of_bool ((andb
                               (let rs2 : regidx := subrange_vec_dec v__460 6 2 in
                               let rd : regidx := subrange_vec_dec v__460 11 7 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rd))
                                     (projT1
                                      (regidx_to_regno zreg))))
                                 ((projT1
                                   (neq_int (projT1 (regidx_to_regno rs2))
                                      (projT1
                                       (regidx_to_regno zreg))))
                                  : bool))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 12)
                                     (vec_of_bits [B1;B0;B0;B0]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     let rs2 : regidx := subrange_vec_dec v__460 6 2 in
     let rd : regidx := subrange_vec_dec v__460 11 7 in
     C_MV
       ((rd, rs2))
   else if ((eq_vec v__460
               (vec_of_bits [B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 16))) then
     C_EBREAK
       (tt)
   else if sumbool_of_bool ((andb
                               (let rsd : regidx := subrange_vec_dec v__460 11 7 in
                               let rs2 : regidx := subrange_vec_dec v__460 6 2 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rsd))
                                     (projT1
                                      (regidx_to_regno zreg))))
                                 ((projT1
                                   (neq_int (projT1 (regidx_to_regno rs2))
                                      (projT1
                                       (regidx_to_regno zreg))))
                                  : bool))
                               (andb
                                  (eq_vec (subrange_vec_dec v__460 15 12)
                                     (vec_of_bits [B1;B0;B0;B1]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__460 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     let rsd : regidx := subrange_vec_dec v__460 11 7 in
     let rs2 : regidx := subrange_vec_dec v__460 6 2 in
     C_ADD
       ((rsd, rs2))
   else C_ILLEGAL (v__460).

Definition encdec_compressed_forwards_matches (arg_ : ast) 
: bool :=
   
   match arg_ with
   | C_NOP (tt) => true
   | C_ADDI4SPN ((rd, v__596)) =>
      if ((let nz96 : bits 4 := subrange_vec_dec v__596 7 4 in
        let nz96 : bits 4 := subrange_vec_dec v__596 7 4 in
        let nz54 : bits 2 := subrange_vec_dec v__596 3 2 in
        let nz3 : bits 1 := subrange_vec_dec v__596 1 1 in
        let nz2 : bits 1 := subrange_vec_dec v__596 0 0 in
        neq_vec (concat_vec nz96 (concat_vec nz54 (concat_vec nz3 nz2)))
          (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword (4 + (2 + (1 + 1)))))) then
        true
      else false
   | C_LW ((v__597, rs1, rd)) => true
   | C_LD ((v__598, rs1, rd)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_SW ((v__599, rs1, rs2)) => true
   | C_SD ((v__600, rs1, rs2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_ADDI ((v__601, rsd)) =>
      if ((let nzi5 : bits 1 := subrange_vec_dec v__601 5 5 in
        let nzi5 : bits 1 := subrange_vec_dec v__601 5 5 in
        let nzi40 : bits 5 := subrange_vec_dec v__601 4 0 in
        andb (neq_vec (concat_vec nzi5 nzi40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
          ((projT1
            (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
           : bool))) then
        true
      else false
   | C_JAL (v__602) => if sumbool_of_bool ((Z.eqb 64 32)) then true else false
   | C_ADDIW ((v__603, rsd)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rsd))
                                 (projT1
                                  (regidx_to_regno zreg)))) (Z.eqb 64 64))) then
        true
      else false
   | C_LI ((v__604, rd)) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_ADDI16SP (v__605) =>
      if ((let nzi9 : bits 1 := subrange_vec_dec v__605 5 5 in
        let nzi9 : bits 1 := subrange_vec_dec v__605 5 5 in
        let nzi87 : bits 2 := subrange_vec_dec v__605 4 3 in
        let nzi6 : bits 1 := subrange_vec_dec v__605 2 2 in
        let nzi5 : bits 1 := subrange_vec_dec v__605 1 1 in
        let nzi4 : bits 1 := subrange_vec_dec v__605 0 0 in
        neq_vec (concat_vec nzi9 (concat_vec nzi87 (concat_vec nzi6 (concat_vec nzi5 nzi4))))
          (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + (2 + (1 + (1 + 1))))))) then
        true
      else false
   | C_LUI ((v__606, rd)) =>
      if sumbool_of_bool ((let imm17 : bits 1 := subrange_vec_dec v__606 5 5 in
        let imm17 : bits 1 := subrange_vec_dec v__606 5 5 in
        let imm1612 : bits 5 := subrange_vec_dec v__606 4 0 in
        andb (projT1 (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg))))
          ((andb (projT1 (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno sp))))
              (neq_vec (concat_vec imm17 imm1612) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5))))
           : bool))) then
        true
      else false
   | C_SRLI ((v__607, rsd)) =>
      if ((let nzui5 : bits 1 := subrange_vec_dec v__607 5 5 in
        let nzui5 : bits 1 := subrange_vec_dec v__607 5 5 in
        let nzui40 : bits 5 := subrange_vec_dec v__607 4 0 in
        neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))) then
        true
      else false
   | C_SRAI ((v__608, rsd)) =>
      if ((let nzui5 : bits 1 := subrange_vec_dec v__608 5 5 in
        let nzui5 : bits 1 := subrange_vec_dec v__608 5 5 in
        let nzui40 : bits 5 := subrange_vec_dec v__608 4 0 in
        neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))) then
        true
      else false
   | C_ANDI ((v__609, rsd)) => true
   | C_SUB ((rsd, rs2)) => true
   | C_XOR ((rsd, rs2)) => true
   | C_OR ((rsd, rs2)) => true
   | C_AND ((rsd, rs2)) => true
   | C_SUBW ((rsd, rs2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_ADDW ((rsd, rs2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_J (v__610) => true
   | C_BEQZ ((v__611, rs)) => true
   | C_BNEZ ((v__612, rs)) => true
   | C_SLLI ((v__613, rsd)) =>
      if ((let nzui5 : bits 1 := subrange_vec_dec v__613 5 5 in
        let nzui5 : bits 1 := subrange_vec_dec v__613 5 5 in
        let nzui40 : bits 5 := subrange_vec_dec v__613 4 0 in
        andb (neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
          ((andb (projT1 (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
              (orb (Z.eqb 64 64) (eq_vec nzui5 ((bool_to_bits false)  : mword 1))))
           : bool))) then
        true
      else false
   | C_LWSP ((v__614, rd)) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_LDSP ((v__615, rd)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg))))
                             (Z.eqb 64 64))) then
        true
      else false
   | C_SWSP ((v__616, rs2)) => true
   | C_SDSP ((v__617, rs2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_JR (rs1) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_JALR (rs1) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_MV ((rd, rs2)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg))))
                             ((projT1
                               (neq_int (projT1 (regidx_to_regno rs2))
                                  (projT1
                                   (regidx_to_regno zreg))))
                              : bool))) then
        true
      else false
   | C_EBREAK (tt) => true
   | C_ADD ((rsd, rs2)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rsd))
                                 (projT1
                                  (regidx_to_regno zreg))))
                             ((projT1
                               (neq_int (projT1 (regidx_to_regno rs2))
                                  (projT1
                                   (regidx_to_regno zreg))))
                              : bool))) then
        true
      else false
   | C_ILLEGAL (s) => true
   | _ => false
   end.

Definition encdec_compressed_backwards_matches (arg_ : mword 16) 
: bool :=
   
   let v__618 := arg_ in
   if ((eq_vec v__618 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  : mword 16)))
   then
     true
   else if ((andb
               (let nz96 : bits 4 := subrange_vec_dec v__618 10 7 in
               let nz54 : bits 2 := subrange_vec_dec v__618 12 11 in
               let nz3 : bits 1 := subrange_vec_dec v__618 5 5 in
               let nz2 : bits 1 := subrange_vec_dec v__618 6 6 in
               neq_vec (concat_vec nz96 (concat_vec nz54 (concat_vec nz3 nz2)))
                 (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword (4 + (2 + (1 + 1)))))
               (andb
                  (eq_vec (subrange_vec_dec v__618 15 13)
                     (vec_of_bits [B0;B0;B0]  : mword (15 - 13 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))))
   then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 13)
                  (vec_of_bits [B0;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))
   then
     true
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 13)
                  (vec_of_bits [B1;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))
   then
     true
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B1;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))))) then
     true
   else if ((andb
               (let rsd : regidx := subrange_vec_dec v__618 11 7 in
               let nzi5 : bits 1 := subrange_vec_dec v__618 12 12 in
               let nzi40 : bits 5 := subrange_vec_dec v__618 6 2 in
               andb
                 (neq_vec (concat_vec nzi5 nzi40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
                 ((projT1
                   (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
                  : bool))
               (andb
                  (eq_vec (subrange_vec_dec v__618 15 13)
                     (vec_of_bits [B0;B0;B0]  : mword (15 - 13 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     true
   else if sumbool_of_bool ((andb (Z.eqb 64 32)
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B0;B0;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     true
   else if sumbool_of_bool ((andb
                               (let rsd : regidx := subrange_vec_dec v__618 11 7 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rsd))
                                     (projT1
                                      (regidx_to_regno zreg)))) (Z.eqb 64 64))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B0;B0;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     true
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__618 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rd))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B0;B1;B0]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     true
   else if ((andb
               (let nzi9 : bits 1 := subrange_vec_dec v__618 12 12 in
               let nzi87 : bits 2 := subrange_vec_dec v__618 4 3 in
               let nzi6 : bits 1 := subrange_vec_dec v__618 5 5 in
               let nzi5 : bits 1 := subrange_vec_dec v__618 2 2 in
               let nzi4 : bits 1 := subrange_vec_dec v__618 6 6 in
               neq_vec (concat_vec nzi9 (concat_vec nzi87 (concat_vec nzi6 (concat_vec nzi5 nzi4))))
                 (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + (2 + (1 + (1 + 1))))))
               (andb
                  (eq_vec (subrange_vec_dec v__618 15 13)
                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                  (andb
                     (eq_vec (subrange_vec_dec v__618 11 7)
                        (vec_of_bits [B0;B0;B0;B1;B0]  : mword (11 - 7 + 1)))
                     (eq_vec (subrange_vec_dec v__618 1 0)
                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     true
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__618 11 7 in
                               let imm17 : bits 1 := subrange_vec_dec v__618 12 12 in
                               let imm1612 : bits 5 := subrange_vec_dec v__618 6 2 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rd))
                                     (projT1
                                      (regidx_to_regno zreg))))
                                 ((andb
                                     (projT1
                                      (neq_int (projT1 (regidx_to_regno rd))
                                         (projT1
                                          (regidx_to_regno sp))))
                                     (neq_vec (concat_vec imm17 imm1612)
                                        (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5))))
                                  : bool))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))) then
     true
   else if ((andb
               (let nzui5 : bits 1 := subrange_vec_dec v__618 12 12 in
               let nzui40 : bits 5 := subrange_vec_dec v__618 6 2 in
               neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
               (andb
                  (eq_vec (subrange_vec_dec v__618 15 13)
                     (vec_of_bits [B1;B0;B0]  : mword (15 - 13 + 1)))
                  (andb
                     (eq_vec (subrange_vec_dec v__618 11 10)
                        (vec_of_bits [B0;B0]  : mword (11 - 10 + 1)))
                     (eq_vec (subrange_vec_dec v__618 1 0)
                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     true
   else if ((andb
               (let nzui5 : bits 1 := subrange_vec_dec v__618 12 12 in
               let nzui40 : bits 5 := subrange_vec_dec v__618 6 2 in
               neq_vec (concat_vec nzui5 nzui40) (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
               (andb
                  (eq_vec (subrange_vec_dec v__618 15 13)
                     (vec_of_bits [B1;B0;B0]  : mword (15 - 13 + 1)))
                  (andb
                     (eq_vec (subrange_vec_dec v__618 11 10)
                        (vec_of_bits [B0;B1]  : mword (11 - 10 + 1)))
                     (eq_vec (subrange_vec_dec v__618 1 0)
                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 13)
                  (vec_of_bits [B1;B0;B0]  : mword (15 - 13 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__618 11 10)
                     (vec_of_bits [B1;B0]  : mword (11 - 10 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__618 6 5) (vec_of_bits [B0;B0]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__618 6 5) (vec_of_bits [B0;B1]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__618 6 5) (vec_of_bits [B1;B0]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 10)
                  (vec_of_bits [B1;B0;B0;B0;B1;B1]  : mword (15 - 10 + 1)))
               (andb
                  (eq_vec (subrange_vec_dec v__618 6 5) (vec_of_bits [B1;B1]  : mword (6 - 5 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))
   then
     true
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 10)
                                     (vec_of_bits [B1;B0;B0;B1;B1;B1]  : mword (15 - 10 + 1)))
                                  (andb
                                     (eq_vec (subrange_vec_dec v__618 6 5)
                                        (vec_of_bits [B0;B0]  : mword (6 - 5 + 1)))
                                     (eq_vec (subrange_vec_dec v__618 1 0)
                                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     true
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 10)
                                     (vec_of_bits [B1;B0;B0;B1;B1;B1]  : mword (15 - 10 + 1)))
                                  (andb
                                     (eq_vec (subrange_vec_dec v__618 6 5)
                                        (vec_of_bits [B0;B1]  : mword (6 - 5 + 1)))
                                     (eq_vec (subrange_vec_dec v__618 1 0)
                                        (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 13)
                  (vec_of_bits [B1;B0;B1]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
   then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 13)
                  (vec_of_bits [B1;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
   then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 13)
                  (vec_of_bits [B1;B1;B1]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
   then
     true
   else if ((andb
               (let rsd : regidx := subrange_vec_dec v__618 11 7 in
               let nzui5 : bits 1 := subrange_vec_dec v__618 12 12 in
               let nzui40 : bits 5 := subrange_vec_dec v__618 6 2 in
               andb
                 (neq_vec (concat_vec nzui5 nzui40)
                    (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword (1 + 5)))
                 ((andb
                     (projT1
                      (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
                     (orb (Z.eqb 64 64) (eq_vec nzui5 ((bool_to_bits false)  : mword 1))))
                  : bool))
               (andb
                  (eq_vec (subrange_vec_dec v__618 15 13)
                     (vec_of_bits [B0;B0;B0]  : mword (15 - 13 + 1)))
                  (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1))))))
   then
     true
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__618 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rd))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B0;B1;B0]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     true
   else if sumbool_of_bool ((andb
                               (let rd : regidx := subrange_vec_dec v__618 11 7 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rd))
                                     (projT1
                                      (regidx_to_regno zreg)))) (Z.eqb 64 64))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B0;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     true
   else if ((andb
               (eq_vec (subrange_vec_dec v__618 15 13)
                  (vec_of_bits [B1;B1;B0]  : mword (15 - 13 + 1)))
               (eq_vec (subrange_vec_dec v__618 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))
   then
     true
   else if sumbool_of_bool ((andb (Z.eqb 64 64)
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 13)
                                     (vec_of_bits [B1;B1;B1]  : mword (15 - 13 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     true
   else if sumbool_of_bool ((andb
                               (let rs1 : regidx := subrange_vec_dec v__618 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rs1))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 12)
                                     (vec_of_bits [B1;B0;B0;B0]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 6 0)
                                     (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  : mword (6 - 0 + 1))))))
   then
     true
   else if sumbool_of_bool ((andb
                               (let rs1 : regidx := subrange_vec_dec v__618 11 7 in
                               projT1
                               (neq_int (projT1 (regidx_to_regno rs1))
                                  (projT1
                                   (regidx_to_regno zreg))))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 12)
                                     (vec_of_bits [B1;B0;B0;B1]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 6 0)
                                     (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  : mword (6 - 0 + 1))))))
   then
     true
   else if sumbool_of_bool ((andb
                               (let rs2 : regidx := subrange_vec_dec v__618 6 2 in
                               let rd : regidx := subrange_vec_dec v__618 11 7 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rd))
                                     (projT1
                                      (regidx_to_regno zreg))))
                                 ((projT1
                                   (neq_int (projT1 (regidx_to_regno rs2))
                                      (projT1
                                       (regidx_to_regno zreg))))
                                  : bool))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 12)
                                     (vec_of_bits [B1;B0;B0;B0]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     true
   else if ((eq_vec v__618
               (vec_of_bits [B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  : mword 16))) then
     true
   else if sumbool_of_bool ((andb
                               (let rsd : regidx := subrange_vec_dec v__618 11 7 in
                               let rs2 : regidx := subrange_vec_dec v__618 6 2 in
                               andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rsd))
                                     (projT1
                                      (regidx_to_regno zreg))))
                                 ((projT1
                                   (neq_int (projT1 (regidx_to_regno rs2))
                                      (projT1
                                       (regidx_to_regno zreg))))
                                  : bool))
                               (andb
                                  (eq_vec (subrange_vec_dec v__618 15 12)
                                     (vec_of_bits [B1;B0;B0;B1]  : mword (15 - 12 + 1)))
                                  (eq_vec (subrange_vec_dec v__618 1 0)
                                     (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))) then
     true
   else true.

Definition execute_WFI '(tt : unit) 
: M (Retired) :=
   
   read_reg cur_privilege_ref >>= fun w__0 : Privilege =>
   (match w__0 with
    | Machine => (platform_wfi tt) >> returnm (RETIRE_SUCCESS  : Retired)
    | Supervisor =>
       read_reg mstatus_ref >>= fun w__1 : Mstatus =>
       (if ((eq_vec (_get_Mstatus_TW w__1) ((bool_to_bits true)  : mword 1))) then
          (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired)
        else (platform_wfi tt) >> returnm (RETIRE_SUCCESS  : Retired))
        : M (Retired)
    | User => (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired)
    end)
    : M (Retired).

Definition execute_UTYPE (imm : mword 20) (rd : mword 5) (op : uop) 
: M (Retired) :=
   
   let off : xlenbits :=
     EXTS 64 (concat_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  : mword 12)) in
   (match op with
    | RISCV_LUI => returnm (off  : mword 64)
    | RISCV_AUIPC =>
       (get_arch_pc tt) >>= fun w__0 : mword 64 => returnm ((add_vec w__0 off)  : mword 64)
    end) >>= fun ret : xlenbits =>
   (wX (projT1 (regidx_to_regno rd)) ret) >> returnm (RETIRE_SUCCESS  : Retired).

Definition execute_URET '(tt : unit) 
: M (Retired) :=
   
   (haveUsrMode tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool ((negb w__0)) then (handle_illegal tt)  : M (unit)
    else
      read_reg cur_privilege_ref >>= fun w__1 : Privilege =>
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
      (exception_handler w__1 (CTL_URET (tt)) w__2) >>= fun w__3 : mword 64 =>
      (set_next_pc w__3)
       : M (unit)) >>
   returnm (RETIRE_FAIL
    : Retired).

Definition execute_STORECON
(aq : bool) (rl : bool) (rs2 : mword 5) (rs1 : mword 5) (width : word_width) (rd : mword 5) 
: M (Retired) :=
   
   (speculate_conditional tt) >>= fun w__0 : bool =>
   (if ((Bool.eqb w__0 false)) then
      (wX (projT1 (regidx_to_regno rd)) (EXTZ 64 (vec_of_bits [B1]  : mword 1))) >>
      returnm (RETIRE_SUCCESS
       : Retired)
    else
      (haveAtomics tt) >>= fun w__1 : bool =>
      (if sumbool_of_bool (w__1) then
         (ext_data_get_addr rs1 (zeros_implicit 64) Write width) >>= fun w__2 : Ext_DataAddr_Check unit =>
         (match w__2 with
          | Ext_DataAddr_Error (e) =>
             let '_ := (ext_handle_data_check_error e)  : unit in
             returnm (RETIRE_FAIL
              : Retired)
          | Ext_DataAddr_OK (vaddr) =>
             (match width with
              | BYTE =>
                 returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
              | HALF =>
                 (cast_unit_vec (access_vec_dec vaddr 0)) >>= fun w__3 : mword 1 =>
                 returnm ((eq_vec w__3 (vec_of_bits [B0]  : mword 1))
                  : bool)
              | WORD =>
                 returnm ((eq_vec (subrange_vec_dec vaddr 1 0)
                             (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))
                  : bool)
              | DOUBLE =>
                 returnm ((eq_vec (subrange_vec_dec vaddr 2 0)
                             (vec_of_bits [B0;B0;B0]  : mword (2 - 0 + 1)))
                  : bool)
              end) >>= fun aligned : bool =>
             (if sumbool_of_bool ((negb aligned)) then
                (handle_mem_exception vaddr E_SAMO_Addr_Align) >> returnm (RETIRE_FAIL  : Retired)
              else if ((Bool.eqb (match_reservation vaddr) false)) then
                (wX (projT1 (regidx_to_regno rd)) (EXTZ 64 (vec_of_bits [B1]  : mword 1))) >>
                let '_ := (cancel_reservation tt)  : unit in
                returnm (RETIRE_SUCCESS
                 : Retired)
              else
                (translateAddr vaddr Write) >>= fun w__4 : TR_Result (mword 64) ExceptionType =>
                (match w__4 with
                 | TR_Failure (e) =>
                    (handle_mem_exception vaddr e) >> returnm (RETIRE_FAIL  : Retired)
                 | TR_Address (addr) =>
                    (match (width, 64) with
                     | (WORD, g__217) => (mem_write_ea addr 4 aq rl true)  : M (MemoryOpResult unit)
                     | (DOUBLE, l__4) =>
                        (if sumbool_of_bool ((Z.eqb l__4 64)) then
                           (mem_write_ea addr 8 aq rl true)
                            : M (MemoryOpResult unit)
                         else
                           (internal_error "STORECON expected word or double")
                            : M (MemoryOpResult unit))
                         : M (MemoryOpResult unit)
                     | _ =>
                        (internal_error "STORECON expected word or double")
                         : M (MemoryOpResult unit)
                     end) >>= fun eares : MemoryOpResult unit =>
                    (match eares with
                     | MemException (e) =>
                        (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
                     | MemValue (_) =>
                        (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val =>
                        (match (width, 64) with
                         | (WORD, g__216) =>
                            (mem_write_value addr 4 (subrange_vec_dec rs2_val 31 0) aq rl true)
                             : M (MemoryOpResult bool)
                         | (DOUBLE, l__3) =>
                            (if sumbool_of_bool ((Z.eqb l__3 64)) then
                               (mem_write_value addr 8 rs2_val aq rl true)
                                : M (MemoryOpResult bool)
                             else
                               (internal_error "STORECON expected word or double")
                                : M (MemoryOpResult bool))
                             : M (MemoryOpResult bool)
                         | _ =>
                            (internal_error "STORECON expected word or double")
                             : M (MemoryOpResult bool)
                         end) >>= fun res : MemoryOpResult bool =>
                        (match res with
                         | MemValue (true) =>
                            (wX (projT1 (regidx_to_regno rd))
                               (EXTZ 64 (vec_of_bits [B0]  : mword 1))) >>
                            let '_ := (cancel_reservation tt)  : unit in
                            returnm (RETIRE_SUCCESS
                             : Retired)
                         | MemValue (false) =>
                            (wX (projT1 (regidx_to_regno rd))
                               (EXTZ 64 (vec_of_bits [B1]  : mword 1))) >>
                            let '_ := (cancel_reservation tt)  : unit in
                            returnm (RETIRE_SUCCESS
                             : Retired)
                         | MemException (e) =>
                            (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
                         end)
                         : M (Retired)
                     end)
                     : M (Retired)
                 end)
                 : M (Retired))
              : M (Retired)
          end)
          : M (Retired)
       else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
       : M (Retired))
    : M (Retired).

Definition execute_STORE
(imm : mword 12) (rs2 : mword 5) (rs1 : mword 5) (width : word_width) (aq : bool) (rl : bool) 
: M (Retired) :=
   
   let offset : xlenbits := EXTS 64 imm in
   (ext_data_get_addr rs1 offset Write width) >>= fun w__0 : Ext_DataAddr_Check unit =>
   (match w__0 with
    | Ext_DataAddr_Error (e) =>
       let '_ := (ext_handle_data_check_error e)  : unit in
       returnm (RETIRE_FAIL
        : Retired)
    | Ext_DataAddr_OK (vaddr) =>
       (check_misaligned vaddr width) >>= fun w__1 : bool =>
       (if sumbool_of_bool (w__1) then
          (handle_mem_exception vaddr E_SAMO_Addr_Align) >> returnm (RETIRE_FAIL  : Retired)
        else
          (translateAddr vaddr Write) >>= fun w__2 : TR_Result (mword 64) ExceptionType =>
          (match w__2 with
           | TR_Failure (e) => (handle_mem_exception vaddr e) >> returnm (RETIRE_FAIL  : Retired)
           | TR_Address (addr) =>
              (match width with
               | BYTE => (mem_write_ea addr 1 aq rl false)  : M (MemoryOpResult unit)
               | HALF => (mem_write_ea addr 2 aq rl false)  : M (MemoryOpResult unit)
               | WORD => (mem_write_ea addr 4 aq rl false)  : M (MemoryOpResult unit)
               | DOUBLE => (mem_write_ea addr 8 aq rl false)  : M (MemoryOpResult unit)
               end) >>= fun eares : MemoryOpResult unit =>
              (match eares with
               | MemException (e) =>
                  (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
               | MemValue (_) =>
                  (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val =>
                  (match (width, 64) with
                   | (BYTE, g__210) =>
                      (mem_write_value addr 1 (subrange_vec_dec rs2_val 7 0) aq rl false)
                       : M (MemoryOpResult bool)
                   | (HALF, g__211) =>
                      (mem_write_value addr 2 (subrange_vec_dec rs2_val 15 0) aq rl false)
                       : M (MemoryOpResult bool)
                   | (WORD, g__212) =>
                      (mem_write_value addr 4 (subrange_vec_dec rs2_val 31 0) aq rl false)
                       : M (MemoryOpResult bool)
                   | (DOUBLE, l__1) =>
                      (if sumbool_of_bool ((Z.eqb l__1 64)) then
                         (mem_write_value addr 8 rs2_val aq rl false)
                          : M (MemoryOpResult bool)
                       else
                         assert_exp' false "Pattern match failure at model/riscv_insts_base.sail 394:47 - 399:15" >>= fun _ =>
                         exit tt)
                       : M (MemoryOpResult bool)
                   end) >>= fun res : MemoryOpResult bool =>
                  (match res with
                   | MemValue (true) => returnm (RETIRE_SUCCESS  : Retired)
                   | MemValue (false) =>
                      (internal_error "store got false from mem_write_value")  : M (Retired)
                   | MemException (e) =>
                      (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
                   end)
                   : M (Retired)
               end)
               : M (Retired)
           end)
           : M (Retired))
        : M (Retired)
    end)
    : M (Retired).

Definition execute_SRET '(tt : unit) 
: M (Retired) :=
   
   read_reg cur_privilege_ref >>= fun w__0 : Privilege =>
   (match w__0 with
    | User => (handle_illegal tt)  : M (unit)
    | Supervisor =>
       (or_boolM ((haveSupMode tt) >>= fun w__1 : bool => returnm ((negb w__1)  : bool))
          (read_reg mstatus_ref >>= fun w__2 : Mstatus =>
           returnm ((eq_vec (_get_Mstatus_TSR w__2) ((bool_to_bits true)  : mword 1))
            : bool))) >>= fun w__3 : bool =>
       (if sumbool_of_bool (w__3) then (handle_illegal tt)  : M (unit)
        else
          read_reg cur_privilege_ref >>= fun w__4 : Privilege =>
          ((read_reg PC_ref)  : M (mword 64)) >>= fun w__5 : mword 64 =>
          (exception_handler w__4 (CTL_SRET (tt)) w__5) >>= fun w__6 : mword 64 =>
          (set_next_pc w__6)
           : M (unit))
        : M (unit)
    | Machine =>
       (haveSupMode tt) >>= fun w__7 : bool =>
       (if sumbool_of_bool ((negb w__7)) then (handle_illegal tt)  : M (unit)
        else
          read_reg cur_privilege_ref >>= fun w__8 : Privilege =>
          ((read_reg PC_ref)  : M (mword 64)) >>= fun w__9 : mword 64 =>
          (exception_handler w__8 (CTL_SRET (tt)) w__9) >>= fun w__10 : mword 64 =>
          (set_next_pc w__10)
           : M (unit))
        : M (unit)
    end) >>
   returnm (RETIRE_FAIL
    : Retired).

Definition execute_SHIFTW (shamt : mword 5) (rs1 : mword 5) (rd : mword 5) (op : sop) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun w__0 : mword 64 =>
   let rs1_val := subrange_vec_dec w__0 31 0 in
   let result : bits 32 :=
     match op with
     | RISCV_SLLI => shift_bits_left rs1_val shamt
     | RISCV_SRLI => shift_bits_right rs1_val shamt
     | RISCV_SRAI => shift_right_arith32 rs1_val shamt
     end in
   (wX (projT1 (regidx_to_regno rd)) (EXTS 64 result)) >> returnm (RETIRE_SUCCESS  : Retired).

Definition execute_SHIFTIWOP (shamt : mword 5) (rs1 : mword 5) (rd : mword 5) (op : sopw) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
   let result : bits 32 :=
     match op with
     | RISCV_SLLIW => shift_bits_left (subrange_vec_dec rs1_val 31 0) shamt
     | RISCV_SRLIW => shift_bits_right (subrange_vec_dec rs1_val 31 0) shamt
     | RISCV_SRAIW => shift_right_arith32 (subrange_vec_dec rs1_val 31 0) shamt
     end in
   (wX (projT1 (regidx_to_regno rd)) (EXTS 64 result)) >> returnm (RETIRE_SUCCESS  : Retired).

Definition execute_SHIFTIOP (shamt : mword 6) (rs1 : mword 5) (rd : mword 5) (op : sop) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
   let result : xlenbits :=
     match op with
     | RISCV_SLLI => shift_bits_left rs1_val shamt
     | RISCV_SRLI => shift_bits_right rs1_val shamt
     | RISCV_SRAI => shift_right_arith64 rs1_val shamt
     end in
   (wX (projT1 (regidx_to_regno rd)) result) >> returnm (RETIRE_SUCCESS  : Retired).

Definition execute_SFENCE_VMA (rs1 : mword 5) (rs2 : mword 5) 
: M (Retired) :=
   
   (if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then
      returnm (None
       : option (mword 64))
    else
      (rX (projT1 (regidx_to_regno rs1))) >>= fun w__0 : mword 64 =>
      returnm ((Some
                  (w__0))
       : option (mword 64))) >>= fun addr : option xlenbits =>
   (if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs2)) 0)) then
      returnm (None
       : option (mword 64))
    else
      (rX (projT1 (regidx_to_regno rs2))) >>= fun w__1 : mword 64 =>
      returnm ((Some
                  (w__1))
       : option (mword 64))) >>= fun asid : option xlenbits =>
   read_reg cur_privilege_ref >>= fun w__2 : Privilege =>
   (match w__2 with
    | User => (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired)
    | Supervisor =>
       read_reg mstatus_ref >>= fun w__3 : Mstatus =>
       read_reg mstatus_ref >>= fun w__4 : Mstatus =>
       let p__214 := (architecture (get_mstatus_SXL w__3), _get_Mstatus_TVM w__4) in
       (match p__214 with
        | (Some (g__213), v_0) =>
           (if ((eq_vec v_0 ((bool_to_bits true)  : mword 1))) then
              (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired)
            else if ((eq_vec v_0 ((bool_to_bits false)  : mword 1))) then
              (flush_TLB asid addr) >> returnm (RETIRE_SUCCESS  : Retired)
            else
              (match (Some
                        (g__213), v_0) with
               | (_, _) => (internal_error "unimplemented sfence architecture")  : M (Retired)
               end)
               : M (Retired))
            : M (Retired)
        | (_, _) => (internal_error "unimplemented sfence architecture")  : M (Retired)
        end)
        : M (Retired)
    | Machine => (flush_TLB asid addr) >> returnm (RETIRE_SUCCESS  : Retired)
    end)
    : M (Retired).

Definition execute_RTYPEW (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (op : ropw) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun w__0 : mword 64 =>
   let rs1_val := subrange_vec_dec w__0 31 0 in
   (rX (projT1 (regidx_to_regno rs2))) >>= fun w__1 : mword 64 =>
   let rs2_val := subrange_vec_dec w__1 31 0 in
   let result : bits 32 :=
     match op with
     | RISCV_ADDW => add_vec rs1_val rs2_val
     | RISCV_SUBW => sub_vec rs1_val rs2_val
     | RISCV_SLLW => shift_bits_left rs1_val (subrange_vec_dec rs2_val 4 0)
     | RISCV_SRLW => shift_bits_right rs1_val (subrange_vec_dec rs2_val 4 0)
     | RISCV_SRAW => shift_right_arith32 rs1_val (subrange_vec_dec rs2_val 4 0)
     end in
   (wX (projT1 (regidx_to_regno rd)) (EXTS 64 result)) >> returnm (RETIRE_SUCCESS  : Retired).

Definition execute_RTYPE (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (op : rop) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
   (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val =>
   let result : xlenbits :=
     match op with
     | RISCV_ADD => add_vec rs1_val rs2_val
     | RISCV_SLT => EXTZ 64 (bool_to_bits (zopz0zI_s rs1_val rs2_val))
     | RISCV_SLTU => EXTZ 64 (bool_to_bits (zopz0zI_u rs1_val rs2_val))
     | RISCV_AND => and_vec rs1_val rs2_val
     | RISCV_OR => or_vec rs1_val rs2_val
     | RISCV_XOR => xor_vec rs1_val rs2_val
     | RISCV_SLL => shift_bits_left rs1_val (subrange_vec_dec rs2_val 5 0)
     | RISCV_SRL => shift_bits_right rs1_val (subrange_vec_dec rs2_val 5 0)
     | RISCV_SUB => sub_vec rs1_val rs2_val
     | RISCV_SRA => shift_right_arith64 rs1_val (subrange_vec_dec rs2_val 5 0)
     end in
   (wX (projT1 (regidx_to_regno rd)) result) >> returnm (RETIRE_SUCCESS  : Retired).

Definition execute_RISCV_JALR (imm : mword 12) (rs1 : mword 5) (rd : mword 5) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun w__0 : mword 64 =>
   let t : xlenbits := add_vec w__0 (EXTS 64 imm) in
   (match (ext_control_check_addr t) with
    | Ext_ControlAddr_Error (e) =>
       let '_ := (ext_handle_control_check_error e)  : unit in
       returnm (RETIRE_FAIL
        : Retired)
    | Ext_ControlAddr_OK (addr) =>
       let target := update_vec_dec addr 0 B0 in
       (and_boolM ((bit_to_bool (access_vec_dec target 1))  : M (bool))
          ((haveRVC tt) >>= fun w__2 : bool => returnm ((negb w__2)  : bool))) >>= fun w__3 : bool =>
       (if sumbool_of_bool (w__3) then
          (handle_mem_exception target E_Fetch_Addr_Align) >> returnm (RETIRE_FAIL  : Retired)
        else
          (get_next_pc tt) >>= fun w__4 : mword 64 =>
          (wX (projT1 (regidx_to_regno rd)) w__4) >>
          (set_next_pc target) >> returnm (RETIRE_SUCCESS  : Retired))
        : M (Retired)
    end)
    : M (Retired).

Definition execute_RISCV_JAL (imm : mword 21) (rd : mword 5) 
: M (Retired) :=
   
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   let t : xlenbits := add_vec w__0 (EXTS 64 imm) in
   (match (ext_control_check_pc t) with
    | Ext_ControlAddr_Error (e) =>
       let '_ := (ext_handle_control_check_error e)  : unit in
       returnm (RETIRE_FAIL
        : Retired)
    | Ext_ControlAddr_OK (target) =>
       (and_boolM ((bit_to_bool (access_vec_dec target 1))  : M (bool))
          ((haveRVC tt) >>= fun w__2 : bool => returnm ((negb w__2)  : bool))) >>= fun w__3 : bool =>
       (if sumbool_of_bool (w__3) then
          (handle_mem_exception target E_Fetch_Addr_Align) >> returnm (RETIRE_FAIL  : Retired)
        else
          (get_next_pc tt) >>= fun w__4 : mword 64 =>
          (wX (projT1 (regidx_to_regno rd)) w__4) >>
          (set_next_pc target) >> returnm (RETIRE_SUCCESS  : Retired))
        : M (Retired)
    end)
    : M (Retired).

Definition execute_REMW (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (s : bool) 
: M (Retired) :=
   
   (haveMulDiv tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (rX (projT1 (regidx_to_regno rs1))) >>= fun w__1 : mword 64 =>
      let rs1_val := subrange_vec_dec w__1 31 0 in
      (rX (projT1 (regidx_to_regno rs2))) >>= fun w__2 : mword 64 =>
      let rs2_val := subrange_vec_dec w__2 31 0 in
      let rs1_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs1_val)
        else projT1 (uint rs1_val) in
      let rs2_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs2_val)
        else projT1 (uint rs2_val) in
      let r : Z := if sumbool_of_bool ((Z.eqb rs2_int 0)) then rs1_int else Z.rem rs1_int rs2_int in
      (wX (projT1 (regidx_to_regno rd)) (EXTS 64 (to_bits 32 r))) >>
      returnm (RETIRE_SUCCESS
       : Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_REM (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (s : bool) 
: M (Retired) :=
   
   (haveMulDiv tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
      (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val =>
      let rs1_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs1_val)
        else projT1 (uint rs1_val) in
      let rs2_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs2_val)
        else projT1 (uint rs2_val) in
      let r : Z := if sumbool_of_bool ((Z.eqb rs2_int 0)) then rs1_int else Z.rem rs1_int rs2_int in
      (wX (projT1 (regidx_to_regno rd)) (to_bits 64 r)) >> returnm (RETIRE_SUCCESS  : Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_MULW (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) 
: M (Retired) :=
   
   (haveMulDiv tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (rX (projT1 (regidx_to_regno rs1))) >>= fun w__1 : mword 64 =>
      let rs1_val := subrange_vec_dec w__1 31 0 in
      (rX (projT1 (regidx_to_regno rs2))) >>= fun w__2 : mword 64 =>
      let rs2_val := subrange_vec_dec w__2 31 0 in
      let rs1_int : Z := projT1 (sint rs1_val) in
      let rs2_int : Z := projT1 (sint rs2_val) in
      let result32 := subrange_vec_dec (to_bits 64 (Z.mul rs1_int rs2_int)) 31 0 in
      let result : xlenbits := EXTS 64 result32 in
      (wX (projT1 (regidx_to_regno rd)) result) >> returnm (RETIRE_SUCCESS  : Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_MUL
(rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (high : bool) (signed1 : bool) (signed2 : bool) 
: M (Retired) :=
   
   (haveMulDiv tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
      (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val =>
      let rs1_int : Z :=
        if sumbool_of_bool (signed1) then projT1 (sint rs1_val)
        else projT1 (uint rs1_val) in
      let rs2_int : Z :=
        if sumbool_of_bool (signed2) then projT1 (sint rs2_val)
        else projT1 (uint rs2_val) in
      let result_wide := to_bits (Z.mul 2 64) (Z.mul rs1_int rs2_int) in
      let result :=
        if sumbool_of_bool (high) then subrange_vec_dec result_wide (Z.sub (Z.mul 2 64) 1) 64
        else subrange_vec_dec result_wide (Z.sub 64 1) 0 in
      (wX (projT1 (regidx_to_regno rd)) result) >> returnm (RETIRE_SUCCESS  : Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_MRET '(tt : unit) 
: M (Retired) :=
   
   read_reg cur_privilege_ref >>= fun w__0 : Privilege =>
   (if ((eq_vec (privLevel_to_bits w__0) ((privLevel_to_bits Machine)  : mword 2))) then
      read_reg cur_privilege_ref >>= fun w__1 : Privilege =>
      ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
      (exception_handler w__1 (CTL_MRET (tt)) w__2) >>= fun w__3 : mword 64 =>
      (set_next_pc w__3)
       : M (unit)
    else (handle_illegal tt)  : M (unit)) >>
   returnm (RETIRE_FAIL
    : Retired).

Definition execute_LOADRES
(aq : bool) (rl : bool) (rs1 : mword 5) (width : word_width) (rd : mword 5) 
: M (Retired) :=
   
   (haveAtomics tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (ext_data_get_addr rs1 (zeros_implicit 64) Read width) >>= fun w__1 : Ext_DataAddr_Check unit =>
      (match w__1 with
       | Ext_DataAddr_Error (e) =>
          let '_ := (ext_handle_data_check_error e)  : unit in
          returnm (RETIRE_FAIL
           : Retired)
       | Ext_DataAddr_OK (vaddr) =>
          (match width with
           | BYTE => returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
           | HALF =>
              (cast_unit_vec (access_vec_dec vaddr 0)) >>= fun w__2 : mword 1 =>
              returnm ((eq_vec w__2 (vec_of_bits [B0]  : mword 1))
               : bool)
           | WORD =>
              returnm ((eq_vec (subrange_vec_dec vaddr 1 0)
                          (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))
               : bool)
           | DOUBLE =>
              returnm ((eq_vec (subrange_vec_dec vaddr 2 0)
                          (vec_of_bits [B0;B0;B0]  : mword (2 - 0 + 1)))
               : bool)
           end) >>= fun aligned : bool =>
          (if sumbool_of_bool ((negb aligned)) then
             (handle_mem_exception vaddr E_Load_Addr_Align) >> returnm (RETIRE_FAIL  : Retired)
           else
             (translateAddr vaddr Read) >>= fun w__3 : TR_Result (mword 64) ExceptionType =>
             (match w__3 with
              | TR_Failure (e) => (handle_mem_exception vaddr e) >> returnm (RETIRE_FAIL  : Retired)
              | TR_Address (addr) =>
                 (match (width, 64) with
                  | (WORD, g__215) =>
                     (mem_read Read addr 4 aq rl true) >>= fun w__4 : MemoryOpResult (mword (8 * 4)) =>
                     (process_loadres rd vaddr w__4 false)
                      : M (Retired)
                  | (DOUBLE, l__2) =>
                     (if sumbool_of_bool ((Z.eqb l__2 64)) then
                        (mem_read Read addr 8 aq rl true) >>= fun w__6 : MemoryOpResult (mword (8 * 8)) =>
                        (process_loadres rd vaddr w__6 false)
                         : M (Retired)
                      else (internal_error "LOADRES expected WORD or DOUBLE")  : M (Retired))
                      : M (Retired)
                  | _ => (internal_error "LOADRES expected WORD or DOUBLE")  : M (Retired)
                  end)
                  : M (Retired)
              end)
              : M (Retired))
           : M (Retired)
       end)
       : M (Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_LOAD
(imm : mword 12) (rs1 : mword 5) (rd : mword 5) (is_unsigned : bool) (width : word_width)
(aq : bool) (rl : bool) 
: M (Retired) :=
   
   let offset : xlenbits := EXTS 64 imm in
   (ext_data_get_addr rs1 offset Read width) >>= fun w__0 : Ext_DataAddr_Check unit =>
   (match w__0 with
    | Ext_DataAddr_Error (e) =>
       let '_ := (ext_handle_data_check_error e)  : unit in
       returnm (RETIRE_FAIL
        : Retired)
    | Ext_DataAddr_OK (vaddr) =>
       (check_misaligned vaddr width) >>= fun w__1 : bool =>
       (if sumbool_of_bool (w__1) then
          (handle_mem_exception vaddr E_Load_Addr_Align) >> returnm (RETIRE_FAIL  : Retired)
        else
          (translateAddr vaddr Read) >>= fun w__2 : TR_Result (mword 64) ExceptionType =>
          (match w__2 with
           | TR_Failure (e) => (handle_mem_exception vaddr e) >> returnm (RETIRE_FAIL  : Retired)
           | TR_Address (addr) =>
              (match (width, 64) with
               | (BYTE, g__207) =>
                  (mem_read Read addr 1 aq rl false) >>= fun w__3 : MemoryOpResult (mword (8 * 1)) =>
                  (process_load rd vaddr w__3 is_unsigned)
                   : M (Retired)
               | (HALF, g__208) =>
                  (mem_read Read addr 2 aq rl false) >>= fun w__5 : MemoryOpResult (mword (8 * 2)) =>
                  (process_load rd vaddr w__5 is_unsigned)
                   : M (Retired)
               | (WORD, g__209) =>
                  (mem_read Read addr 4 aq rl false) >>= fun w__7 : MemoryOpResult (mword (8 * 4)) =>
                  (process_load rd vaddr w__7 is_unsigned)
                   : M (Retired)
               | (DOUBLE, l__0) =>
                  (if sumbool_of_bool ((Z.eqb l__0 64)) then
                     (mem_read Read addr 8 aq rl false) >>= fun w__9 : MemoryOpResult (mword (8 * 8)) =>
                     (process_load rd vaddr w__9 is_unsigned)
                      : M (Retired)
                   else
                     assert_exp' false "Pattern match failure at model/riscv_insts_base.sail 329:10 - 338:11" >>= fun _ =>
                     exit tt)
                   : M (Retired)
               end)
               : M (Retired)
           end)
           : M (Retired))
        : M (Retired)
    end)
    : M (Retired).

Definition execute_ITYPE (imm : mword 12) (rs1 : mword 5) (rd : mword 5) (op : iop) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
   let immext : xlenbits := EXTS 64 imm in
   let result : xlenbits :=
     match op with
     | RISCV_ADDI => add_vec rs1_val immext
     | RISCV_SLTI => EXTZ 64 (bool_to_bits (zopz0zI_s rs1_val immext))
     | RISCV_SLTIU => EXTZ 64 (bool_to_bits (zopz0zI_u rs1_val immext))
     | RISCV_ANDI => and_vec rs1_val immext
     | RISCV_ORI => or_vec rs1_val immext
     | RISCV_XORI => xor_vec rs1_val immext
     end in
   (wX (projT1 (regidx_to_regno rd)) result) >> returnm (RETIRE_SUCCESS  : Retired).

Definition execute_ILLEGAL (s : mword 32) 
: M (Retired) :=
   
   (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired).

Definition execute_FENCE_TSO (pred : mword 4) (succ : mword 4) 
: M (Retired) :=
   
   (match (pred, succ) with
    | (v__794, v__795) =>
       (if ((andb (eq_vec (subrange_vec_dec v__794 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
               (eq_vec (subrange_vec_dec v__795 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_tso (tt)))
           : M (unit)
        else
          returnm ((if ((andb
                           (eq_vec (subrange_vec_dec v__794 1 0)
                              (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))
                           (eq_vec (subrange_vec_dec v__795 1 0)
                              (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))) then
                      tt
                    else
                      let '_ := (print_endline "FIXME: unsupported fence")  : unit in
                      tt)
           : unit))
        : M (unit)
    end) >>
   returnm (RETIRE_SUCCESS
    : Retired).

Definition execute_FENCEI '(tt : unit)  : Retired :=  RETIRE_SUCCESS.

Definition execute_FENCE (pred : mword 4) (succ : mword 4) 
: M (Retired) :=
   
   (match (pred, succ) with
    | (v__754, v__755) =>
       (if ((andb (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
               (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_rw_rw (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_r_rw (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_r_r (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_rw_w (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_w_w (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_w_rw (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_rw_r (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_r_w (tt)))
           : M (unit)
        else if ((andb
                    (eq_vec (subrange_vec_dec v__754 1 0) (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))
                    (eq_vec (subrange_vec_dec v__755 1 0) (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))))
        then
          (barrier (Barrier_RISCV_w_r (tt)))
           : M (unit)
        else
          returnm ((if ((andb
                           (eq_vec (subrange_vec_dec v__754 1 0)
                              (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))
                           (eq_vec (subrange_vec_dec v__755 1 0)
                              (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))) then
                      tt
                    else
                      let '_ := (print_endline "FIXME: unsupported fence")  : unit in
                      tt)
           : unit))
        : M (unit)
    end) >>
   returnm (RETIRE_SUCCESS
    : Retired).

Definition execute_ECALL '(tt : unit) 
: M (Retired) :=
   
   read_reg cur_privilege_ref >>= fun w__0 : Privilege =>
   let t : sync_exception :=
     {| sync_exception_trap :=
          (match w__0 with
           | User => E_U_EnvCall
           | Supervisor => E_S_EnvCall
           | Machine => E_M_EnvCall
           end); 
        sync_exception_excinfo := (None  : option xlenbits); 
        sync_exception_ext := None |} in
   read_reg cur_privilege_ref >>= fun w__1 : Privilege =>
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__2 : mword 64 =>
   (exception_handler w__1 (CTL_TRAP (t)) w__2) >>= fun w__3 : mword 64 =>
   (set_next_pc w__3) >> returnm (RETIRE_FAIL  : Retired).

Definition execute_EBREAK '(tt : unit) 
: M (Retired) :=
   
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   (handle_mem_exception w__0 E_Breakpoint) >> returnm (RETIRE_FAIL  : Retired).

Definition execute_DIVW (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (s : bool) 
: M (Retired) :=
   
   (haveMulDiv tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (rX (projT1 (regidx_to_regno rs1))) >>= fun w__1 : mword 64 =>
      let rs1_val := subrange_vec_dec w__1 31 0 in
      (rX (projT1 (regidx_to_regno rs2))) >>= fun w__2 : mword 64 =>
      let rs2_val := subrange_vec_dec w__2 31 0 in
      let rs1_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs1_val)
        else projT1 (uint rs1_val) in
      let rs2_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs2_val)
        else projT1 (uint rs2_val) in
      let q : Z := if sumbool_of_bool ((Z.eqb rs2_int 0)) then (-1) else Z.quot rs1_int rs2_int in
      let q' : Z :=
        if sumbool_of_bool ((andb s (Z.gtb q (Z.sub (projT1 (pow2 31)) 1)))) then Z.sub 0 (pow 2 31)
        else q in
      (wX (projT1 (regidx_to_regno rd)) (EXTS 64 (to_bits 32 q'))) >>
      returnm (RETIRE_SUCCESS
       : Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_DIV (rs2 : mword 5) (rs1 : mword 5) (rd : mword 5) (s : bool) 
: M (Retired) :=
   
   (haveMulDiv tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
      (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val =>
      let rs1_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs1_val)
        else projT1 (uint rs1_val) in
      let rs2_int : Z :=
        if sumbool_of_bool (s) then projT1 (sint rs2_val)
        else projT1 (uint rs2_val) in
      let q : Z := if sumbool_of_bool ((Z.eqb rs2_int 0)) then (-1) else Z.quot rs1_int rs2_int in
      let q' : Z :=
        if sumbool_of_bool ((andb s (Z.gtb q xlen_max_signed))) then xlen_min_signed
        else q in
      (wX (projT1 (regidx_to_regno rd)) (to_bits 64 q')) >> returnm (RETIRE_SUCCESS  : Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_C_NOP '(tt : unit)  : Retired :=  RETIRE_SUCCESS.

Definition execute_C_ILLEGAL (s : mword 16) 
: M (Retired) :=
   
   (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired).

Definition execute_CSR (csr : mword 12) (rs1 : mword 5) (rd : mword 5) (is_imm : bool) (op : csrop) 
: M (Retired) :=
   
   (if sumbool_of_bool (is_imm) then returnm ((EXTZ 64 rs1)  : mword 64)
    else (rX (projT1 (regidx_to_regno rs1)))  : M (mword 64)) >>= fun rs1_val : xlenbits =>
   let isWrite : bool :=
     match op with
     | CSRRW => true
     | _ =>
        if sumbool_of_bool (is_imm) then projT1 (neq_int (projT1 (uint rs1_val)) 0)
        else projT1 (neq_int (projT1 (uint rs1)) 0)
     end in
   read_reg cur_privilege_ref >>= fun w__1 : Privilege =>
   (check_CSR csr w__1 isWrite) >>= fun w__2 : bool =>
   (if sumbool_of_bool ((negb w__2)) then (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired)
    else
      (readCSR csr) >>= fun csr_val =>
      (if sumbool_of_bool (isWrite) then
         let new_val : xlenbits :=
           match op with
           | CSRRW => rs1_val
           | CSRRS => or_vec csr_val rs1_val
           | CSRRC => and_vec csr_val (not_vec rs1_val)
           end in
         (writeCSR csr new_val)
          : M (unit)
       else returnm (tt  : unit)) >>
      (wX (projT1 (regidx_to_regno rd)) csr_val) >> returnm (RETIRE_SUCCESS  : Retired))
    : M (Retired).

Definition execute_BTYPE (imm : mword 13) (rs2 : mword 5) (rs1 : mword 5) (op : bop) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun rs1_val =>
   (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val =>
   let taken : bool :=
     match op with
     | RISCV_BEQ => eq_vec rs1_val rs2_val
     | RISCV_BNE => neq_vec rs1_val rs2_val
     | RISCV_BLT => zopz0zI_s rs1_val rs2_val
     | RISCV_BGE => zopz0zKzJ_s rs1_val rs2_val
     | RISCV_BLTU => zopz0zI_u rs1_val rs2_val
     | RISCV_BGEU => zopz0zKzJ_u rs1_val rs2_val
     end in
   ((read_reg PC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
   let t : xlenbits := add_vec w__0 (EXTS 64 imm) in
   (if sumbool_of_bool (taken) then
      (match (ext_control_check_pc t) with
       | Ext_ControlAddr_Error (e) =>
          let '_ := (ext_handle_control_check_error e)  : unit in
          returnm (RETIRE_FAIL
           : Retired)
       | Ext_ControlAddr_OK (target) =>
          (and_boolM ((bit_to_bool (access_vec_dec target 1))  : M (bool))
             ((haveRVC tt) >>= fun w__2 : bool => returnm ((negb w__2)  : bool))) >>= fun w__3 : bool =>
          (if sumbool_of_bool (w__3) then
             (handle_mem_exception target E_Fetch_Addr_Align) >> returnm (RETIRE_FAIL  : Retired)
           else (set_next_pc target) >> returnm (RETIRE_SUCCESS  : Retired))
           : M (Retired)
       end)
       : M (Retired)
    else returnm (RETIRE_SUCCESS  : Retired))
    : M (Retired).

Definition execute_AMO
(op : amoop) (aq : bool) (rl : bool) (rs2 : mword 5) (rs1 : mword 5) (width : word_width)
(rd : mword 5) 
: M (Retired) :=
   
   (haveAtomics tt) >>= fun w__0 : bool =>
   (if sumbool_of_bool (w__0) then
      (ext_data_get_addr rs1 (zeros_implicit 64) ReadWrite width) >>= fun w__1 : Ext_DataAddr_Check unit =>
      (match w__1 with
       | Ext_DataAddr_Error (e) =>
          let '_ := (ext_handle_data_check_error e)  : unit in
          returnm (RETIRE_FAIL
           : Retired)
       | Ext_DataAddr_OK (vaddr) =>
          (translateAddr vaddr ReadWrite) >>= fun w__2 : TR_Result (mword 64) ExceptionType =>
          (match w__2 with
           | TR_Failure (e) => (handle_mem_exception vaddr e) >> returnm (RETIRE_FAIL  : Retired)
           | TR_Address (addr) =>
              (match (width, 64) with
               | (WORD, g__220) =>
                  (mem_write_ea addr 4 (andb aq rl) rl true)  : M (MemoryOpResult unit)
               | (DOUBLE, l__7) =>
                  (if sumbool_of_bool ((Z.eqb l__7 64)) then
                     (mem_write_ea addr 8 (andb aq rl) rl true)
                      : M (MemoryOpResult unit)
                   else (internal_error "AMO expected WORD or DOUBLE")  : M (MemoryOpResult unit))
                   : M (MemoryOpResult unit)
               | _ => (internal_error "AMO expected WORD or DOUBLE")  : M (MemoryOpResult unit)
               end) >>= fun eares : MemoryOpResult unit =>
              (rX (projT1 (regidx_to_regno rs2))) >>= fun rs2_val : xlenbits =>
              (match eares with
               | MemException (e) =>
                  (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
               | MemValue (_) =>
                  (match (width, 64) with
                   | (WORD, g__219) =>
                      (mem_read ReadWrite addr 4 aq (andb aq rl) true) >>= fun w__8 : MemoryOpResult (mword (8 * 4)) =>
                      returnm ((extend_value false w__8)
                       : MemoryOpResult (mword 64))
                   | (DOUBLE, l__6) =>
                      (if sumbool_of_bool ((Z.eqb l__6 64)) then
                         (mem_read ReadWrite addr 8 aq (andb aq rl) true) >>= fun w__9 : MemoryOpResult (mword (8 * 8)) =>
                         returnm ((extend_value false w__9)
                          : MemoryOpResult (mword 64))
                       else
                         (internal_error "AMO expected WORD or DOUBLE")
                          : M (MemoryOpResult (mword 64)))
                       : M (MemoryOpResult (mword 64))
                   | _ =>
                      (internal_error "AMO expected WORD or DOUBLE")
                       : M (MemoryOpResult (mword 64))
                   end) >>= fun rval : MemoryOpResult xlenbits =>
                  (match rval with
                   | MemException (e) =>
                      (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
                   | MemValue (loaded) =>
                      let result : xlenbits :=
                        match op with
                        | AMOSWAP => rs2_val
                        | AMOADD => add_vec rs2_val loaded
                        | AMOXOR => xor_vec rs2_val loaded
                        | AMOAND => and_vec rs2_val loaded
                        | AMOOR => or_vec rs2_val loaded
                        | AMOMIN =>
                           to_bits 64 (Z.min (projT1 (sint rs2_val)) (projT1 (sint loaded)))
                        | AMOMAX =>
                           to_bits 64 (Z.max (projT1 (sint rs2_val)) (projT1 (sint loaded)))
                        | AMOMINU =>
                           to_bits 64
                             (projT1
                              (min_nat (projT1 (uint rs2_val)) (projT1 (uint loaded))))
                        | AMOMAXU =>
                           to_bits 64
                             (projT1
                              (max_nat (projT1 (uint rs2_val)) (projT1 (uint loaded))))
                        end in
                      (match (width, 64) with
                       | (WORD, g__218) =>
                          (mem_write_value addr 4 (subrange_vec_dec result 31 0) (andb aq rl) rl
                             true)
                           : M (MemoryOpResult bool)
                       | (DOUBLE, l__5) =>
                          (if sumbool_of_bool ((Z.eqb l__5 64)) then
                             (mem_write_value addr 8 result (andb aq rl) rl true)
                              : M (MemoryOpResult bool)
                           else
                             (internal_error "AMO expected WORD or DOUBLE")
                              : M (MemoryOpResult bool))
                           : M (MemoryOpResult bool)
                       | _ =>
                          (internal_error "AMO expected WORD or DOUBLE")  : M (MemoryOpResult bool)
                       end) >>= fun wval : MemoryOpResult bool =>
                      (match wval with
                       | MemValue (true) =>
                          (wX (projT1 (regidx_to_regno rd)) loaded) >>
                          returnm (RETIRE_SUCCESS
                           : Retired)
                       | MemValue (false) =>
                          (internal_error "AMO got false from mem_write_value")  : M (Retired)
                       | MemException (e) =>
                          (handle_mem_exception addr e) >> returnm (RETIRE_FAIL  : Retired)
                       end)
                       : M (Retired)
                   end)
                   : M (Retired)
               end)
               : M (Retired)
           end)
           : M (Retired)
       end)
       : M (Retired)
    else (handle_illegal tt) >> returnm (RETIRE_FAIL  : Retired))
    : M (Retired).

Definition execute_ADDIW (imm : mword 12) (rs1 : mword 5) (rd : mword 5) 
: M (Retired) :=
   
   (rX (projT1 (regidx_to_regno rs1))) >>= fun w__0 : mword 64 =>
   let result : xlenbits := add_vec (EXTS 64 imm) w__0 in
   (wX (projT1 (regidx_to_regno rd)) (EXTS 64 (subrange_vec_dec result 31 0))) >>
   returnm (RETIRE_SUCCESS
    : Retired).

Definition compressed_measure (instr : ast) 
: Z :=
   
   match instr with
   | C_ADDI4SPN ((rdc, nzimm)) => 1
   | C_LW ((uimm, rsc, rdc)) => 1
   | C_LD ((uimm, rsc, rdc)) => 1
   | C_SW ((uimm, rsc1, rsc2)) => 1
   | C_SD ((uimm, rsc1, rsc2)) => 1
   | C_ADDI ((nzi, rsd)) => 1
   | C_JAL (imm) => 1
   | C_LI ((imm, rd)) => 1
   | C_ADDI16SP (imm) => 1
   | C_LUI ((imm, rd)) => 1
   | C_SRLI ((shamt, rsd)) => 1
   | C_SRAI ((shamt, rsd)) => 1
   | C_ANDI ((imm, rsd)) => 1
   | C_SUB ((rsd, rs2)) => 1
   | C_XOR ((rsd, rs2)) => 1
   | C_OR ((rsd, rs2)) => 1
   | C_AND ((rsd, rs2)) => 1
   | C_SUBW ((rsd, rs2)) => 1
   | C_ADDW ((rsd, rs2)) => 1
   | C_J (imm) => 1
   | C_BEQZ ((imm, rs)) => 1
   | C_BNEZ ((imm, rs)) => 1
   | C_SLLI ((shamt, rsd)) => 1
   | C_LWSP ((uimm, rd)) => 1
   | C_LDSP ((uimm, rd)) => 1
   | C_SWSP ((uimm, rs2)) => 1
   | C_SDSP ((uimm, rs2)) => 1
   | C_JR (rs1) => 1
   | C_JALR (rs1) => 1
   | C_MV ((rd, rs2)) => 1
   | C_EBREAK (tt') => 1
   | C_ADD ((rsd, rs2)) => 1
   | _ => 0
   end.

Fixpoint _rec_execute (merge_var : ast) (_reclimit : Z)  (_acc : Acc (Zwf 0) _reclimit)
{struct _acc} : M (Retired) :=
   
   assert_exp' (Z.geb _reclimit 0) "recursion limit reached" >>= fun _ =>
   (match merge_var with
    | C_ADDI4SPN ((rdc, nzimm)) =>
       let imm : bits 12 :=
         concat_vec (vec_of_bits [B0;B0]  : mword 2)
           (concat_vec nzimm (vec_of_bits [B0;B0]  : mword 2)) in
       let rd := creg2reg_idx rdc in
       (_rec_execute (ITYPE ((imm, sp, rd, RISCV_ADDI))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_LW ((uimm, rsc, rdc)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0]  : mword 2)) in
       let rd := creg2reg_idx rdc in
       let rs := creg2reg_idx rsc in
       (_rec_execute (LOAD ((imm, rs, rd, false, WORD, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_LD ((uimm, rsc, rdc)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0;B0]  : mword 3)) in
       let rd := creg2reg_idx rdc in
       let rs := creg2reg_idx rsc in
       (_rec_execute (LOAD ((imm, rs, rd, false, DOUBLE, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_SW ((uimm, rsc1, rsc2)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0]  : mword 2)) in
       let rs1 := creg2reg_idx rsc1 in
       let rs2 := creg2reg_idx rsc2 in
       (_rec_execute (STORE ((imm, rs2, rs1, WORD, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_SD ((uimm, rsc1, rsc2)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0;B0]  : mword 3)) in
       let rs1 := creg2reg_idx rsc1 in
       let rs2 := creg2reg_idx rsc2 in
       (_rec_execute (STORE ((imm, rs2, rs1, DOUBLE, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_ADDI ((nzi, rsd)) =>
       let imm : bits 12 := EXTS 12 nzi in
       (_rec_execute (ITYPE ((imm, rsd, rsd, RISCV_ADDI))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_JAL (imm) =>
       (_rec_execute (RISCV_JAL ((EXTS 21 (concat_vec imm (vec_of_bits [B0]  : mword 1)), ra)))
          (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_ADDIW ((imm, rsd)) =>
       (_rec_execute (ADDIW ((EXTS 12 imm, rsd, rsd))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_LI ((imm, rd)) =>
       let imm : bits 12 := EXTS 12 imm in
       (_rec_execute (ITYPE ((imm, zreg, rd, RISCV_ADDI))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_ADDI16SP (imm) =>
       let imm : bits 12 := EXTS 12 (concat_vec imm (vec_of_bits [B0;B0;B0;B0]  : mword 4)) in
       (_rec_execute (ITYPE ((imm, sp, sp, RISCV_ADDI))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_LUI ((imm, rd)) =>
       let res : bits 20 := EXTS 20 imm in
       (_rec_execute (UTYPE ((res, rd, RISCV_LUI))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_SRLI ((shamt, rsd)) =>
       let rsd := creg2reg_idx rsd in
       (_rec_execute (SHIFTIOP ((shamt, rsd, rsd, RISCV_SRLI))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_SRAI ((shamt, rsd)) =>
       let rsd := creg2reg_idx rsd in
       (_rec_execute (SHIFTIOP ((shamt, rsd, rsd, RISCV_SRAI))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_ANDI ((imm, rsd)) =>
       let rsd := creg2reg_idx rsd in
       (_rec_execute (ITYPE ((EXTS 12 imm, rsd, rsd, RISCV_ANDI))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_SUB ((rsd, rs2)) =>
       let rsd := creg2reg_idx rsd in
       let rs2 := creg2reg_idx rs2 in
       (_rec_execute (RTYPE ((rs2, rsd, rsd, RISCV_SUB))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_XOR ((rsd, rs2)) =>
       let rsd := creg2reg_idx rsd in
       let rs2 := creg2reg_idx rs2 in
       (_rec_execute (RTYPE ((rs2, rsd, rsd, RISCV_XOR))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_OR ((rsd, rs2)) =>
       let rsd := creg2reg_idx rsd in
       let rs2 := creg2reg_idx rs2 in
       (_rec_execute (RTYPE ((rs2, rsd, rsd, RISCV_OR))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_AND ((rsd, rs2)) =>
       let rsd := creg2reg_idx rsd in
       let rs2 := creg2reg_idx rs2 in
       (_rec_execute (RTYPE ((rs2, rsd, rsd, RISCV_AND))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_SUBW ((rsd, rs2)) =>
       let rsd := creg2reg_idx rsd in
       let rs2 := creg2reg_idx rs2 in
       (_rec_execute (RTYPEW ((rs2, rsd, rsd, RISCV_SUBW))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_ADDW ((rsd, rs2)) =>
       let rsd := creg2reg_idx rsd in
       let rs2 := creg2reg_idx rs2 in
       (_rec_execute (RTYPEW ((rs2, rsd, rsd, RISCV_ADDW))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_J (imm) =>
       (_rec_execute (RISCV_JAL ((EXTS 21 (concat_vec imm (vec_of_bits [B0]  : mword 1)), zreg)))
          (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_BEQZ ((imm, rs)) =>
       (_rec_execute
          (BTYPE
             ((EXTS 13 (concat_vec imm (vec_of_bits [B0]  : mword 1)), zreg, creg2reg_idx rs, RISCV_BEQ)))
          (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_BNEZ ((imm, rs)) =>
       (_rec_execute
          (BTYPE
             ((EXTS 13 (concat_vec imm (vec_of_bits [B0]  : mword 1)), zreg, creg2reg_idx rs, RISCV_BNE)))
          (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_SLLI ((shamt, rsd)) =>
       (_rec_execute (SHIFTIOP ((shamt, rsd, rsd, RISCV_SLLI))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_LWSP ((uimm, rd)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0]  : mword 2)) in
       (_rec_execute (LOAD ((imm, sp, rd, false, WORD, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_LDSP ((uimm, rd)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0;B0]  : mword 3)) in
       (_rec_execute (LOAD ((imm, sp, rd, false, DOUBLE, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_SWSP ((uimm, rs2)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0]  : mword 2)) in
       (_rec_execute (STORE ((imm, rs2, sp, WORD, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_SDSP ((uimm, rs2)) =>
       let imm : bits 12 := EXTZ 12 (concat_vec uimm (vec_of_bits [B0;B0;B0]  : mword 3)) in
       (_rec_execute (STORE ((imm, rs2, sp, DOUBLE, false, false))) (Z.sub _reclimit 1)
          (_limit_reduces _acc))
        : M (Retired)
    | C_JR (rs1) =>
       (_rec_execute (RISCV_JALR ((EXTZ 12 (vec_of_bits [B0]  : mword 1), rs1, zreg)))
          (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_JALR (rs1) =>
       (_rec_execute (RISCV_JALR ((EXTZ 12 (vec_of_bits [B0]  : mword 1), rs1, ra)))
          (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_MV ((rd, rs2)) =>
       (_rec_execute (RTYPE ((rs2, zreg, rd, RISCV_ADD))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | C_EBREAK (tt) =>
       (_rec_execute (EBREAK (tt)) (Z.sub _reclimit 1) (_limit_reduces _acc))  : M (Retired)
    | C_ADD ((rsd, rs2)) =>
       (_rec_execute (RTYPE ((rs2, rsd, rsd, RISCV_ADD))) (Z.sub _reclimit 1) (_limit_reduces _acc))
        : M (Retired)
    | UTYPE ((imm, rd, op)) => (execute_UTYPE imm rd op)  : M (Retired)
    | RISCV_JAL ((imm, rd)) => (execute_RISCV_JAL imm rd)  : M (Retired)
    | BTYPE ((imm, rs2, rs1, op)) => (execute_BTYPE imm rs2 rs1 op)  : M (Retired)
    | ITYPE ((imm, rs1, rd, op)) => (execute_ITYPE imm rs1 rd op)  : M (Retired)
    | SHIFTIOP ((shamt, rs1, rd, op)) => (execute_SHIFTIOP shamt rs1 rd op)  : M (Retired)
    | RTYPE ((rs2, rs1, rd, op)) => (execute_RTYPE rs2 rs1 rd op)  : M (Retired)
    | LOAD ((imm, rs1, rd, is_unsigned, width, aq, rl)) =>
       (execute_LOAD imm rs1 rd is_unsigned width aq rl)  : M (Retired)
    | STORE ((imm, rs2, rs1, width, aq, rl)) =>
       (execute_STORE imm rs2 rs1 width aq rl)  : M (Retired)
    | ADDIW ((imm, rs1, rd)) => (execute_ADDIW imm rs1 rd)  : M (Retired)
    | SHIFTW ((shamt, rs1, rd, op)) => (execute_SHIFTW shamt rs1 rd op)  : M (Retired)
    | RTYPEW ((rs2, rs1, rd, op)) => (execute_RTYPEW rs2 rs1 rd op)  : M (Retired)
    | SHIFTIWOP ((shamt, rs1, rd, op)) => (execute_SHIFTIWOP shamt rs1 rd op)  : M (Retired)
    | FENCE ((pred, succ)) => (execute_FENCE pred succ)  : M (Retired)
    | FENCE_TSO ((pred, succ)) => (execute_FENCE_TSO pred succ)  : M (Retired)
    | FENCEI (arg0) => returnm ((execute_FENCEI arg0)  : Retired)
    | ECALL (arg0) => (execute_ECALL arg0)  : M (Retired)
    | MRET (arg0) => (execute_MRET arg0)  : M (Retired)
    | SRET (arg0) => (execute_SRET arg0)  : M (Retired)
    | EBREAK (arg0) => (execute_EBREAK arg0)  : M (Retired)
    | WFI (arg0) => (execute_WFI arg0)  : M (Retired)
    | SFENCE_VMA ((rs1, rs2)) => (execute_SFENCE_VMA rs1 rs2)  : M (Retired)
    | LOADRES ((aq, rl, rs1, width, rd)) => (execute_LOADRES aq rl rs1 width rd)  : M (Retired)
    | STORECON ((aq, rl, rs2, rs1, width, rd)) =>
       (execute_STORECON aq rl rs2 rs1 width rd)  : M (Retired)
    | AMO ((op, aq, rl, rs2, rs1, width, rd)) =>
       (execute_AMO op aq rl rs2 rs1 width rd)  : M (Retired)
    | C_NOP (arg0) => returnm ((execute_C_NOP arg0)  : Retired)
    | MUL ((rs2, rs1, rd, high, signed1, signed2)) =>
       (execute_MUL rs2 rs1 rd high signed1 signed2)  : M (Retired)
    | DIV ((rs2, rs1, rd, s)) => (execute_DIV rs2 rs1 rd s)  : M (Retired)
    | REM ((rs2, rs1, rd, s)) => (execute_REM rs2 rs1 rd s)  : M (Retired)
    | MULW ((rs2, rs1, rd)) => (execute_MULW rs2 rs1 rd)  : M (Retired)
    | DIVW ((rs2, rs1, rd, s)) => (execute_DIVW rs2 rs1 rd s)  : M (Retired)
    | REMW ((rs2, rs1, rd, s)) => (execute_REMW rs2 rs1 rd s)  : M (Retired)
    | CSR ((csr, rs1, rd, is_imm, op)) => (execute_CSR csr rs1 rd is_imm op)  : M (Retired)
    | URET (arg0) => (execute_URET arg0)  : M (Retired)
    | RISCV_JALR ((imm, rs1, rd)) => (execute_RISCV_JALR imm rs1 rd)  : M (Retired)
    | ILLEGAL (s) => (execute_ILLEGAL s)  : M (Retired)
    | C_ILLEGAL (s) => (execute_C_ILLEGAL s)  : M (Retired)
    end)
    : M (Retired).

Definition execute (i : ast) 
: M (Retired) :=
   
   (_rec_execute i ((compressed_measure i)  : Z) (Zwf_guarded _))
    : M (Retired).

Definition assembly_forwards (arg_ : ast) 
: M (string) :=
   
   (match arg_ with
    | UTYPE ((imm, rd, op)) =>
       (reg_name_forwards rd) >>= fun w__0 : string =>
       returnm ((string_append (utype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append w__0
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits imm) "")))))
        : string)
    | RISCV_JAL ((imm, rd)) =>
       (reg_name_forwards rd) >>= fun w__1 : string =>
       returnm ((string_append "jal"
                   (string_append (spc_forwards tt)
                      (string_append w__1
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits imm) "")))))
        : string)
    | RISCV_JALR ((imm, rs1, rd)) =>
       (reg_name_forwards rd) >>= fun w__2 : string =>
       (reg_name_forwards rs1) >>= fun w__3 : string =>
       returnm ((string_append "jalr"
                   (string_append (spc_forwards tt)
                      (string_append w__2
                         (string_append (sep_forwards tt)
                            (string_append w__3
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm) "")))))))
        : string)
    | BTYPE ((imm, rs2, rs1, op)) =>
       (reg_name_forwards rs1) >>= fun w__4 : string =>
       (reg_name_forwards rs2) >>= fun w__5 : string =>
       returnm ((string_append (btype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append w__4
                         (string_append (sep_forwards tt)
                            (string_append w__5
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm) "")))))))
        : string)
    | ITYPE ((imm, rs1, rd, op)) =>
       (reg_name_forwards rd) >>= fun w__6 : string =>
       (reg_name_forwards rs1) >>= fun w__7 : string =>
       returnm ((string_append (itype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append w__6
                         (string_append (sep_forwards tt)
                            (string_append w__7
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits imm) "")))))))
        : string)
    | SHIFTIOP ((shamt, rs1, rd, op)) =>
       (reg_name_forwards rd) >>= fun w__8 : string =>
       (reg_name_forwards rs1) >>= fun w__9 : string =>
       returnm ((string_append (shiftiop_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append w__8
                         (string_append (sep_forwards tt)
                            (string_append w__9
                               (string_append (sep_forwards tt)
                                  (string_append (decimal_string_of_bits shamt) "")))))))
        : string)
    | RTYPE ((rs2, rs1, rd, op)) =>
       (reg_name_forwards rd) >>= fun w__10 : string =>
       (reg_name_forwards rs1) >>= fun w__11 : string =>
       (reg_name_forwards rs2) >>= fun w__12 : string =>
       returnm ((string_append (rtype_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append w__10
                         (string_append (sep_forwards tt)
                            (string_append w__11
                               (string_append (sep_forwards tt) (string_append w__12 "")))))))
        : string)
    | LOAD ((imm, rs1, rd, is_unsigned, size, aq, rl)) =>
       (reg_name_forwards rd) >>= fun w__13 : string =>
       (reg_name_forwards rs1) >>= fun w__14 : string =>
       returnm ((string_append "l"
                   (string_append (size_mnemonic_forwards size)
                      (string_append (maybe_u_forwards is_unsigned)
                         (string_append (maybe_aq_forwards aq)
                            (string_append (maybe_rl_forwards rl)
                               (string_append (spc_forwards tt)
                                  (string_append w__13
                                     (string_append (sep_forwards tt)
                                        (string_append (decimal_string_of_bits imm)
                                           (string_append (opt_spc_forwards tt)
                                              (string_append "("
                                                 (string_append (opt_spc_forwards tt)
                                                    (string_append w__14
                                                       (string_append (opt_spc_forwards tt)
                                                          (string_append ")" "")))))))))))))))
        : string)
    | STORE ((imm, rs2, rs1, size, aq, rl)) =>
       (reg_name_forwards rs2) >>= fun w__15 : string =>
       (reg_name_forwards rs1) >>= fun w__16 : string =>
       returnm ((string_append "s"
                   (string_append (size_mnemonic_forwards size)
                      (string_append (maybe_aq_forwards aq)
                         (string_append (maybe_rl_forwards rl)
                            (string_append (spc_forwards tt)
                               (string_append w__15
                                  (string_append (sep_forwards tt)
                                     (string_append (decimal_string_of_bits imm)
                                        (string_append (opt_spc_forwards tt)
                                           (string_append "("
                                              (string_append (opt_spc_forwards tt)
                                                 (string_append w__16
                                                    (string_append (opt_spc_forwards tt)
                                                       (string_append ")" ""))))))))))))))
        : string)
    | ADDIW ((imm, rs1, rd)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rd) >>= fun w__17 : string =>
          (reg_name_forwards rs1) >>= fun w__18 : string =>
          returnm ((string_append "addiw"
                      (string_append (spc_forwards tt)
                         (string_append w__17
                            (string_append (sep_forwards tt)
                               (string_append w__18
                                  (string_append (sep_forwards tt)
                                     (string_append (decimal_string_of_bits imm) "")))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | SHIFTW ((shamt, rs1, rd, op)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rd) >>= fun w__21 : string =>
          (reg_name_forwards rs1) >>= fun w__22 : string =>
          returnm ((string_append (shiftw_mnemonic_forwards op)
                      (string_append (spc_forwards tt)
                         (string_append w__21
                            (string_append (sep_forwards tt)
                               (string_append w__22
                                  (string_append (sep_forwards tt)
                                     (string_append (decimal_string_of_bits shamt) "")))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | RTYPEW ((rs2, rs1, rd, op)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rd) >>= fun w__25 : string =>
          (reg_name_forwards rs1) >>= fun w__26 : string =>
          (reg_name_forwards rs2) >>= fun w__27 : string =>
          returnm ((string_append (rtypew_mnemonic_forwards op)
                      (string_append (spc_forwards tt)
                         (string_append w__25
                            (string_append (sep_forwards tt)
                               (string_append w__26
                                  (string_append (sep_forwards tt) (string_append w__27 "")))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | SHIFTIWOP ((shamt, rs1, rd, op)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rd) >>= fun w__30 : string =>
          (reg_name_forwards rs1) >>= fun w__31 : string =>
          returnm ((string_append (shiftiwop_mnemonic_forwards op)
                      (string_append (spc_forwards tt)
                         (string_append w__30
                            (string_append (sep_forwards tt)
                               (string_append w__31
                                  (string_append (sep_forwards tt)
                                     (string_append (decimal_string_of_bits shamt) "")))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | FENCE ((pred, succ)) =>
       (fence_bits_forwards pred) >>= fun w__34 : string =>
       (fence_bits_forwards succ) >>= fun w__35 : string =>
       returnm ((string_append "fence"
                   (string_append (spc_forwards tt)
                      (string_append w__34
                         (string_append (sep_forwards tt) (string_append w__35 "")))))
        : string)
    | FENCE_TSO ((pred, succ)) =>
       (fence_bits_forwards pred) >>= fun w__36 : string =>
       (fence_bits_forwards succ) >>= fun w__37 : string =>
       returnm ((string_append "fence.tso"
                   (string_append (spc_forwards tt)
                      (string_append w__36
                         (string_append (sep_forwards tt) (string_append w__37 "")))))
        : string)
    | FENCEI (tt) => returnm ("fence.i"  : string)
    | ECALL (tt) => returnm ("ecall"  : string)
    | MRET (tt) => returnm ("mret"  : string)
    | SRET (tt) => returnm ("sret"  : string)
    | EBREAK (tt) => returnm ("ebreak"  : string)
    | WFI (tt) => returnm ("wfi"  : string)
    | SFENCE_VMA ((rs1, rs2)) =>
       (reg_name_forwards rs1) >>= fun w__38 : string =>
       (reg_name_forwards rs2) >>= fun w__39 : string =>
       returnm ((string_append "sfence.vma"
                   (string_append (spc_forwards tt)
                      (string_append w__38
                         (string_append (sep_forwards tt) (string_append w__39 "")))))
        : string)
    | LOADRES ((aq, rl, rs1, size, rd)) =>
       (reg_name_forwards rd) >>= fun w__40 : string =>
       (reg_name_forwards rs1) >>= fun w__41 : string =>
       returnm ((string_append "lr."
                   (string_append (size_mnemonic_forwards size)
                      (string_append (maybe_aq_forwards aq)
                         (string_append (maybe_rl_forwards rl)
                            (string_append (spc_forwards tt)
                               (string_append w__40
                                  (string_append (sep_forwards tt) (string_append w__41 ""))))))))
        : string)
    | STORECON ((aq, rl, rs2, rs1, size, rd)) =>
       (reg_name_forwards rd) >>= fun w__42 : string =>
       (reg_name_forwards rs1) >>= fun w__43 : string =>
       (reg_name_forwards rs2) >>= fun w__44 : string =>
       returnm ((string_append "sc."
                   (string_append (size_mnemonic_forwards size)
                      (string_append (maybe_aq_forwards aq)
                         (string_append (maybe_rl_forwards rl)
                            (string_append (spc_forwards tt)
                               (string_append w__42
                                  (string_append (sep_forwards tt)
                                     (string_append w__43
                                        (string_append (sep_forwards tt) (string_append w__44 ""))))))))))
        : string)
    | AMO ((op, aq, rl, rs2, rs1, width, rd)) =>
       (reg_name_forwards rd) >>= fun w__45 : string =>
       (reg_name_forwards rs1) >>= fun w__46 : string =>
       (reg_name_forwards rs2) >>= fun w__47 : string =>
       returnm ((string_append (amo_mnemonic_forwards op)
                   (string_append "."
                      (string_append (size_mnemonic_forwards width)
                         (string_append (maybe_aq_forwards aq)
                            (string_append (maybe_rl_forwards rl)
                               (string_append (spc_forwards tt)
                                  (string_append w__45
                                     (string_append (sep_forwards tt)
                                        (string_append w__46
                                           (string_append (sep_forwards tt) (string_append w__47 "")))))))))))
        : string)
    | C_NOP (tt) => returnm ("c.nop"  : string)
    | C_ADDI4SPN ((rdc, nzimm)) =>
       (if ((neq_vec nzimm (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8))) then
          (creg_name_forwards rdc) >>= fun w__48 : string =>
          returnm ((string_append "c.addi4spn"
                      (string_append (spc_forwards tt)
                         (string_append w__48
                            (string_append (sep_forwards tt)
                               (string_append
                                  (decimal_string_of_bits
                                     (concat_vec (nzimm  : mword 8) (vec_of_bits [B0;B0]  : mword 2)))
                                  "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_LW ((uimm, rsc, rdc)) =>
       (creg_name_forwards rdc) >>= fun w__51 : string =>
       (creg_name_forwards rsc) >>= fun w__52 : string =>
       returnm ((string_append "c.lw"
                   (string_append (spc_forwards tt)
                      (string_append w__51
                         (string_append (sep_forwards tt)
                            (string_append w__52
                               (string_append (sep_forwards tt)
                                  (string_append
                                     (decimal_string_of_bits
                                        (concat_vec (uimm  : mword 5)
                                           (vec_of_bits [B0;B0]  : mword 2))) "")))))))
        : string)
    | C_LD ((uimm, rsc, rdc)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (creg_name_forwards rdc) >>= fun w__53 : string =>
          (creg_name_forwards rsc) >>= fun w__54 : string =>
          returnm ((string_append "c.ld"
                      (string_append (spc_forwards tt)
                         (string_append w__53
                            (string_append (sep_forwards tt)
                               (string_append w__54
                                  (string_append (sep_forwards tt)
                                     (string_append
                                        (decimal_string_of_bits
                                           (concat_vec (uimm  : mword 5)
                                              (vec_of_bits [B0;B0;B0]  : mword 3))) "")))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_SW ((uimm, rsc1, rsc2)) =>
       (creg_name_forwards rsc1) >>= fun w__57 : string =>
       (creg_name_forwards rsc2) >>= fun w__58 : string =>
       returnm ((string_append "c.sw"
                   (string_append (spc_forwards tt)
                      (string_append w__57
                         (string_append (sep_forwards tt)
                            (string_append w__58
                               (string_append (sep_forwards tt)
                                  (string_append
                                     (decimal_string_of_bits
                                        (concat_vec (uimm  : mword 5)
                                           (vec_of_bits [B0;B0]  : mword 2))) "")))))))
        : string)
    | C_SD ((uimm, rsc1, rsc2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (creg_name_forwards rsc1) >>= fun w__59 : string =>
          (creg_name_forwards rsc2) >>= fun w__60 : string =>
          returnm ((string_append "c.sd"
                      (string_append (spc_forwards tt)
                         (string_append w__59
                            (string_append (sep_forwards tt)
                               (string_append w__60
                                  (string_append (sep_forwards tt)
                                     (string_append
                                        (decimal_string_of_bits
                                           (concat_vec (uimm  : mword 5)
                                              (vec_of_bits [B0;B0;B0]  : mword 3))) "")))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_ADDI ((nzi, rsd)) =>
       (if ((andb (neq_vec nzi (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))
               ((projT1
                 (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
                : bool))) then
          (reg_name_forwards rsd) >>= fun w__63 : string =>
          returnm ((string_append "c.addi"
                      (string_append (spc_forwards tt)
                         (string_append w__63
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits nzi) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_JAL (imm) =>
       (if sumbool_of_bool ((Z.eqb 64 32)) then
          returnm ((string_append "c.jal"
                      (string_append (spc_forwards tt)
                         (string_append
                            (decimal_string_of_bits
                               (concat_vec (imm  : mword 11) (vec_of_bits [B0]  : mword 1))) "")))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_ADDIW ((imm, rsd)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rsd) >>= fun w__68 : string =>
          returnm ((string_append "c.addiw"
                      (string_append (spc_forwards tt)
                         (string_append w__68
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits imm) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_LI ((imm, rd)) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
        then
          (reg_name_forwards rd) >>= fun w__71 : string =>
          returnm ((string_append "c.li"
                      (string_append (spc_forwards tt)
                         (string_append w__71
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits imm) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_ADDI16SP (imm) =>
       (if ((neq_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))) then
          returnm ((string_append "c.addi16sp"
                      (string_append (spc_forwards tt)
                         (string_append (decimal_string_of_bits imm) "")))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_LUI ((imm, rd)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rd))
                                   (projT1
                                    (regidx_to_regno zreg))))
                               ((andb
                                   (projT1
                                    (neq_int (projT1 (regidx_to_regno rd))
                                       (projT1
                                        (regidx_to_regno sp))))
                                   (neq_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6)))
                                : bool))) then
          (reg_name_forwards rd) >>= fun w__76 : string =>
          returnm ((string_append "c.lui"
                      (string_append (spc_forwards tt)
                         (string_append w__76
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits imm) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_SRLI ((shamt, rsd)) =>
       (if ((neq_vec shamt (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))) then
          (creg_name_forwards rsd) >>= fun w__79 : string =>
          returnm ((string_append "c.srli"
                      (string_append (spc_forwards tt)
                         (string_append w__79
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits shamt) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_SRAI ((shamt, rsd)) =>
       (if ((neq_vec shamt (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))) then
          (creg_name_forwards rsd) >>= fun w__82 : string =>
          returnm ((string_append "c.srai"
                      (string_append (spc_forwards tt)
                         (string_append w__82
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits shamt) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_ANDI ((imm, rsd)) =>
       (creg_name_forwards rsd) >>= fun w__85 : string =>
       returnm ((string_append "c.andi"
                   (string_append (spc_forwards tt)
                      (string_append w__85
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits imm) "")))))
        : string)
    | C_SUB ((rsd, rs2)) =>
       (creg_name_forwards rsd) >>= fun w__86 : string =>
       (creg_name_forwards rs2) >>= fun w__87 : string =>
       returnm ((string_append "c.sub"
                   (string_append (spc_forwards tt)
                      (string_append w__86
                         (string_append (sep_forwards tt) (string_append w__87 "")))))
        : string)
    | C_XOR ((rsd, rs2)) =>
       (creg_name_forwards rsd) >>= fun w__88 : string =>
       (creg_name_forwards rs2) >>= fun w__89 : string =>
       returnm ((string_append "c.xor"
                   (string_append (spc_forwards tt)
                      (string_append w__88
                         (string_append (sep_forwards tt) (string_append w__89 "")))))
        : string)
    | C_OR ((rsd, rs2)) =>
       (creg_name_forwards rsd) >>= fun w__90 : string =>
       (creg_name_forwards rs2) >>= fun w__91 : string =>
       returnm ((string_append "c.or"
                   (string_append (spc_forwards tt)
                      (string_append w__90
                         (string_append (sep_forwards tt) (string_append w__91 "")))))
        : string)
    | C_AND ((rsd, rs2)) =>
       (creg_name_forwards rsd) >>= fun w__92 : string =>
       (creg_name_forwards rs2) >>= fun w__93 : string =>
       returnm ((string_append "c.and"
                   (string_append (spc_forwards tt)
                      (string_append w__92
                         (string_append (sep_forwards tt) (string_append w__93 "")))))
        : string)
    | C_SUBW ((rsd, rs2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (creg_name_forwards rsd) >>= fun w__94 : string =>
          (creg_name_forwards rs2) >>= fun w__95 : string =>
          returnm ((string_append "c.subw"
                      (string_append (spc_forwards tt)
                         (string_append w__94
                            (string_append (sep_forwards tt) (string_append w__95 "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_ADDW ((rsd, rs2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (creg_name_forwards rsd) >>= fun w__98 : string =>
          (creg_name_forwards rs2) >>= fun w__99 : string =>
          returnm ((string_append "c.addw"
                      (string_append (spc_forwards tt)
                         (string_append w__98
                            (string_append (sep_forwards tt) (string_append w__99 "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_J (imm) =>
       returnm ((string_append "c.j"
                   (string_append (spc_forwards tt) (string_append (decimal_string_of_bits imm) "")))
        : string)
    | C_BEQZ ((imm, rs)) =>
       (creg_name_forwards rs) >>= fun w__102 : string =>
       returnm ((string_append "c.beqz"
                   (string_append (spc_forwards tt)
                      (string_append w__102
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits imm) "")))))
        : string)
    | C_BNEZ ((imm, rs)) =>
       (creg_name_forwards rs) >>= fun w__103 : string =>
       returnm ((string_append "c.bnez"
                   (string_append (spc_forwards tt)
                      (string_append w__103
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits imm) "")))))
        : string)
    | C_SLLI ((shamt, rsd)) =>
       (if ((andb (neq_vec shamt (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))
               ((projT1
                 (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
                : bool))) then
          (reg_name_forwards rsd) >>= fun w__104 : string =>
          returnm ((string_append "c.slli"
                      (string_append (spc_forwards tt)
                         (string_append w__104
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits shamt) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_LWSP ((uimm, rd)) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
        then
          (reg_name_forwards rd) >>= fun w__107 : string =>
          returnm ((string_append "c.lwsp"
                      (string_append (spc_forwards tt)
                         (string_append w__107
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits uimm) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_LDSP ((uimm, rd)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rd))
                                   (projT1
                                    (regidx_to_regno zreg)))) (Z.eqb 64 64))) then
          (reg_name_forwards rd) >>= fun w__110 : string =>
          returnm ((string_append "c.ldsp"
                      (string_append (spc_forwards tt)
                         (string_append w__110
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits uimm) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_SWSP ((uimm, rd)) =>
       (reg_name_forwards rd) >>= fun w__113 : string =>
       returnm ((string_append "c.swsp"
                   (string_append (spc_forwards tt)
                      (string_append w__113
                         (string_append (sep_forwards tt)
                            (string_append (decimal_string_of_bits uimm) "")))))
        : string)
    | C_SDSP ((uimm, rs2)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rs2) >>= fun w__114 : string =>
          returnm ((string_append "c.sdsp"
                      (string_append (spc_forwards tt)
                         (string_append w__114
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits uimm) "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_JR (rs1) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
        then
          (reg_name_forwards rs1) >>= fun w__117 : string =>
          returnm ((string_append "c.jr" (string_append (spc_forwards tt) (string_append w__117 "")))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_JALR (rs1) =>
       (if sumbool_of_bool ((projT1
                             (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
        then
          (reg_name_forwards rs1) >>= fun w__120 : string =>
          returnm ((string_append "c.jalr"
                      (string_append (spc_forwards tt) (string_append w__120 "")))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_MV ((rd, rs2)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rd))
                                   (projT1
                                    (regidx_to_regno zreg))))
                               ((projT1
                                 (neq_int (projT1 (regidx_to_regno rs2))
                                    (projT1
                                     (regidx_to_regno zreg))))
                                : bool))) then
          (reg_name_forwards rd) >>= fun w__123 : string =>
          (reg_name_forwards rs2) >>= fun w__124 : string =>
          returnm ((string_append "c.mv"
                      (string_append (spc_forwards tt)
                         (string_append w__123
                            (string_append (sep_forwards tt) (string_append w__124 "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | C_EBREAK (tt) => returnm ("c.ebreak"  : string)
    | C_ADD ((rsd, rs2)) =>
       (if sumbool_of_bool ((andb
                               (projT1
                                (neq_int (projT1 (regidx_to_regno rsd))
                                   (projT1
                                    (regidx_to_regno zreg))))
                               ((projT1
                                 (neq_int (projT1 (regidx_to_regno rs2))
                                    (projT1
                                     (regidx_to_regno zreg))))
                                : bool))) then
          (reg_name_forwards rsd) >>= fun w__127 : string =>
          (reg_name_forwards rs2) >>= fun w__128 : string =>
          returnm ((string_append "c.add"
                      (string_append (spc_forwards tt)
                         (string_append w__127
                            (string_append (sep_forwards tt) (string_append w__128 "")))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | MUL ((rs2, rs1, rd, high, signed1, signed2)) =>
       (mul_mnemonic_forwards (high, signed1, signed2)) >>= fun w__131 : string =>
       (reg_name_forwards rd) >>= fun w__132 : string =>
       (reg_name_forwards rs1) >>= fun w__133 : string =>
       (reg_name_forwards rs2) >>= fun w__134 : string =>
       returnm ((string_append w__131
                   (string_append (spc_forwards tt)
                      (string_append w__132
                         (string_append (sep_forwards tt)
                            (string_append w__133
                               (string_append (sep_forwards tt) (string_append w__134 "")))))))
        : string)
    | DIV ((rs2, rs1, rd, s)) =>
       (reg_name_forwards rd) >>= fun w__135 : string =>
       (reg_name_forwards rs1) >>= fun w__136 : string =>
       (reg_name_forwards rs2) >>= fun w__137 : string =>
       returnm ((string_append "div"
                   (string_append (maybe_not_u_forwards s)
                      (string_append (spc_forwards tt)
                         (string_append w__135
                            (string_append (sep_forwards tt)
                               (string_append w__136
                                  (string_append (sep_forwards tt) (string_append w__137 ""))))))))
        : string)
    | REM ((rs2, rs1, rd, s)) =>
       (reg_name_forwards rd) >>= fun w__138 : string =>
       (reg_name_forwards rs1) >>= fun w__139 : string =>
       (reg_name_forwards rs2) >>= fun w__140 : string =>
       returnm ((string_append "rem"
                   (string_append (maybe_not_u_forwards s)
                      (string_append (spc_forwards tt)
                         (string_append w__138
                            (string_append (sep_forwards tt)
                               (string_append w__139
                                  (string_append (sep_forwards tt) (string_append w__140 ""))))))))
        : string)
    | MULW ((rs2, rs1, rd)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rd) >>= fun w__141 : string =>
          (reg_name_forwards rs1) >>= fun w__142 : string =>
          (reg_name_forwards rs2) >>= fun w__143 : string =>
          returnm ((string_append "mulw"
                      (string_append (spc_forwards tt)
                         (string_append w__141
                            (string_append (sep_forwards tt)
                               (string_append w__142
                                  (string_append (sep_forwards tt) (string_append w__143 "")))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | DIVW ((rs2, rs1, rd, s)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rd) >>= fun w__146 : string =>
          (reg_name_forwards rs1) >>= fun w__147 : string =>
          (reg_name_forwards rs2) >>= fun w__148 : string =>
          returnm ((string_append "div"
                      (string_append (maybe_not_u_forwards s)
                         (string_append "w"
                            (string_append (spc_forwards tt)
                               (string_append w__146
                                  (string_append (sep_forwards tt)
                                     (string_append w__147
                                        (string_append (sep_forwards tt) (string_append w__148 "")))))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | REMW ((rs2, rs1, rd, s)) =>
       (if sumbool_of_bool ((Z.eqb 64 64)) then
          (reg_name_forwards rd) >>= fun w__151 : string =>
          (reg_name_forwards rs1) >>= fun w__152 : string =>
          (reg_name_forwards rs2) >>= fun w__153 : string =>
          returnm ((string_append "rem"
                      (string_append (maybe_not_u_forwards s)
                         (string_append "w"
                            (string_append (spc_forwards tt)
                               (string_append w__151
                                  (string_append (sep_forwards tt)
                                     (string_append w__152
                                        (string_append (sep_forwards tt) (string_append w__153 "")))))))))
           : string)
        else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
        : M (string)
    | CSR ((csr, rs1, rd, true, op)) =>
       (reg_name_forwards rd) >>= fun w__156 : string =>
       (csr_name_map_forwards csr) >>= fun w__157 : string =>
       returnm ((string_append (csr_mnemonic_forwards op)
                   (string_append "i"
                      (string_append (spc_forwards tt)
                         (string_append w__156
                            (string_append (sep_forwards tt)
                               (string_append (decimal_string_of_bits rs1)
                                  (string_append (sep_forwards tt) (string_append w__157 ""))))))))
        : string)
    | CSR ((csr, rs1, rd, false, op)) =>
       (reg_name_forwards rd) >>= fun w__158 : string =>
       (reg_name_forwards rs1) >>= fun w__159 : string =>
       (csr_name_map_forwards csr) >>= fun w__160 : string =>
       returnm ((string_append (csr_mnemonic_forwards op)
                   (string_append (spc_forwards tt)
                      (string_append w__158
                         (string_append (sep_forwards tt)
                            (string_append w__159
                               (string_append (sep_forwards tt) (string_append w__160 "")))))))
        : string)
    | URET (tt) => returnm ("uret"  : string)
    | ILLEGAL (s) =>
       returnm ((string_append "illegal"
                   (string_append (spc_forwards tt) (string_append (decimal_string_of_bits s) "")))
        : string)
    | C_ILLEGAL (s) =>
       returnm ((string_append "c.illegal"
                   (string_append (spc_forwards tt) (string_append (decimal_string_of_bits s) "")))
        : string)
    end)
    : M (string).

Definition _s1677_ (_s1678_ : string) 
: M (option (mword 16)) :=
   
   let _s1679_ := _s1678_ in
   (if ((string_startswith _s1679_ "c.illegal")) then
      (match (string_drop _s1679_ (projT1 (string_length "c.illegal"))) with
       | _s1680_ =>
          (spc_matches_prefix _s1680_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s1681_ _)) =>
                       match (string_drop _s1680_ _s1681_) with
                       | _s1682_ =>
                          match (hex_bits_16_matches_prefix _s1682_) with
                          | Some ((s, existT _ _s1683_ _)) =>
                             let p0_ := string_drop _s1682_ _s1683_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 16))
       end)
       : M (option (mword 16))
    else returnm (None  : option (mword 16)))
    : M (option (mword 16)).

Definition _s1669_ (_s1670_ : string) 
: M (option (mword 32)) :=
   
   let _s1671_ := _s1670_ in
   (if ((string_startswith _s1671_ "illegal")) then
      (match (string_drop _s1671_ (projT1 (string_length "illegal"))) with
       | _s1672_ =>
          (spc_matches_prefix _s1672_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s1673_ _)) =>
                       match (string_drop _s1672_ _s1673_) with
                       | _s1674_ =>
                          match (hex_bits_32_matches_prefix _s1674_) with
                          | Some ((s, existT _ _s1675_ _)) =>
                             let p0_ := string_drop _s1674_ _s1675_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 32))
       end)
       : M (option (mword 32))
    else returnm (None  : option (mword 32)))
    : M (option (mword 32)).

Definition _s1652_ (_s1653_ : string) 
: M (option ((csrop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s1653_ with
    | _s1654_ =>
       (csr_mnemonic_matches_prefix _s1654_) >>= fun w__0 : option ((csrop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1655_ _)) =>
           (match (string_drop _s1654_ _s1655_) with
            | _s1656_ =>
               (spc_matches_prefix _s1656_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1657_ _)) =>
                   (match (string_drop _s1656_ _s1657_) with
                    | _s1658_ =>
                       (reg_name_matches_prefix _s1658_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1659_ _)) =>
                           (match (string_drop _s1658_ _s1659_) with
                            | _s1660_ =>
                               (sep_matches_prefix _s1660_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1661_ _)) =>
                                   (match (string_drop _s1660_ _s1661_) with
                                    | _s1662_ =>
                                       (reg_name_matches_prefix _s1662_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1663_ _)) =>
                                           (match (string_drop _s1662_ _s1663_) with
                                            | _s1664_ =>
                                               (sep_matches_prefix _s1664_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s1665_ _)) =>
                                                   (match (string_drop _s1664_ _s1665_) with
                                                    | _s1666_ =>
                                                       (csr_name_map_matches_prefix _s1666_) >>= fun w__6 : option ((mword 12 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((csr, existT _ _s1667_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s1666_ _s1667_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, csr))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                    end)
                                                    : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                end)
                                                : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                            end)
                                            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                        | _ =>
                                           returnm (None
                                            : option ((csrop * mword 5 * mword 5 * mword 12)))
                                        end)
                                        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                    end)
                                    : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                | _ =>
                                   returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                                end)
                                : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                            end)
                            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                        end)
                        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                    end)
                    : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                end)
                : M (option ((csrop * mword 5 * mword 5 * mword 12)))
            end)
            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((csrop * mword 5 * mword 5 * mword 12))).

Definition _s1634_ (_s1635_ : string) 
: M (option ((csrop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s1635_ with
    | _s1636_ =>
       (csr_mnemonic_matches_prefix _s1636_) >>= fun w__0 : option ((csrop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1637_ _)) =>
           let _s1638_ := string_drop _s1636_ _s1637_ in
           (if ((string_startswith _s1638_ "i")) then
              (match (string_drop _s1638_ (projT1 (string_length "i"))) with
               | _s1639_ =>
                  (spc_matches_prefix _s1639_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s1640_ _)) =>
                      (match (string_drop _s1639_ _s1640_) with
                       | _s1641_ =>
                          (reg_name_matches_prefix _s1641_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s1642_ _)) =>
                              (match (string_drop _s1641_ _s1642_) with
                               | _s1643_ =>
                                  (sep_matches_prefix _s1643_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1644_ _)) =>
                                      (match (string_drop _s1643_ _s1644_) with
                                       | _s1645_ =>
                                          (match (hex_bits_5_matches_prefix _s1645_) with
                                           | Some ((rs1, existT _ _s1646_ _)) =>
                                              (match (string_drop _s1645_ _s1646_) with
                                               | _s1647_ =>
                                                  (sep_matches_prefix _s1647_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__4 with
                                                   | Some ((tt, existT _ _s1648_ _)) =>
                                                      (match (string_drop _s1647_ _s1648_) with
                                                       | _s1649_ =>
                                                          (csr_name_map_matches_prefix _s1649_) >>= fun w__5 : option ((mword 12 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__5 with
                                                                    | Some
                                                                      ((csr, existT _ _s1650_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s1649_ _s1650_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((op, rd, rs1, csr))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                       end)
                                                       : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                   end)
                                                   : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                               end)
                                               : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                           | _ =>
                                              returnm (None
                                               : option ((csrop * mword 5 * mword 5 * mword 12)))
                                           end)
                                           : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                   | _ =>
                                      returnm (None
                                       : option ((csrop * mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((csrop * mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((csrop * mword 5 * mword 5 * mword 12)))
            else returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12))))
            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((csrop * mword 5 * mword 5 * mword 12))).

Definition _s1615_ (_s1616_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s1617_ := _s1616_ in
   (if ((string_startswith _s1617_ "rem")) then
      (match (string_drop _s1617_ (projT1 (string_length "rem"))) with
       | _s1618_ =>
          (maybe_not_u_matches_prefix _s1618_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s1619_ _)) =>
              let _s1620_ := string_drop _s1618_ _s1619_ in
              (if ((string_startswith _s1620_ "w")) then
                 (match (string_drop _s1620_ (projT1 (string_length "w"))) with
                  | _s1621_ =>
                     (spc_matches_prefix _s1621_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some ((tt, existT _ _s1622_ _)) =>
                         (match (string_drop _s1621_ _s1622_) with
                          | _s1623_ =>
                             (reg_name_matches_prefix _s1623_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some ((rd, existT _ _s1624_ _)) =>
                                 (match (string_drop _s1623_ _s1624_) with
                                  | _s1625_ =>
                                     (sep_matches_prefix _s1625_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some ((tt, existT _ _s1626_ _)) =>
                                         (match (string_drop _s1625_ _s1626_) with
                                          | _s1627_ =>
                                             (reg_name_matches_prefix _s1627_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some ((rs1, existT _ _s1628_ _)) =>
                                                 (match (string_drop _s1627_ _s1628_) with
                                                  | _s1629_ =>
                                                     (sep_matches_prefix _s1629_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     (match w__5 with
                                                      | Some ((tt, existT _ _s1630_ _)) =>
                                                         (match (string_drop _s1629_ _s1630_) with
                                                          | _s1631_ =>
                                                             (reg_name_matches_prefix _s1631_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                               0)})) =>
                                                             returnm ((match w__6 with
                                                                       | Some
                                                                         ((rs2, existT _ _s1632_ _)) =>
                                                                          let p0_ :=
                                                                            string_drop _s1631_
                                                                              _s1632_ in
                                                                          if ((generic_eq p0_ ""))
                                                                          then
                                                                            Some
                                                                              ((s, rd, rs1, rs2))
                                                                          else None
                                                                       | _ => None
                                                                       end)
                                                              : option ((bool * mword 5 * mword 5 * mword 5)))
                                                          end)
                                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                      | _ =>
                                                         returnm (None
                                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                                      end)
                                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                  end)
                                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((bool * mword 5 * mword 5 * mword 5)))
                                              end)
                                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                          end)
                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None
                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                      end)
                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                  end)
                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                              | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                              end)
                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                          end)
                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                      | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                      end)
                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                  end)
                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
               else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s1596_ (_s1597_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s1598_ := _s1597_ in
   (if ((string_startswith _s1598_ "div")) then
      (match (string_drop _s1598_ (projT1 (string_length "div"))) with
       | _s1599_ =>
          (maybe_not_u_matches_prefix _s1599_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s1600_ _)) =>
              let _s1601_ := string_drop _s1599_ _s1600_ in
              (if ((string_startswith _s1601_ "w")) then
                 (match (string_drop _s1601_ (projT1 (string_length "w"))) with
                  | _s1602_ =>
                     (spc_matches_prefix _s1602_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some ((tt, existT _ _s1603_ _)) =>
                         (match (string_drop _s1602_ _s1603_) with
                          | _s1604_ =>
                             (reg_name_matches_prefix _s1604_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some ((rd, existT _ _s1605_ _)) =>
                                 (match (string_drop _s1604_ _s1605_) with
                                  | _s1606_ =>
                                     (sep_matches_prefix _s1606_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some ((tt, existT _ _s1607_ _)) =>
                                         (match (string_drop _s1606_ _s1607_) with
                                          | _s1608_ =>
                                             (reg_name_matches_prefix _s1608_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some ((rs1, existT _ _s1609_ _)) =>
                                                 (match (string_drop _s1608_ _s1609_) with
                                                  | _s1610_ =>
                                                     (sep_matches_prefix _s1610_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     (match w__5 with
                                                      | Some ((tt, existT _ _s1611_ _)) =>
                                                         (match (string_drop _s1610_ _s1611_) with
                                                          | _s1612_ =>
                                                             (reg_name_matches_prefix _s1612_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                               0)})) =>
                                                             returnm ((match w__6 with
                                                                       | Some
                                                                         ((rs2, existT _ _s1613_ _)) =>
                                                                          let p0_ :=
                                                                            string_drop _s1612_
                                                                              _s1613_ in
                                                                          if ((generic_eq p0_ ""))
                                                                          then
                                                                            Some
                                                                              ((s, rd, rs1, rs2))
                                                                          else None
                                                                       | _ => None
                                                                       end)
                                                              : option ((bool * mword 5 * mword 5 * mword 5)))
                                                          end)
                                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                      | _ =>
                                                         returnm (None
                                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                                      end)
                                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                  end)
                                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((bool * mword 5 * mword 5 * mword 5)))
                                              end)
                                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                          end)
                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None
                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                      end)
                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                  end)
                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                              | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                              end)
                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                          end)
                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                      | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                      end)
                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                  end)
                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
               else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s1580_ (_s1581_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s1582_ := _s1581_ in
   (if ((string_startswith _s1582_ "mulw")) then
      (match (string_drop _s1582_ (projT1 (string_length "mulw"))) with
       | _s1583_ =>
          (spc_matches_prefix _s1583_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1584_ _)) =>
              (match (string_drop _s1583_ _s1584_) with
               | _s1585_ =>
                  (reg_name_matches_prefix _s1585_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1586_ _)) =>
                      (match (string_drop _s1585_ _s1586_) with
                       | _s1587_ =>
                          (sep_matches_prefix _s1587_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1588_ _)) =>
                              (match (string_drop _s1587_ _s1588_) with
                               | _s1589_ =>
                                  (reg_name_matches_prefix _s1589_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s1590_ _)) =>
                                      (match (string_drop _s1589_ _s1590_) with
                                       | _s1591_ =>
                                          (sep_matches_prefix _s1591_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s1592_ _)) =>
                                              (match (string_drop _s1591_ _s1592_) with
                                               | _s1593_ =>
                                                  (reg_name_matches_prefix _s1593_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some ((rs2, existT _ _s1594_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s1593_ _s1594_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rd, rs1, rs2))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s1562_ (_s1563_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s1564_ := _s1563_ in
   (if ((string_startswith _s1564_ "rem")) then
      (match (string_drop _s1564_ (projT1 (string_length "rem"))) with
       | _s1565_ =>
          (maybe_not_u_matches_prefix _s1565_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s1566_ _)) =>
              (match (string_drop _s1565_ _s1566_) with
               | _s1567_ =>
                  (spc_matches_prefix _s1567_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s1568_ _)) =>
                      (match (string_drop _s1567_ _s1568_) with
                       | _s1569_ =>
                          (reg_name_matches_prefix _s1569_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s1570_ _)) =>
                              (match (string_drop _s1569_ _s1570_) with
                               | _s1571_ =>
                                  (sep_matches_prefix _s1571_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1572_ _)) =>
                                      (match (string_drop _s1571_ _s1572_) with
                                       | _s1573_ =>
                                          (reg_name_matches_prefix _s1573_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs1, existT _ _s1574_ _)) =>
                                              (match (string_drop _s1573_ _s1574_) with
                                               | _s1575_ =>
                                                  (sep_matches_prefix _s1575_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s1576_ _)) =>
                                                      (match (string_drop _s1575_ _s1576_) with
                                                       | _s1577_ =>
                                                          (reg_name_matches_prefix _s1577_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs2, existT _ _s1578_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s1577_ _s1578_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((s, rd, rs1, rs2))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s1544_ (_s1545_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s1546_ := _s1545_ in
   (if ((string_startswith _s1546_ "div")) then
      (match (string_drop _s1546_ (projT1 (string_length "div"))) with
       | _s1547_ =>
          (maybe_not_u_matches_prefix _s1547_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s1548_ _)) =>
              (match (string_drop _s1547_ _s1548_) with
               | _s1549_ =>
                  (spc_matches_prefix _s1549_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s1550_ _)) =>
                      (match (string_drop _s1549_ _s1550_) with
                       | _s1551_ =>
                          (reg_name_matches_prefix _s1551_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s1552_ _)) =>
                              (match (string_drop _s1551_ _s1552_) with
                               | _s1553_ =>
                                  (sep_matches_prefix _s1553_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1554_ _)) =>
                                      (match (string_drop _s1553_ _s1554_) with
                                       | _s1555_ =>
                                          (reg_name_matches_prefix _s1555_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs1, existT _ _s1556_ _)) =>
                                              (match (string_drop _s1555_ _s1556_) with
                                               | _s1557_ =>
                                                  (sep_matches_prefix _s1557_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s1558_ _)) =>
                                                      (match (string_drop _s1557_ _s1558_) with
                                                       | _s1559_ =>
                                                          (reg_name_matches_prefix _s1559_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs2, existT _ _s1560_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s1559_ _s1560_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((s, rd, rs1, rs2))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s1527_ (_s1528_ : string) 
: M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1528_ with
    | _s1529_ =>
       (mul_mnemonic_matches_prefix _s1529_) >>= fun w__0 : option (((bool * bool * bool) * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (((high, signed1, signed2), existT _ _s1530_ _)) =>
           (match (string_drop _s1529_ _s1530_) with
            | _s1531_ =>
               (spc_matches_prefix _s1531_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1532_ _)) =>
                   (match (string_drop _s1531_ _s1532_) with
                    | _s1533_ =>
                       (reg_name_matches_prefix _s1533_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1534_ _)) =>
                           (match (string_drop _s1533_ _s1534_) with
                            | _s1535_ =>
                               (sep_matches_prefix _s1535_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1536_ _)) =>
                                   (match (string_drop _s1535_ _s1536_) with
                                    | _s1537_ =>
                                       (reg_name_matches_prefix _s1537_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1538_ _)) =>
                                           (match (string_drop _s1537_ _s1538_) with
                                            | _s1539_ =>
                                               (sep_matches_prefix _s1539_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s1540_ _)) =>
                                                   (match (string_drop _s1539_ _s1540_) with
                                                    | _s1541_ =>
                                                       (reg_name_matches_prefix _s1541_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s1542_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s1541_ _s1542_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((high, signed1, signed2, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None
                                    : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                        | _ =>
                           returnm (None
                            : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5))).

Definition _s1515_ (_s1516_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1517_ := _s1516_ in
   (if ((string_startswith _s1517_ "c.add")) then
      (match (string_drop _s1517_ (projT1 (string_length "c.add"))) with
       | _s1518_ =>
          (spc_matches_prefix _s1518_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1519_ _)) =>
              (match (string_drop _s1518_ _s1519_) with
               | _s1520_ =>
                  (reg_name_matches_prefix _s1520_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1521_ _)) =>
                      (match (string_drop _s1520_ _s1521_) with
                       | _s1522_ =>
                          (sep_matches_prefix _s1522_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1523_ _)) =>
                              (match (string_drop _s1522_ _s1523_) with
                               | _s1524_ =>
                                  (reg_name_matches_prefix _s1524_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1525_ _)) =>
                                               let p0_ := string_drop _s1524_ _s1525_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1503_ (_s1504_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1505_ := _s1504_ in
   (if ((string_startswith _s1505_ "c.mv")) then
      (match (string_drop _s1505_ (projT1 (string_length "c.mv"))) with
       | _s1506_ =>
          (spc_matches_prefix _s1506_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1507_ _)) =>
              (match (string_drop _s1506_ _s1507_) with
               | _s1508_ =>
                  (reg_name_matches_prefix _s1508_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1509_ _)) =>
                      (match (string_drop _s1508_ _s1509_) with
                       | _s1510_ =>
                          (sep_matches_prefix _s1510_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1511_ _)) =>
                              (match (string_drop _s1510_ _s1511_) with
                               | _s1512_ =>
                                  (reg_name_matches_prefix _s1512_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1513_ _)) =>
                                               let p0_ := string_drop _s1512_ _s1513_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1495_ (_s1496_ : string) 
: M (option (mword 5)) :=
   
   let _s1497_ := _s1496_ in
   (if ((string_startswith _s1497_ "c.jalr")) then
      (match (string_drop _s1497_ (projT1 (string_length "c.jalr"))) with
       | _s1498_ =>
          (spc_matches_prefix _s1498_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1499_ _)) =>
              (match (string_drop _s1498_ _s1499_) with
               | _s1500_ =>
                  (reg_name_matches_prefix _s1500_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((rs1, existT _ _s1501_ _)) =>
                               let p0_ := string_drop _s1500_ _s1501_ in
                               if ((generic_eq p0_ "")) then Some (rs1)
                               else None
                            | _ => None
                            end)
                   : option (mword 5))
               end)
               : M (option (mword 5))
           | _ => returnm (None  : option (mword 5))
           end)
           : M (option (mword 5))
       end)
       : M (option (mword 5))
    else returnm (None  : option (mword 5)))
    : M (option (mword 5)).

Definition _s1487_ (_s1488_ : string) 
: M (option (mword 5)) :=
   
   let _s1489_ := _s1488_ in
   (if ((string_startswith _s1489_ "c.jr")) then
      (match (string_drop _s1489_ (projT1 (string_length "c.jr"))) with
       | _s1490_ =>
          (spc_matches_prefix _s1490_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1491_ _)) =>
              (match (string_drop _s1490_ _s1491_) with
               | _s1492_ =>
                  (reg_name_matches_prefix _s1492_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((rs1, existT _ _s1493_ _)) =>
                               let p0_ := string_drop _s1492_ _s1493_ in
                               if ((generic_eq p0_ "")) then Some (rs1)
                               else None
                            | _ => None
                            end)
                   : option (mword 5))
               end)
               : M (option (mword 5))
           | _ => returnm (None  : option (mword 5))
           end)
           : M (option (mword 5))
       end)
       : M (option (mword 5))
    else returnm (None  : option (mword 5)))
    : M (option (mword 5)).

Definition _s1475_ (_s1476_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1477_ := _s1476_ in
   (if ((string_startswith _s1477_ "c.sdsp")) then
      (match (string_drop _s1477_ (projT1 (string_length "c.sdsp"))) with
       | _s1478_ =>
          (spc_matches_prefix _s1478_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1479_ _)) =>
              (match (string_drop _s1478_ _s1479_) with
               | _s1480_ =>
                  (reg_name_matches_prefix _s1480_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs2, existT _ _s1481_ _)) =>
                      (match (string_drop _s1480_ _s1481_) with
                       | _s1482_ =>
                          (sep_matches_prefix _s1482_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1483_ _)) =>
                                       match (string_drop _s1482_ _s1483_) with
                                       | _s1484_ =>
                                          match (hex_bits_6_matches_prefix _s1484_) with
                                          | Some ((uimm, existT _ _s1485_ _)) =>
                                             let p0_ := string_drop _s1484_ _s1485_ in
                                             if ((generic_eq p0_ "")) then Some ((rs2, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1463_ (_s1464_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1465_ := _s1464_ in
   (if ((string_startswith _s1465_ "c.swsp")) then
      (match (string_drop _s1465_ (projT1 (string_length "c.swsp"))) with
       | _s1466_ =>
          (spc_matches_prefix _s1466_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1467_ _)) =>
              (match (string_drop _s1466_ _s1467_) with
               | _s1468_ =>
                  (reg_name_matches_prefix _s1468_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1469_ _)) =>
                      (match (string_drop _s1468_ _s1469_) with
                       | _s1470_ =>
                          (sep_matches_prefix _s1470_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1471_ _)) =>
                                       match (string_drop _s1470_ _s1471_) with
                                       | _s1472_ =>
                                          match (hex_bits_6_matches_prefix _s1472_) with
                                          | Some ((uimm, existT _ _s1473_ _)) =>
                                             let p0_ := string_drop _s1472_ _s1473_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1451_ (_s1452_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1453_ := _s1452_ in
   (if ((string_startswith _s1453_ "c.ldsp")) then
      (match (string_drop _s1453_ (projT1 (string_length "c.ldsp"))) with
       | _s1454_ =>
          (spc_matches_prefix _s1454_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1455_ _)) =>
              (match (string_drop _s1454_ _s1455_) with
               | _s1456_ =>
                  (reg_name_matches_prefix _s1456_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1457_ _)) =>
                      (match (string_drop _s1456_ _s1457_) with
                       | _s1458_ =>
                          (sep_matches_prefix _s1458_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1459_ _)) =>
                                       match (string_drop _s1458_ _s1459_) with
                                       | _s1460_ =>
                                          match (hex_bits_6_matches_prefix _s1460_) with
                                          | Some ((uimm, existT _ _s1461_ _)) =>
                                             let p0_ := string_drop _s1460_ _s1461_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1439_ (_s1440_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1441_ := _s1440_ in
   (if ((string_startswith _s1441_ "c.lwsp")) then
      (match (string_drop _s1441_ (projT1 (string_length "c.lwsp"))) with
       | _s1442_ =>
          (spc_matches_prefix _s1442_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1443_ _)) =>
              (match (string_drop _s1442_ _s1443_) with
               | _s1444_ =>
                  (reg_name_matches_prefix _s1444_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1445_ _)) =>
                      (match (string_drop _s1444_ _s1445_) with
                       | _s1446_ =>
                          (sep_matches_prefix _s1446_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1447_ _)) =>
                                       match (string_drop _s1446_ _s1447_) with
                                       | _s1448_ =>
                                          match (hex_bits_6_matches_prefix _s1448_) with
                                          | Some ((uimm, existT _ _s1449_ _)) =>
                                             let p0_ := string_drop _s1448_ _s1449_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1427_ (_s1428_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1429_ := _s1428_ in
   (if ((string_startswith _s1429_ "c.slli")) then
      (match (string_drop _s1429_ (projT1 (string_length "c.slli"))) with
       | _s1430_ =>
          (spc_matches_prefix _s1430_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1431_ _)) =>
              (match (string_drop _s1430_ _s1431_) with
               | _s1432_ =>
                  (reg_name_matches_prefix _s1432_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1433_ _)) =>
                      (match (string_drop _s1432_ _s1433_) with
                       | _s1434_ =>
                          (sep_matches_prefix _s1434_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1435_ _)) =>
                                       match (string_drop _s1434_ _s1435_) with
                                       | _s1436_ =>
                                          match (hex_bits_6_matches_prefix _s1436_) with
                                          | Some ((shamt, existT _ _s1437_ _)) =>
                                             let p0_ := string_drop _s1436_ _s1437_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, shamt))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1415_ (_s1416_ : string) 
: M (option ((mword 3 * mword 8))) :=
   
   let _s1417_ := _s1416_ in
   (if ((string_startswith _s1417_ "c.bnez")) then
      (match (string_drop _s1417_ (projT1 (string_length "c.bnez"))) with
       | _s1418_ =>
          (spc_matches_prefix _s1418_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1419_ _)) =>
              (match (string_drop _s1418_ _s1419_) with
               | _s1420_ =>
                  (creg_name_matches_prefix _s1420_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs, existT _ _s1421_ _)) =>
                      (match (string_drop _s1420_ _s1421_) with
                       | _s1422_ =>
                          (sep_matches_prefix _s1422_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1423_ _)) =>
                                       match (string_drop _s1422_ _s1423_) with
                                       | _s1424_ =>
                                          match (hex_bits_8_matches_prefix _s1424_) with
                                          | Some ((imm, existT _ _s1425_ _)) =>
                                             let p0_ := string_drop _s1424_ _s1425_ in
                                             if ((generic_eq p0_ "")) then Some ((rs, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8)))
                       end)
                       : M (option ((mword 3 * mword 8)))
                   | _ => returnm (None  : option ((mword 3 * mword 8)))
                   end)
                   : M (option ((mword 3 * mword 8)))
               end)
               : M (option ((mword 3 * mword 8)))
           | _ => returnm (None  : option ((mword 3 * mword 8)))
           end)
           : M (option ((mword 3 * mword 8)))
       end)
       : M (option ((mword 3 * mword 8)))
    else returnm (None  : option ((mword 3 * mword 8))))
    : M (option ((mword 3 * mword 8))).

Definition _s1403_ (_s1404_ : string) 
: M (option ((mword 3 * mword 8))) :=
   
   let _s1405_ := _s1404_ in
   (if ((string_startswith _s1405_ "c.beqz")) then
      (match (string_drop _s1405_ (projT1 (string_length "c.beqz"))) with
       | _s1406_ =>
          (spc_matches_prefix _s1406_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1407_ _)) =>
              (match (string_drop _s1406_ _s1407_) with
               | _s1408_ =>
                  (creg_name_matches_prefix _s1408_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs, existT _ _s1409_ _)) =>
                      (match (string_drop _s1408_ _s1409_) with
                       | _s1410_ =>
                          (sep_matches_prefix _s1410_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1411_ _)) =>
                                       match (string_drop _s1410_ _s1411_) with
                                       | _s1412_ =>
                                          match (hex_bits_8_matches_prefix _s1412_) with
                                          | Some ((imm, existT _ _s1413_ _)) =>
                                             let p0_ := string_drop _s1412_ _s1413_ in
                                             if ((generic_eq p0_ "")) then Some ((rs, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8)))
                       end)
                       : M (option ((mword 3 * mword 8)))
                   | _ => returnm (None  : option ((mword 3 * mword 8)))
                   end)
                   : M (option ((mword 3 * mword 8)))
               end)
               : M (option ((mword 3 * mword 8)))
           | _ => returnm (None  : option ((mword 3 * mword 8)))
           end)
           : M (option ((mword 3 * mword 8)))
       end)
       : M (option ((mword 3 * mword 8)))
    else returnm (None  : option ((mword 3 * mword 8))))
    : M (option ((mword 3 * mword 8))).

Definition _s1395_ (_s1396_ : string) 
: M (option (mword 11)) :=
   
   let _s1397_ := _s1396_ in
   (if ((string_startswith _s1397_ "c.j")) then
      (match (string_drop _s1397_ (projT1 (string_length "c.j"))) with
       | _s1398_ =>
          (spc_matches_prefix _s1398_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s1399_ _)) =>
                       match (string_drop _s1398_ _s1399_) with
                       | _s1400_ =>
                          match (hex_bits_11_matches_prefix _s1400_) with
                          | Some ((imm, existT _ _s1401_ _)) =>
                             let p0_ := string_drop _s1400_ _s1401_ in
                             if ((generic_eq p0_ "")) then Some (imm)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 11))
       end)
       : M (option (mword 11))
    else returnm (None  : option (mword 11)))
    : M (option (mword 11)).

Definition _s1383_ (_s1384_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s1385_ := _s1384_ in
   (if ((string_startswith _s1385_ "c.addw")) then
      (match (string_drop _s1385_ (projT1 (string_length "c.addw"))) with
       | _s1386_ =>
          (spc_matches_prefix _s1386_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1387_ _)) =>
              (match (string_drop _s1386_ _s1387_) with
               | _s1388_ =>
                  (creg_name_matches_prefix _s1388_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1389_ _)) =>
                      (match (string_drop _s1388_ _s1389_) with
                       | _s1390_ =>
                          (sep_matches_prefix _s1390_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1391_ _)) =>
                              (match (string_drop _s1390_ _s1391_) with
                               | _s1392_ =>
                                  (creg_name_matches_prefix _s1392_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1393_ _)) =>
                                               let p0_ := string_drop _s1392_ _s1393_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s1371_ (_s1372_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s1373_ := _s1372_ in
   (if ((string_startswith _s1373_ "c.subw")) then
      (match (string_drop _s1373_ (projT1 (string_length "c.subw"))) with
       | _s1374_ =>
          (spc_matches_prefix _s1374_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1375_ _)) =>
              (match (string_drop _s1374_ _s1375_) with
               | _s1376_ =>
                  (creg_name_matches_prefix _s1376_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1377_ _)) =>
                      (match (string_drop _s1376_ _s1377_) with
                       | _s1378_ =>
                          (sep_matches_prefix _s1378_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1379_ _)) =>
                              (match (string_drop _s1378_ _s1379_) with
                               | _s1380_ =>
                                  (creg_name_matches_prefix _s1380_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1381_ _)) =>
                                               let p0_ := string_drop _s1380_ _s1381_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s1359_ (_s1360_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s1361_ := _s1360_ in
   (if ((string_startswith _s1361_ "c.and")) then
      (match (string_drop _s1361_ (projT1 (string_length "c.and"))) with
       | _s1362_ =>
          (spc_matches_prefix _s1362_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1363_ _)) =>
              (match (string_drop _s1362_ _s1363_) with
               | _s1364_ =>
                  (creg_name_matches_prefix _s1364_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1365_ _)) =>
                      (match (string_drop _s1364_ _s1365_) with
                       | _s1366_ =>
                          (sep_matches_prefix _s1366_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1367_ _)) =>
                              (match (string_drop _s1366_ _s1367_) with
                               | _s1368_ =>
                                  (creg_name_matches_prefix _s1368_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1369_ _)) =>
                                               let p0_ := string_drop _s1368_ _s1369_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s1347_ (_s1348_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s1349_ := _s1348_ in
   (if ((string_startswith _s1349_ "c.or")) then
      (match (string_drop _s1349_ (projT1 (string_length "c.or"))) with
       | _s1350_ =>
          (spc_matches_prefix _s1350_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1351_ _)) =>
              (match (string_drop _s1350_ _s1351_) with
               | _s1352_ =>
                  (creg_name_matches_prefix _s1352_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1353_ _)) =>
                      (match (string_drop _s1352_ _s1353_) with
                       | _s1354_ =>
                          (sep_matches_prefix _s1354_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1355_ _)) =>
                              (match (string_drop _s1354_ _s1355_) with
                               | _s1356_ =>
                                  (creg_name_matches_prefix _s1356_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1357_ _)) =>
                                               let p0_ := string_drop _s1356_ _s1357_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s1335_ (_s1336_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s1337_ := _s1336_ in
   (if ((string_startswith _s1337_ "c.xor")) then
      (match (string_drop _s1337_ (projT1 (string_length "c.xor"))) with
       | _s1338_ =>
          (spc_matches_prefix _s1338_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1339_ _)) =>
              (match (string_drop _s1338_ _s1339_) with
               | _s1340_ =>
                  (creg_name_matches_prefix _s1340_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1341_ _)) =>
                      (match (string_drop _s1340_ _s1341_) with
                       | _s1342_ =>
                          (sep_matches_prefix _s1342_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1343_ _)) =>
                              (match (string_drop _s1342_ _s1343_) with
                               | _s1344_ =>
                                  (creg_name_matches_prefix _s1344_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1345_ _)) =>
                                               let p0_ := string_drop _s1344_ _s1345_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s1323_ (_s1324_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s1325_ := _s1324_ in
   (if ((string_startswith _s1325_ "c.sub")) then
      (match (string_drop _s1325_ (projT1 (string_length "c.sub"))) with
       | _s1326_ =>
          (spc_matches_prefix _s1326_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1327_ _)) =>
              (match (string_drop _s1326_ _s1327_) with
               | _s1328_ =>
                  (creg_name_matches_prefix _s1328_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1329_ _)) =>
                      (match (string_drop _s1328_ _s1329_) with
                       | _s1330_ =>
                          (sep_matches_prefix _s1330_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1331_ _)) =>
                              (match (string_drop _s1330_ _s1331_) with
                               | _s1332_ =>
                                  (creg_name_matches_prefix _s1332_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1333_ _)) =>
                                               let p0_ := string_drop _s1332_ _s1333_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s1311_ (_s1312_ : string) 
: M (option ((mword 3 * mword 6))) :=
   
   let _s1313_ := _s1312_ in
   (if ((string_startswith _s1313_ "c.andi")) then
      (match (string_drop _s1313_ (projT1 (string_length "c.andi"))) with
       | _s1314_ =>
          (spc_matches_prefix _s1314_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1315_ _)) =>
              (match (string_drop _s1314_ _s1315_) with
               | _s1316_ =>
                  (creg_name_matches_prefix _s1316_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1317_ _)) =>
                      (match (string_drop _s1316_ _s1317_) with
                       | _s1318_ =>
                          (sep_matches_prefix _s1318_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1319_ _)) =>
                                       match (string_drop _s1318_ _s1319_) with
                                       | _s1320_ =>
                                          match (hex_bits_6_matches_prefix _s1320_) with
                                          | Some ((imm, existT _ _s1321_ _)) =>
                                             let p0_ := string_drop _s1320_ _s1321_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6)))
                       end)
                       : M (option ((mword 3 * mword 6)))
                   | _ => returnm (None  : option ((mword 3 * mword 6)))
                   end)
                   : M (option ((mword 3 * mword 6)))
               end)
               : M (option ((mword 3 * mword 6)))
           | _ => returnm (None  : option ((mword 3 * mword 6)))
           end)
           : M (option ((mword 3 * mword 6)))
       end)
       : M (option ((mword 3 * mword 6)))
    else returnm (None  : option ((mword 3 * mword 6))))
    : M (option ((mword 3 * mword 6))).

Definition _s1299_ (_s1300_ : string) 
: M (option ((mword 3 * mword 6))) :=
   
   let _s1301_ := _s1300_ in
   (if ((string_startswith _s1301_ "c.srai")) then
      (match (string_drop _s1301_ (projT1 (string_length "c.srai"))) with
       | _s1302_ =>
          (spc_matches_prefix _s1302_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1303_ _)) =>
              (match (string_drop _s1302_ _s1303_) with
               | _s1304_ =>
                  (creg_name_matches_prefix _s1304_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1305_ _)) =>
                      (match (string_drop _s1304_ _s1305_) with
                       | _s1306_ =>
                          (sep_matches_prefix _s1306_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1307_ _)) =>
                                       match (string_drop _s1306_ _s1307_) with
                                       | _s1308_ =>
                                          match (hex_bits_6_matches_prefix _s1308_) with
                                          | Some ((shamt, existT _ _s1309_ _)) =>
                                             let p0_ := string_drop _s1308_ _s1309_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, shamt))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6)))
                       end)
                       : M (option ((mword 3 * mword 6)))
                   | _ => returnm (None  : option ((mword 3 * mword 6)))
                   end)
                   : M (option ((mword 3 * mword 6)))
               end)
               : M (option ((mword 3 * mword 6)))
           | _ => returnm (None  : option ((mword 3 * mword 6)))
           end)
           : M (option ((mword 3 * mword 6)))
       end)
       : M (option ((mword 3 * mword 6)))
    else returnm (None  : option ((mword 3 * mword 6))))
    : M (option ((mword 3 * mword 6))).

Definition _s1287_ (_s1288_ : string) 
: M (option ((mword 3 * mword 6))) :=
   
   let _s1289_ := _s1288_ in
   (if ((string_startswith _s1289_ "c.srli")) then
      (match (string_drop _s1289_ (projT1 (string_length "c.srli"))) with
       | _s1290_ =>
          (spc_matches_prefix _s1290_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1291_ _)) =>
              (match (string_drop _s1290_ _s1291_) with
               | _s1292_ =>
                  (creg_name_matches_prefix _s1292_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1293_ _)) =>
                      (match (string_drop _s1292_ _s1293_) with
                       | _s1294_ =>
                          (sep_matches_prefix _s1294_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1295_ _)) =>
                                       match (string_drop _s1294_ _s1295_) with
                                       | _s1296_ =>
                                          match (hex_bits_6_matches_prefix _s1296_) with
                                          | Some ((shamt, existT _ _s1297_ _)) =>
                                             let p0_ := string_drop _s1296_ _s1297_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, shamt))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6)))
                       end)
                       : M (option ((mword 3 * mword 6)))
                   | _ => returnm (None  : option ((mword 3 * mword 6)))
                   end)
                   : M (option ((mword 3 * mword 6)))
               end)
               : M (option ((mword 3 * mword 6)))
           | _ => returnm (None  : option ((mword 3 * mword 6)))
           end)
           : M (option ((mword 3 * mword 6)))
       end)
       : M (option ((mword 3 * mword 6)))
    else returnm (None  : option ((mword 3 * mword 6))))
    : M (option ((mword 3 * mword 6))).

Definition _s1275_ (_s1276_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1277_ := _s1276_ in
   (if ((string_startswith _s1277_ "c.lui")) then
      (match (string_drop _s1277_ (projT1 (string_length "c.lui"))) with
       | _s1278_ =>
          (spc_matches_prefix _s1278_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1279_ _)) =>
              (match (string_drop _s1278_ _s1279_) with
               | _s1280_ =>
                  (reg_name_matches_prefix _s1280_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1281_ _)) =>
                      (match (string_drop _s1280_ _s1281_) with
                       | _s1282_ =>
                          (sep_matches_prefix _s1282_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1283_ _)) =>
                                       match (string_drop _s1282_ _s1283_) with
                                       | _s1284_ =>
                                          match (hex_bits_6_matches_prefix _s1284_) with
                                          | Some ((imm, existT _ _s1285_ _)) =>
                                             let p0_ := string_drop _s1284_ _s1285_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1267_ (_s1268_ : string) 
: M (option (mword 6)) :=
   
   let _s1269_ := _s1268_ in
   (if ((string_startswith _s1269_ "c.addi16sp")) then
      (match (string_drop _s1269_ (projT1 (string_length "c.addi16sp"))) with
       | _s1270_ =>
          (spc_matches_prefix _s1270_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s1271_ _)) =>
                       match (string_drop _s1270_ _s1271_) with
                       | _s1272_ =>
                          match (hex_bits_6_matches_prefix _s1272_) with
                          | Some ((imm, existT _ _s1273_ _)) =>
                             let p0_ := string_drop _s1272_ _s1273_ in
                             if ((generic_eq p0_ "")) then Some (imm)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 6))
       end)
       : M (option (mword 6))
    else returnm (None  : option (mword 6)))
    : M (option (mword 6)).

Definition _s1255_ (_s1256_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1257_ := _s1256_ in
   (if ((string_startswith _s1257_ "c.li")) then
      (match (string_drop _s1257_ (projT1 (string_length "c.li"))) with
       | _s1258_ =>
          (spc_matches_prefix _s1258_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1259_ _)) =>
              (match (string_drop _s1258_ _s1259_) with
               | _s1260_ =>
                  (reg_name_matches_prefix _s1260_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1261_ _)) =>
                      (match (string_drop _s1260_ _s1261_) with
                       | _s1262_ =>
                          (sep_matches_prefix _s1262_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1263_ _)) =>
                                       match (string_drop _s1262_ _s1263_) with
                                       | _s1264_ =>
                                          match (hex_bits_6_matches_prefix _s1264_) with
                                          | Some ((imm, existT _ _s1265_ _)) =>
                                             let p0_ := string_drop _s1264_ _s1265_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1243_ (_s1244_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1245_ := _s1244_ in
   (if ((string_startswith _s1245_ "c.addiw")) then
      (match (string_drop _s1245_ (projT1 (string_length "c.addiw"))) with
       | _s1246_ =>
          (spc_matches_prefix _s1246_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1247_ _)) =>
              (match (string_drop _s1246_ _s1247_) with
               | _s1248_ =>
                  (reg_name_matches_prefix _s1248_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1249_ _)) =>
                      (match (string_drop _s1248_ _s1249_) with
                       | _s1250_ =>
                          (sep_matches_prefix _s1250_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1251_ _)) =>
                                       match (string_drop _s1250_ _s1251_) with
                                       | _s1252_ =>
                                          match (hex_bits_6_matches_prefix _s1252_) with
                                          | Some ((imm, existT _ _s1253_ _)) =>
                                             let p0_ := string_drop _s1252_ _s1253_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1235_ (_s1236_ : string) 
: M (option (mword 11)) :=
   
   let _s1237_ := _s1236_ in
   (if ((string_startswith _s1237_ "c.jal")) then
      (match (string_drop _s1237_ (projT1 (string_length "c.jal"))) with
       | _s1238_ =>
          (spc_matches_prefix _s1238_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s1239_ _)) =>
                       match (string_drop _s1238_ _s1239_) with
                       | _s1240_ =>
                          match (hex_bits_12_matches_prefix _s1240_) with
                          | Some ((v__802, existT _ _s1241_ _)) =>
                             if ((eq_vec (subrange_vec_dec v__802 0 0)
                                    (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then
                               let imm : mword 11 := subrange_vec_dec v__802 11 1 in
                               let imm : mword 11 := subrange_vec_dec v__802 11 1 in
                               let p0_ := string_drop _s1240_ _s1241_ in
                               if ((generic_eq p0_ "")) then Some (imm)
                               else None
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 11))
       end)
       : M (option (mword 11))
    else returnm (None  : option (mword 11)))
    : M (option (mword 11)).

Definition _s1223_ (_s1224_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s1225_ := _s1224_ in
   (if ((string_startswith _s1225_ "c.addi")) then
      (match (string_drop _s1225_ (projT1 (string_length "c.addi"))) with
       | _s1226_ =>
          (spc_matches_prefix _s1226_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1227_ _)) =>
              (match (string_drop _s1226_ _s1227_) with
               | _s1228_ =>
                  (reg_name_matches_prefix _s1228_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s1229_ _)) =>
                      (match (string_drop _s1228_ _s1229_) with
                       | _s1230_ =>
                          (sep_matches_prefix _s1230_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1231_ _)) =>
                                       match (string_drop _s1230_ _s1231_) with
                                       | _s1232_ =>
                                          match (hex_bits_6_matches_prefix _s1232_) with
                                          | Some ((nzi, existT _ _s1233_ _)) =>
                                             let p0_ := string_drop _s1232_ _s1233_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, nzi))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s1207_ (_s1208_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s1209_ := _s1208_ in
   (if ((string_startswith _s1209_ "c.sd")) then
      (match (string_drop _s1209_ (projT1 (string_length "c.sd"))) with
       | _s1210_ =>
          (spc_matches_prefix _s1210_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1211_ _)) =>
              (match (string_drop _s1210_ _s1211_) with
               | _s1212_ =>
                  (creg_name_matches_prefix _s1212_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsc1, existT _ _s1213_ _)) =>
                      (match (string_drop _s1212_ _s1213_) with
                       | _s1214_ =>
                          (sep_matches_prefix _s1214_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1215_ _)) =>
                              (match (string_drop _s1214_ _s1215_) with
                               | _s1216_ =>
                                  (creg_name_matches_prefix _s1216_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc2, existT _ _s1217_ _)) =>
                                      (match (string_drop _s1216_ _s1217_) with
                                       | _s1218_ =>
                                          (sep_matches_prefix _s1218_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s1219_ _)) =>
                                                       match (string_drop _s1218_ _s1219_) with
                                                       | _s1220_ =>
                                                          match (hex_bits_8_matches_prefix _s1220_) with
                                                          | Some ((v__804, existT _ _s1221_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__804 2 0)
                                                                    (vec_of_bits [B0;B0;B0]
                                                                      : mword (2 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__804 7 3 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__804 7 3 in
                                                               let p0_ :=
                                                                 string_drop _s1220_ _s1221_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rsc1, rsc2, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s1191_ (_s1192_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s1193_ := _s1192_ in
   (if ((string_startswith _s1193_ "c.sw")) then
      (match (string_drop _s1193_ (projT1 (string_length "c.sw"))) with
       | _s1194_ =>
          (spc_matches_prefix _s1194_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1195_ _)) =>
              (match (string_drop _s1194_ _s1195_) with
               | _s1196_ =>
                  (creg_name_matches_prefix _s1196_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsc1, existT _ _s1197_ _)) =>
                      (match (string_drop _s1196_ _s1197_) with
                       | _s1198_ =>
                          (sep_matches_prefix _s1198_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1199_ _)) =>
                              (match (string_drop _s1198_ _s1199_) with
                               | _s1200_ =>
                                  (creg_name_matches_prefix _s1200_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc2, existT _ _s1201_ _)) =>
                                      (match (string_drop _s1200_ _s1201_) with
                                       | _s1202_ =>
                                          (sep_matches_prefix _s1202_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s1203_ _)) =>
                                                       match (string_drop _s1202_ _s1203_) with
                                                       | _s1204_ =>
                                                          match (hex_bits_7_matches_prefix _s1204_) with
                                                          | Some ((v__806, existT _ _s1205_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__806 1 0)
                                                                    (vec_of_bits [B0;B0]
                                                                      : mword (1 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__806 6 2 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__806 6 2 in
                                                               let p0_ :=
                                                                 string_drop _s1204_ _s1205_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rsc1, rsc2, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s1175_ (_s1176_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s1177_ := _s1176_ in
   (if ((string_startswith _s1177_ "c.ld")) then
      (match (string_drop _s1177_ (projT1 (string_length "c.ld"))) with
       | _s1178_ =>
          (spc_matches_prefix _s1178_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1179_ _)) =>
              (match (string_drop _s1178_ _s1179_) with
               | _s1180_ =>
                  (creg_name_matches_prefix _s1180_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s1181_ _)) =>
                      (match (string_drop _s1180_ _s1181_) with
                       | _s1182_ =>
                          (sep_matches_prefix _s1182_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1183_ _)) =>
                              (match (string_drop _s1182_ _s1183_) with
                               | _s1184_ =>
                                  (creg_name_matches_prefix _s1184_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc, existT _ _s1185_ _)) =>
                                      (match (string_drop _s1184_ _s1185_) with
                                       | _s1186_ =>
                                          (sep_matches_prefix _s1186_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s1187_ _)) =>
                                                       match (string_drop _s1186_ _s1187_) with
                                                       | _s1188_ =>
                                                          match (hex_bits_8_matches_prefix _s1188_) with
                                                          | Some ((v__808, existT _ _s1189_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__808 2 0)
                                                                    (vec_of_bits [B0;B0;B0]
                                                                      : mword (2 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__808 7 3 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__808 7 3 in
                                                               let p0_ :=
                                                                 string_drop _s1188_ _s1189_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rdc, rsc, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s1159_ (_s1160_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s1161_ := _s1160_ in
   (if ((string_startswith _s1161_ "c.lw")) then
      (match (string_drop _s1161_ (projT1 (string_length "c.lw"))) with
       | _s1162_ =>
          (spc_matches_prefix _s1162_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1163_ _)) =>
              (match (string_drop _s1162_ _s1163_) with
               | _s1164_ =>
                  (creg_name_matches_prefix _s1164_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s1165_ _)) =>
                      (match (string_drop _s1164_ _s1165_) with
                       | _s1166_ =>
                          (sep_matches_prefix _s1166_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1167_ _)) =>
                              (match (string_drop _s1166_ _s1167_) with
                               | _s1168_ =>
                                  (creg_name_matches_prefix _s1168_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc, existT _ _s1169_ _)) =>
                                      (match (string_drop _s1168_ _s1169_) with
                                       | _s1170_ =>
                                          (sep_matches_prefix _s1170_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s1171_ _)) =>
                                                       match (string_drop _s1170_ _s1171_) with
                                                       | _s1172_ =>
                                                          match (hex_bits_7_matches_prefix _s1172_) with
                                                          | Some ((v__810, existT _ _s1173_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__810 1 0)
                                                                    (vec_of_bits [B0;B0]
                                                                      : mword (1 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__810 6 2 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__810 6 2 in
                                                               let p0_ :=
                                                                 string_drop _s1172_ _s1173_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rdc, rsc, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s1147_ (_s1148_ : string) 
: M (option ((mword 3 * mword 8))) :=
   
   let _s1149_ := _s1148_ in
   (if ((string_startswith _s1149_ "c.addi4spn")) then
      (match (string_drop _s1149_ (projT1 (string_length "c.addi4spn"))) with
       | _s1150_ =>
          (spc_matches_prefix _s1150_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1151_ _)) =>
              (match (string_drop _s1150_ _s1151_) with
               | _s1152_ =>
                  (creg_name_matches_prefix _s1152_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s1153_ _)) =>
                      (match (string_drop _s1152_ _s1153_) with
                       | _s1154_ =>
                          (sep_matches_prefix _s1154_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1155_ _)) =>
                                       match (string_drop _s1154_ _s1155_) with
                                       | _s1156_ =>
                                          match (hex_bits_10_matches_prefix _s1156_) with
                                          | Some ((v__812, existT _ _s1157_ _)) =>
                                             if ((eq_vec (subrange_vec_dec v__812 1 0)
                                                    (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))
                                             then
                                               let nzimm : mword 8 := subrange_vec_dec v__812 9 2 in
                                               let nzimm : mword 8 := subrange_vec_dec v__812 9 2 in
                                               let p0_ := string_drop _s1156_ _s1157_ in
                                               if ((generic_eq p0_ "")) then Some ((rdc, nzimm))
                                               else None
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8)))
                       end)
                       : M (option ((mword 3 * mword 8)))
                   | _ => returnm (None  : option ((mword 3 * mword 8)))
                   end)
                   : M (option ((mword 3 * mword 8)))
               end)
               : M (option ((mword 3 * mword 8)))
           | _ => returnm (None  : option ((mword 3 * mword 8)))
           end)
           : M (option ((mword 3 * mword 8)))
       end)
       : M (option ((mword 3 * mword 8)))
    else returnm (None  : option ((mword 3 * mword 8))))
    : M (option ((mword 3 * mword 8))).

Definition _s1123_ (_s1124_ : string) 
: M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1124_ with
    | _s1125_ =>
       (amo_mnemonic_matches_prefix _s1125_) >>= fun w__0 : option ((amoop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1126_ _)) =>
           let _s1127_ := string_drop _s1125_ _s1126_ in
           (if ((string_startswith _s1127_ ".")) then
              (match (string_drop _s1127_ (projT1 (string_length "."))) with
               | _s1128_ =>
                  (size_mnemonic_matches_prefix _s1128_) >>= fun w__1 : option ((word_width * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((width, existT _ _s1129_ _)) =>
                      (match (string_drop _s1128_ _s1129_) with
                       | _s1130_ =>
                          (maybe_aq_matches_prefix _s1130_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((aq, existT _ _s1131_ _)) =>
                              (match (string_drop _s1130_ _s1131_) with
                               | _s1132_ =>
                                  (maybe_rl_matches_prefix _s1132_) >>= fun w__3 : option ((bool * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rl, existT _ _s1133_ _)) =>
                                      (match (string_drop _s1132_ _s1133_) with
                                       | _s1134_ =>
                                          (spc_matches_prefix _s1134_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s1135_ _)) =>
                                              (match (string_drop _s1134_ _s1135_) with
                                               | _s1136_ =>
                                                  (reg_name_matches_prefix _s1136_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((rd, existT _ _s1137_ _)) =>
                                                      (match (string_drop _s1136_ _s1137_) with
                                                       | _s1138_ =>
                                                          (sep_matches_prefix _s1138_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((tt, existT _ _s1139_ _)) =>
                                                              (match (string_drop _s1138_ _s1139_) with
                                                               | _s1140_ =>
                                                                  (reg_name_matches_prefix _s1140_) >>= fun w__7 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__7 with
                                                                   | Some
                                                                     ((rs1, existT _ _s1141_ _)) =>
                                                                      (match (string_drop _s1140_
                                                                                _s1141_) with
                                                                       | _s1142_ =>
                                                                          (sep_matches_prefix
                                                                             _s1142_) >>= fun w__8 : option ((unit * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          (match w__8 with
                                                                           | Some
                                                                             ((tt, existT _ _s1143_ _)) =>
                                                                              (match (string_drop
                                                                                        _s1142_
                                                                                        _s1143_) with
                                                                               | _s1144_ =>
                                                                                  (reg_name_matches_prefix
                                                                                     _s1144_) >>= fun w__9 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                    0)})) =>
                                                                                  returnm ((match w__9 with
                                                                                            | Some
                                                                                              ((rs2, existT _ _s1145_ _)) =>
                                                                                               let p0_ :=
                                                                                                 string_drop
                                                                                                   _s1144_
                                                                                                   _s1145_ in
                                                                                               if ((generic_eq
                                                                                                      p0_
                                                                                                      ""))
                                                                                               then
                                                                                                 Some
                                                                                                   ((op, width, aq, rl, rd, rs1, rs2))
                                                                                               else
                                                                                                 None
                                                                                            | _ =>
                                                                                               None
                                                                                            end)
                                                                                   : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                               end)
                                                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                           | _ =>
                                                                              returnm (None
                                                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                           end)
                                                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                       end)
                                                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   end)
                                                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                               end)
                                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           end)
                                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
            else
              returnm (None
               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5))))
            : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
        | _ =>
           returnm (None
            : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5))).

Definition _s1101_ (_s1102_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s1103_ := _s1102_ in
   (if ((string_startswith _s1103_ "sc.")) then
      (match (string_drop _s1103_ (projT1 (string_length "sc."))) with
       | _s1104_ =>
          (size_mnemonic_matches_prefix _s1104_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s1105_ _)) =>
              (match (string_drop _s1104_ _s1105_) with
               | _s1106_ =>
                  (maybe_aq_matches_prefix _s1106_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s1107_ _)) =>
                      (match (string_drop _s1106_ _s1107_) with
                       | _s1108_ =>
                          (maybe_rl_matches_prefix _s1108_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s1109_ _)) =>
                              (match (string_drop _s1108_ _s1109_) with
                               | _s1110_ =>
                                  (spc_matches_prefix _s1110_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1111_ _)) =>
                                      (match (string_drop _s1110_ _s1111_) with
                                       | _s1112_ =>
                                          (reg_name_matches_prefix _s1112_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rd, existT _ _s1113_ _)) =>
                                              (match (string_drop _s1112_ _s1113_) with
                                               | _s1114_ =>
                                                  (sep_matches_prefix _s1114_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s1115_ _)) =>
                                                      (match (string_drop _s1114_ _s1115_) with
                                                       | _s1116_ =>
                                                          (reg_name_matches_prefix _s1116_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((rs1, existT _ _s1117_ _)) =>
                                                              (match (string_drop _s1116_ _s1117_) with
                                                               | _s1118_ =>
                                                                  (sep_matches_prefix _s1118_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__7 with
                                                                   | Some ((tt, existT _ _s1119_ _)) =>
                                                                      (match (string_drop _s1118_
                                                                                _s1119_) with
                                                                       | _s1120_ =>
                                                                          (reg_name_matches_prefix
                                                                             _s1120_) >>= fun w__8 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          returnm ((match w__8 with
                                                                                    | Some
                                                                                      ((rs2, existT _ _s1121_ _)) =>
                                                                                       let p0_ :=
                                                                                         string_drop
                                                                                           _s1120_
                                                                                           _s1121_ in
                                                                                       if ((generic_eq
                                                                                              p0_ ""))
                                                                                       then
                                                                                         Some
                                                                                           ((size, aq, rl, rd, rs1, rs2))
                                                                                       else None
                                                                                    | _ => None
                                                                                    end)
                                                                           : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                       end)
                                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
           | _ =>
              returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5))))
    : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5))).

Definition _s1083_ (_s1084_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 5))) :=
   
   let _s1085_ := _s1084_ in
   (if ((string_startswith _s1085_ "lr.")) then
      (match (string_drop _s1085_ (projT1 (string_length "lr."))) with
       | _s1086_ =>
          (size_mnemonic_matches_prefix _s1086_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s1087_ _)) =>
              (match (string_drop _s1086_ _s1087_) with
               | _s1088_ =>
                  (maybe_aq_matches_prefix _s1088_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s1089_ _)) =>
                      (match (string_drop _s1088_ _s1089_) with
                       | _s1090_ =>
                          (maybe_rl_matches_prefix _s1090_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s1091_ _)) =>
                              (match (string_drop _s1090_ _s1091_) with
                               | _s1092_ =>
                                  (spc_matches_prefix _s1092_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1093_ _)) =>
                                      (match (string_drop _s1092_ _s1093_) with
                                       | _s1094_ =>
                                          (reg_name_matches_prefix _s1094_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rd, existT _ _s1095_ _)) =>
                                              (match (string_drop _s1094_ _s1095_) with
                                               | _s1096_ =>
                                                  (sep_matches_prefix _s1096_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s1097_ _)) =>
                                                      (match (string_drop _s1096_ _s1097_) with
                                                       | _s1098_ =>
                                                          (reg_name_matches_prefix _s1098_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs1, existT _ _s1099_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s1098_ _s1099_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((size, aq, rl, rd, rs1))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((word_width * bool * bool * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 5)))
           | _ => returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5))))
    : M (option ((word_width * bool * bool * mword 5 * mword 5))).

Definition _s1071_ (_s1072_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1073_ := _s1072_ in
   (if ((string_startswith _s1073_ "sfence.vma")) then
      (match (string_drop _s1073_ (projT1 (string_length "sfence.vma"))) with
       | _s1074_ =>
          (spc_matches_prefix _s1074_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1075_ _)) =>
              (match (string_drop _s1074_ _s1075_) with
               | _s1076_ =>
                  (reg_name_matches_prefix _s1076_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs1, existT _ _s1077_ _)) =>
                      (match (string_drop _s1076_ _s1077_) with
                       | _s1078_ =>
                          (sep_matches_prefix _s1078_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1079_ _)) =>
                              (match (string_drop _s1078_ _s1079_) with
                               | _s1080_ =>
                                  (reg_name_matches_prefix _s1080_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1081_ _)) =>
                                               let p0_ := string_drop _s1080_ _s1081_ in
                                               if ((generic_eq p0_ "")) then Some ((rs1, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1059_ (_s1060_ : string) 
: M (option ((mword 4 * mword 4))) :=
   
   let _s1061_ := _s1060_ in
   (if ((string_startswith _s1061_ "fence.tso")) then
      (match (string_drop _s1061_ (projT1 (string_length "fence.tso"))) with
       | _s1062_ =>
          (spc_matches_prefix _s1062_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1063_ _)) =>
              (match (string_drop _s1062_ _s1063_) with
               | _s1064_ =>
                  (fence_bits_matches_prefix _s1064_) >>= fun w__1 : option ((mword 4 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((pred, existT _ _s1065_ _)) =>
                      (match (string_drop _s1064_ _s1065_) with
                       | _s1066_ =>
                          (sep_matches_prefix _s1066_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1067_ _)) =>
                              (match (string_drop _s1066_ _s1067_) with
                               | _s1068_ =>
                                  (fence_bits_matches_prefix _s1068_) >>= fun w__3 : option ((mword 4 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((succ, existT _ _s1069_ _)) =>
                                               let p0_ := string_drop _s1068_ _s1069_ in
                                               if ((generic_eq p0_ "")) then Some ((pred, succ))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 4 * mword 4)))
                               end)
                               : M (option ((mword 4 * mword 4)))
                           | _ => returnm (None  : option ((mword 4 * mword 4)))
                           end)
                           : M (option ((mword 4 * mword 4)))
                       end)
                       : M (option ((mword 4 * mword 4)))
                   | _ => returnm (None  : option ((mword 4 * mword 4)))
                   end)
                   : M (option ((mword 4 * mword 4)))
               end)
               : M (option ((mword 4 * mword 4)))
           | _ => returnm (None  : option ((mword 4 * mword 4)))
           end)
           : M (option ((mword 4 * mword 4)))
       end)
       : M (option ((mword 4 * mword 4)))
    else returnm (None  : option ((mword 4 * mword 4))))
    : M (option ((mword 4 * mword 4))).

Definition _s1047_ (_s1048_ : string) 
: M (option ((mword 4 * mword 4))) :=
   
   let _s1049_ := _s1048_ in
   (if ((string_startswith _s1049_ "fence")) then
      (match (string_drop _s1049_ (projT1 (string_length "fence"))) with
       | _s1050_ =>
          (spc_matches_prefix _s1050_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1051_ _)) =>
              (match (string_drop _s1050_ _s1051_) with
               | _s1052_ =>
                  (fence_bits_matches_prefix _s1052_) >>= fun w__1 : option ((mword 4 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((pred, existT _ _s1053_ _)) =>
                      (match (string_drop _s1052_ _s1053_) with
                       | _s1054_ =>
                          (sep_matches_prefix _s1054_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1055_ _)) =>
                              (match (string_drop _s1054_ _s1055_) with
                               | _s1056_ =>
                                  (fence_bits_matches_prefix _s1056_) >>= fun w__3 : option ((mword 4 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((succ, existT _ _s1057_ _)) =>
                                               let p0_ := string_drop _s1056_ _s1057_ in
                                               if ((generic_eq p0_ "")) then Some ((pred, succ))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 4 * mword 4)))
                               end)
                               : M (option ((mword 4 * mword 4)))
                           | _ => returnm (None  : option ((mword 4 * mword 4)))
                           end)
                           : M (option ((mword 4 * mword 4)))
                       end)
                       : M (option ((mword 4 * mword 4)))
                   | _ => returnm (None  : option ((mword 4 * mword 4)))
                   end)
                   : M (option ((mword 4 * mword 4)))
               end)
               : M (option ((mword 4 * mword 4)))
           | _ => returnm (None  : option ((mword 4 * mword 4)))
           end)
           : M (option ((mword 4 * mword 4)))
       end)
       : M (option ((mword 4 * mword 4)))
    else returnm (None  : option ((mword 4 * mword 4))))
    : M (option ((mword 4 * mword 4))).

Definition _s1030_ (_s1031_ : string) 
: M (option ((sopw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1031_ with
    | _s1032_ =>
       (shiftiwop_mnemonic_matches_prefix _s1032_) >>= fun w__0 : option ((sopw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1033_ _)) =>
           (match (string_drop _s1032_ _s1033_) with
            | _s1034_ =>
               (spc_matches_prefix _s1034_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1035_ _)) =>
                   (match (string_drop _s1034_ _s1035_) with
                    | _s1036_ =>
                       (reg_name_matches_prefix _s1036_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1037_ _)) =>
                           (match (string_drop _s1036_ _s1037_) with
                            | _s1038_ =>
                               (sep_matches_prefix _s1038_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1039_ _)) =>
                                   (match (string_drop _s1038_ _s1039_) with
                                    | _s1040_ =>
                                       (reg_name_matches_prefix _s1040_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1041_ _)) =>
                                           (match (string_drop _s1040_ _s1041_) with
                                            | _s1042_ =>
                                               (sep_matches_prefix _s1042_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s1043_ _)) =>
                                                            match (string_drop _s1042_ _s1043_) with
                                                            | _s1044_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s1044_) with
                                                               | Some ((shamt, existT _ _s1045_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1044_ _s1045_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sopw * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((sopw * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sopw * mword 5 * mword 5 * mword 5))).

Definition _s1013_ (_s1014_ : string) 
: M (option ((ropw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1014_ with
    | _s1015_ =>
       (rtypew_mnemonic_matches_prefix _s1015_) >>= fun w__0 : option ((ropw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1016_ _)) =>
           (match (string_drop _s1015_ _s1016_) with
            | _s1017_ =>
               (spc_matches_prefix _s1017_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1018_ _)) =>
                   (match (string_drop _s1017_ _s1018_) with
                    | _s1019_ =>
                       (reg_name_matches_prefix _s1019_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1020_ _)) =>
                           (match (string_drop _s1019_ _s1020_) with
                            | _s1021_ =>
                               (sep_matches_prefix _s1021_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1022_ _)) =>
                                   (match (string_drop _s1021_ _s1022_) with
                                    | _s1023_ =>
                                       (reg_name_matches_prefix _s1023_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1024_ _)) =>
                                           (match (string_drop _s1023_ _s1024_) with
                                            | _s1025_ =>
                                               (sep_matches_prefix _s1025_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s1026_ _)) =>
                                                   (match (string_drop _s1025_ _s1026_) with
                                                    | _s1027_ =>
                                                       (reg_name_matches_prefix _s1027_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s1028_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s1027_ _s1028_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((ropw * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((ropw * mword 5 * mword 5 * mword 5))).

Definition _s996_ (_s997_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s997_ with
    | _s998_ =>
       (shiftw_mnemonic_matches_prefix _s998_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s999_ _)) =>
           (match (string_drop _s998_ _s999_) with
            | _s1000_ =>
               (spc_matches_prefix _s1000_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1001_ _)) =>
                   (match (string_drop _s1000_ _s1001_) with
                    | _s1002_ =>
                       (reg_name_matches_prefix _s1002_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1003_ _)) =>
                           (match (string_drop _s1002_ _s1003_) with
                            | _s1004_ =>
                               (sep_matches_prefix _s1004_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1005_ _)) =>
                                   (match (string_drop _s1004_ _s1005_) with
                                    | _s1006_ =>
                                       (reg_name_matches_prefix _s1006_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1007_ _)) =>
                                           (match (string_drop _s1006_ _s1007_) with
                                            | _s1008_ =>
                                               (sep_matches_prefix _s1008_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s1009_ _)) =>
                                                            match (string_drop _s1008_ _s1009_) with
                                                            | _s1010_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s1010_) with
                                                               | Some ((shamt, existT _ _s1011_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1010_ _s1011_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 5))).

Definition _s980_ (_s981_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s982_ := _s981_ in
   (if ((string_startswith _s982_ "addiw")) then
      (match (string_drop _s982_ (projT1 (string_length "addiw"))) with
       | _s983_ =>
          (spc_matches_prefix _s983_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s984_ _)) =>
              (match (string_drop _s983_ _s984_) with
               | _s985_ =>
                  (reg_name_matches_prefix _s985_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s986_ _)) =>
                      (match (string_drop _s985_ _s986_) with
                       | _s987_ =>
                          (sep_matches_prefix _s987_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s988_ _)) =>
                              (match (string_drop _s987_ _s988_) with
                               | _s989_ =>
                                  (reg_name_matches_prefix _s989_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s990_ _)) =>
                                      (match (string_drop _s989_ _s990_) with
                                       | _s991_ =>
                                          (sep_matches_prefix _s991_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s992_ _)) =>
                                                       match (string_drop _s991_ _s992_) with
                                                       | _s993_ =>
                                                          match (hex_bits_12_matches_prefix _s993_) with
                                                          | Some ((imm, existT _ _s994_ _)) =>
                                                             let p0_ := string_drop _s993_ _s994_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s952_ (_s953_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))) :=
   
   let _s954_ := _s953_ in
   (if ((string_startswith _s954_ "s")) then
      (match (string_drop _s954_ (projT1 (string_length "s"))) with
       | _s955_ =>
          (size_mnemonic_matches_prefix _s955_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s956_ _)) =>
              (match (string_drop _s955_ _s956_) with
               | _s957_ =>
                  (maybe_aq_matches_prefix _s957_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s958_ _)) =>
                      (match (string_drop _s957_ _s958_) with
                       | _s959_ =>
                          (maybe_rl_matches_prefix _s959_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s960_ _)) =>
                              (match (string_drop _s959_ _s960_) with
                               | _s961_ =>
                                  (spc_matches_prefix _s961_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s962_ _)) =>
                                      (match (string_drop _s961_ _s962_) with
                                       | _s963_ =>
                                          (reg_name_matches_prefix _s963_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs2, existT _ _s964_ _)) =>
                                              (match (string_drop _s963_ _s964_) with
                                               | _s965_ =>
                                                  (sep_matches_prefix _s965_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s966_ _)) =>
                                                      (match (string_drop _s965_ _s966_) with
                                                       | _s967_ =>
                                                          (match (hex_bits_12_matches_prefix _s967_) with
                                                           | Some ((imm, existT _ _s968_ _)) =>
                                                              (match (string_drop _s967_ _s968_) with
                                                               | _s969_ =>
                                                                  (opt_spc_matches_prefix _s969_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__6 with
                                                                   | Some ((tt, existT _ _s970_ _)) =>
                                                                      let _s971_ :=
                                                                        string_drop _s969_ _s970_ in
                                                                      (if ((string_startswith _s971_
                                                                              "(")) then
                                                                         (match (string_drop _s971_
                                                                                   (projT1
                                                                                    (string_length
                                                                                       "("))) with
                                                                          | _s972_ =>
                                                                             (opt_spc_matches_prefix
                                                                                _s972_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                               0)})) =>
                                                                             (match w__7 with
                                                                              | Some
                                                                                ((tt, existT _ _s973_ _)) =>
                                                                                 (match (string_drop
                                                                                           _s972_
                                                                                           _s973_) with
                                                                                  | _s974_ =>
                                                                                     (reg_name_matches_prefix
                                                                                        _s974_) >>= fun w__8 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                       0)})) =>
                                                                                     (match w__8 with
                                                                                      | Some
                                                                                        ((rs1, existT _ _s975_ _)) =>
                                                                                         (match (string_drop
                                                                                                   _s974_
                                                                                                   _s975_) with
                                                                                          | _s976_ =>
                                                                                             (opt_spc_matches_prefix
                                                                                                _s976_) >>= fun w__9 : option ((unit * {n : Z & ArithFact (n >=
                                                                                               0)})) =>
                                                                                             returnm ((match w__9 with
                                                                                                       | Some
                                                                                                         ((tt, existT _ _s977_ _)) =>
                                                                                                          let _s978_ :=
                                                                                                            string_drop
                                                                                                              _s976_
                                                                                                              _s977_ in
                                                                                                          if
                                                                                                            ((string_startswith
                                                                                                                _s978_
                                                                                                                ")"))
                                                                                                          then
                                                                                                            let p0_ :=
                                                                                                              string_drop
                                                                                                                _s978_
                                                                                                                (projT1
                                                                                                                 (string_length
                                                                                                                    ")")) in
                                                                                                            if
                                                                                                              ((generic_eq
                                                                                                                  p0_
                                                                                                                  ""))
                                                                                                            then
                                                                                                              Some
                                                                                                                ((size, aq, rl, rs2, imm, rs1))
                                                                                                            else
                                                                                                              None
                                                                                                          else
                                                                                                            None
                                                                                                       | _ =>
                                                                                                          None
                                                                                                       end)
                                                                                              : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                          end)
                                                                                          : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      | _ =>
                                                                                         returnm (None
                                                                                          : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      end)
                                                                                      : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                  end)
                                                                                  : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                              | _ =>
                                                                                 returnm (None
                                                                                  : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                              end)
                                                                              : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                          end)
                                                                          : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                       else
                                                                         returnm (None
                                                                          : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))))
                                                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
           | _ =>
              returnm (None  : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))))
    : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))).

Definition _s922_ (_s923_ : string) 
: M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))) :=
   
   let _s924_ := _s923_ in
   (if ((string_startswith _s924_ "l")) then
      (match (string_drop _s924_ (projT1 (string_length "l"))) with
       | _s925_ =>
          (size_mnemonic_matches_prefix _s925_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s926_ _)) =>
              (match (string_drop _s925_ _s926_) with
               | _s927_ =>
                  (maybe_u_matches_prefix _s927_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((is_unsigned, existT _ _s928_ _)) =>
                      (match (string_drop _s927_ _s928_) with
                       | _s929_ =>
                          (maybe_aq_matches_prefix _s929_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((aq, existT _ _s930_ _)) =>
                              (match (string_drop _s929_ _s930_) with
                               | _s931_ =>
                                  (maybe_rl_matches_prefix _s931_) >>= fun w__3 : option ((bool * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rl, existT _ _s932_ _)) =>
                                      (match (string_drop _s931_ _s932_) with
                                       | _s933_ =>
                                          (spc_matches_prefix _s933_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s934_ _)) =>
                                              (match (string_drop _s933_ _s934_) with
                                               | _s935_ =>
                                                  (reg_name_matches_prefix _s935_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((rd, existT _ _s936_ _)) =>
                                                      (match (string_drop _s935_ _s936_) with
                                                       | _s937_ =>
                                                          (sep_matches_prefix _s937_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((tt, existT _ _s938_ _)) =>
                                                              (match (string_drop _s937_ _s938_) with
                                                               | _s939_ =>
                                                                  (match (hex_bits_12_matches_prefix
                                                                            _s939_) with
                                                                   | Some ((imm, existT _ _s940_ _)) =>
                                                                      (match (string_drop _s939_
                                                                                _s940_) with
                                                                       | _s941_ =>
                                                                          (opt_spc_matches_prefix
                                                                             _s941_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          (match w__7 with
                                                                           | Some
                                                                             ((tt, existT _ _s942_ _)) =>
                                                                              let _s943_ :=
                                                                                string_drop _s941_
                                                                                  _s942_ in
                                                                              (if ((string_startswith
                                                                                      _s943_ "("))
                                                                               then
                                                                                 (match (string_drop
                                                                                           _s943_
                                                                                           (projT1
                                                                                            (string_length
                                                                                               "("))) with
                                                                                  | _s944_ =>
                                                                                     (opt_spc_matches_prefix
                                                                                        _s944_) >>= fun w__8 : option ((unit * {n : Z & ArithFact (n >=
                                                                                       0)})) =>
                                                                                     (match w__8 with
                                                                                      | Some
                                                                                        ((tt, existT _ _s945_ _)) =>
                                                                                         (match (string_drop
                                                                                                   _s944_
                                                                                                   _s945_) with
                                                                                          | _s946_ =>
                                                                                             (reg_name_matches_prefix
                                                                                                _s946_) >>= fun w__9 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                               0)})) =>
                                                                                             (match w__9 with
                                                                                              | Some
                                                                                                ((rs1, existT _ _s947_ _)) =>
                                                                                                 (match (string_drop
                                                                                                           _s946_
                                                                                                           _s947_) with
                                                                                                  | _s948_ =>
                                                                                                     (opt_spc_matches_prefix
                                                                                                        _s948_) >>= fun w__10 : option ((unit * {n : Z & ArithFact (n >=
                                                                                                       0)})) =>
                                                                                                     returnm ((match w__10 with
                                                                                                               | Some
                                                                                                                 ((tt, existT _ _s949_ _)) =>
                                                                                                                  let _s950_ :=
                                                                                                                    string_drop
                                                                                                                      _s948_
                                                                                                                      _s949_ in
                                                                                                                  if
                                                                                                                    ((string_startswith
                                                                                                                        _s950_
                                                                                                                        ")"))
                                                                                                                  then
                                                                                                                    let p0_ :=
                                                                                                                      string_drop
                                                                                                                        _s950_
                                                                                                                        (projT1
                                                                                                                         (string_length
                                                                                                                            ")")) in
                                                                                                                    if
                                                                                                                      ((generic_eq
                                                                                                                          p0_
                                                                                                                          ""))
                                                                                                                    then
                                                                                                                      Some
                                                                                                                        ((size, is_unsigned, aq, rl, rd, imm, rs1))
                                                                                                                    else
                                                                                                                      None
                                                                                                                  else
                                                                                                                    None
                                                                                                               | _ =>
                                                                                                                  None
                                                                                                               end)
                                                                                                      : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                                  end)
                                                                                                  : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                              | _ =>
                                                                                                 returnm (None
                                                                                                  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                              end)
                                                                                              : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                          end)
                                                                                          : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      | _ =>
                                                                                         returnm (None
                                                                                          : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      end)
                                                                                      : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                  end)
                                                                                  : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                               else
                                                                                 returnm (None
                                                                                  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))))
                                                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                           | _ =>
                                                                              returnm (None
                                                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                           end)
                                                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                       end)
                                                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
           | _ =>
              returnm (None
               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))))
    : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))).

Definition _s905_ (_s906_ : string) 
: M (option ((rop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s906_ with
    | _s907_ =>
       (rtype_mnemonic_matches_prefix _s907_) >>= fun w__0 : option ((rop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s908_ _)) =>
           (match (string_drop _s907_ _s908_) with
            | _s909_ =>
               (spc_matches_prefix _s909_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s910_ _)) =>
                   (match (string_drop _s909_ _s910_) with
                    | _s911_ =>
                       (reg_name_matches_prefix _s911_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s912_ _)) =>
                           (match (string_drop _s911_ _s912_) with
                            | _s913_ =>
                               (sep_matches_prefix _s913_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s914_ _)) =>
                                   (match (string_drop _s913_ _s914_) with
                                    | _s915_ =>
                                       (reg_name_matches_prefix _s915_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s916_ _)) =>
                                           (match (string_drop _s915_ _s916_) with
                                            | _s917_ =>
                                               (sep_matches_prefix _s917_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s918_ _)) =>
                                                   (match (string_drop _s917_ _s918_) with
                                                    | _s919_ =>
                                                       (reg_name_matches_prefix _s919_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s920_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s919_ _s920_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((rop * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((rop * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((rop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((rop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((rop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((rop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((rop * mword 5 * mword 5 * mword 5))).

Definition _s888_ (_s889_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 6))) :=
   
   (match _s889_ with
    | _s890_ =>
       (shiftiop_mnemonic_matches_prefix _s890_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s891_ _)) =>
           (match (string_drop _s890_ _s891_) with
            | _s892_ =>
               (spc_matches_prefix _s892_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s893_ _)) =>
                   (match (string_drop _s892_ _s893_) with
                    | _s894_ =>
                       (reg_name_matches_prefix _s894_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s895_ _)) =>
                           (match (string_drop _s894_ _s895_) with
                            | _s896_ =>
                               (sep_matches_prefix _s896_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s897_ _)) =>
                                   (match (string_drop _s896_ _s897_) with
                                    | _s898_ =>
                                       (reg_name_matches_prefix _s898_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s899_ _)) =>
                                           (match (string_drop _s898_ _s899_) with
                                            | _s900_ =>
                                               (sep_matches_prefix _s900_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s901_ _)) =>
                                                            match (string_drop _s900_ _s901_) with
                                                            | _s902_ =>
                                                               match (hex_bits_6_matches_prefix
                                                                        _s902_) with
                                                               | Some ((shamt, existT _ _s903_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s902_ _s903_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 6)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 6)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 6)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 6)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 6)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 6)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 6)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 6)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 6))).

Definition _s871_ (_s872_ : string) 
: M (option ((iop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s872_ with
    | _s873_ =>
       (itype_mnemonic_matches_prefix _s873_) >>= fun w__0 : option ((iop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s874_ _)) =>
           (match (string_drop _s873_ _s874_) with
            | _s875_ =>
               (spc_matches_prefix _s875_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s876_ _)) =>
                   (match (string_drop _s875_ _s876_) with
                    | _s877_ =>
                       (reg_name_matches_prefix _s877_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s878_ _)) =>
                           (match (string_drop _s877_ _s878_) with
                            | _s879_ =>
                               (sep_matches_prefix _s879_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s880_ _)) =>
                                   (match (string_drop _s879_ _s880_) with
                                    | _s881_ =>
                                       (reg_name_matches_prefix _s881_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s882_ _)) =>
                                           (match (string_drop _s881_ _s882_) with
                                            | _s883_ =>
                                               (sep_matches_prefix _s883_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s884_ _)) =>
                                                            match (string_drop _s883_ _s884_) with
                                                            | _s885_ =>
                                                               match (hex_bits_12_matches_prefix
                                                                        _s885_) with
                                                               | Some ((imm, existT _ _s886_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s885_ _s886_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((iop * mword 5 * mword 5 * mword 12)))
                                            end)
                                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                        | _ =>
                                           returnm (None
                                            : option ((iop * mword 5 * mword 5 * mword 12)))
                                        end)
                                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                    end)
                                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                | _ =>
                                   returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                                end)
                                : M (option ((iop * mword 5 * mword 5 * mword 12)))
                            end)
                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                        end)
                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                    end)
                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                end)
                : M (option ((iop * mword 5 * mword 5 * mword 12)))
            end)
            : M (option ((iop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((iop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((iop * mword 5 * mword 5 * mword 12))).

Definition _s854_ (_s855_ : string) 
: M (option ((bop * mword 5 * mword 5 * mword 13))) :=
   
   (match _s855_ with
    | _s856_ =>
       (btype_mnemonic_matches_prefix _s856_) >>= fun w__0 : option ((bop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s857_ _)) =>
           (match (string_drop _s856_ _s857_) with
            | _s858_ =>
               (spc_matches_prefix _s858_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s859_ _)) =>
                   (match (string_drop _s858_ _s859_) with
                    | _s860_ =>
                       (reg_name_matches_prefix _s860_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rs1, existT _ _s861_ _)) =>
                           (match (string_drop _s860_ _s861_) with
                            | _s862_ =>
                               (sep_matches_prefix _s862_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s863_ _)) =>
                                   (match (string_drop _s862_ _s863_) with
                                    | _s864_ =>
                                       (reg_name_matches_prefix _s864_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs2, existT _ _s865_ _)) =>
                                           (match (string_drop _s864_ _s865_) with
                                            | _s866_ =>
                                               (sep_matches_prefix _s866_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s867_ _)) =>
                                                            match (string_drop _s866_ _s867_) with
                                                            | _s868_ =>
                                                               match (hex_bits_13_matches_prefix
                                                                        _s868_) with
                                                               | Some ((imm, existT _ _s869_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s868_ _s869_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rs1, rs2, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((bop * mword 5 * mword 5 * mword 13)))
                                            end)
                                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                        | _ =>
                                           returnm (None
                                            : option ((bop * mword 5 * mword 5 * mword 13)))
                                        end)
                                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                    end)
                                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                | _ =>
                                   returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                                end)
                                : M (option ((bop * mword 5 * mword 5 * mword 13)))
                            end)
                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                        end)
                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                    end)
                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                end)
                : M (option ((bop * mword 5 * mword 5 * mword 13)))
            end)
            : M (option ((bop * mword 5 * mword 5 * mword 13)))
        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
        end)
        : M (option ((bop * mword 5 * mword 5 * mword 13)))
    end)
    : M (option ((bop * mword 5 * mword 5 * mword 13))).

Definition _s838_ (_s839_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s840_ := _s839_ in
   (if ((string_startswith _s840_ "jalr")) then
      (match (string_drop _s840_ (projT1 (string_length "jalr"))) with
       | _s841_ =>
          (spc_matches_prefix _s841_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s842_ _)) =>
              (match (string_drop _s841_ _s842_) with
               | _s843_ =>
                  (reg_name_matches_prefix _s843_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s844_ _)) =>
                      (match (string_drop _s843_ _s844_) with
                       | _s845_ =>
                          (sep_matches_prefix _s845_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s846_ _)) =>
                              (match (string_drop _s845_ _s846_) with
                               | _s847_ =>
                                  (reg_name_matches_prefix _s847_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s848_ _)) =>
                                      (match (string_drop _s847_ _s848_) with
                                       | _s849_ =>
                                          (sep_matches_prefix _s849_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s850_ _)) =>
                                                       match (string_drop _s849_ _s850_) with
                                                       | _s851_ =>
                                                          match (hex_bits_12_matches_prefix _s851_) with
                                                          | Some ((imm, existT _ _s852_ _)) =>
                                                             let p0_ := string_drop _s851_ _s852_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s826_ (_s827_ : string) 
: M (option ((mword 5 * mword 21))) :=
   
   let _s828_ := _s827_ in
   (if ((string_startswith _s828_ "jal")) then
      (match (string_drop _s828_ (projT1 (string_length "jal"))) with
       | _s829_ =>
          (spc_matches_prefix _s829_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s830_ _)) =>
              (match (string_drop _s829_ _s830_) with
               | _s831_ =>
                  (reg_name_matches_prefix _s831_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s832_ _)) =>
                      (match (string_drop _s831_ _s832_) with
                       | _s833_ =>
                          (sep_matches_prefix _s833_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s834_ _)) =>
                                       match (string_drop _s833_ _s834_) with
                                       | _s835_ =>
                                          match (hex_bits_21_matches_prefix _s835_) with
                                          | Some ((imm, existT _ _s836_ _)) =>
                                             let p0_ := string_drop _s835_ _s836_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 21)))
                       end)
                       : M (option ((mword 5 * mword 21)))
                   | _ => returnm (None  : option ((mword 5 * mword 21)))
                   end)
                   : M (option ((mword 5 * mword 21)))
               end)
               : M (option ((mword 5 * mword 21)))
           | _ => returnm (None  : option ((mword 5 * mword 21)))
           end)
           : M (option ((mword 5 * mword 21)))
       end)
       : M (option ((mword 5 * mword 21)))
    else returnm (None  : option ((mword 5 * mword 21))))
    : M (option ((mword 5 * mword 21))).

Definition _s813_ (_s814_ : string) 
: M (option ((uop * mword 5 * mword 20))) :=
   
   (match _s814_ with
    | _s815_ =>
       (utype_mnemonic_matches_prefix _s815_) >>= fun w__0 : option ((uop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s816_ _)) =>
           (match (string_drop _s815_ _s816_) with
            | _s817_ =>
               (spc_matches_prefix _s817_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s818_ _)) =>
                   (match (string_drop _s817_ _s818_) with
                    | _s819_ =>
                       (reg_name_matches_prefix _s819_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s820_ _)) =>
                           (match (string_drop _s819_ _s820_) with
                            | _s821_ =>
                               (sep_matches_prefix _s821_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some ((tt, existT _ _s822_ _)) =>
                                            match (string_drop _s821_ _s822_) with
                                            | _s823_ =>
                                               match (hex_bits_20_matches_prefix _s823_) with
                                               | Some ((imm, existT _ _s824_ _)) =>
                                                  let p0_ := string_drop _s823_ _s824_ in
                                                  if ((generic_eq p0_ "")) then Some ((op, rd, imm))
                                                  else None
                                               | _ => None
                                               end
                                            end
                                         | _ => None
                                         end)
                                : option ((uop * mword 5 * mword 20)))
                            end)
                            : M (option ((uop * mword 5 * mword 20)))
                        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                        end)
                        : M (option ((uop * mword 5 * mword 20)))
                    end)
                    : M (option ((uop * mword 5 * mword 20)))
                | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                end)
                : M (option ((uop * mword 5 * mword 20)))
            end)
            : M (option ((uop * mword 5 * mword 20)))
        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
        end)
        : M (option ((uop * mword 5 * mword 20)))
    end)
    : M (option ((uop * mword 5 * mword 20))).

Definition assembly_backwards (arg_ : string) 
: M (ast) :=
   
   let _s825_ := arg_ in
   (_s813_ _s825_) >>= fun w__0 : option ((uop * mword 5 * mword 20)) =>
   (if ((match w__0 with | Some ((op, rd, imm)) => true | _ => false end)) then
      (_s813_ _s825_) >>= fun w__1 : option ((uop * mword 5 * mword 20)) =>
      (match w__1 with
       | Some ((op, rd, imm)) => returnm ((UTYPE ((imm, rd, op)))  : ast )
       | _ => exit tt  : M (ast)
       end)
       : M (ast)
    else
      (_s826_ _s825_) >>= fun w__4 : option ((mword 5 * mword 21)) =>
      (if ((match w__4 with | Some ((rd, imm)) => true | _ => false end)) then
         (_s826_ _s825_) >>= fun w__5 : option ((mword 5 * mword 21)) =>
         (match w__5 with
          | Some ((rd, imm)) => returnm ((RISCV_JAL ((imm, rd)))  : ast )
          | _ => exit tt  : M (ast)
          end)
          : M (ast)
       else
         (_s838_ _s825_) >>= fun w__8 : option ((mword 5 * mword 5 * mword 12)) =>
         (if ((match w__8 with | Some ((rd, rs1, imm)) => true | _ => false end)) then
            (_s838_ _s825_) >>= fun w__9 : option ((mword 5 * mword 5 * mword 12)) =>
            (match w__9 with
             | Some ((rd, rs1, imm)) => returnm ((RISCV_JALR ((imm, rs1, rd)))  : ast )
             | _ => exit tt  : M (ast)
             end)
             : M (ast)
          else
            (_s854_ _s825_) >>= fun w__12 : option ((bop * mword 5 * mword 5 * mword 13)) =>
            (if ((match w__12 with | Some ((op, rs1, rs2, imm)) => true | _ => false end)) then
               (_s854_ _s825_) >>= fun w__13 : option ((bop * mword 5 * mword 5 * mword 13)) =>
               (match w__13 with
                | Some ((op, rs1, rs2, imm)) => returnm ((BTYPE ((imm, rs2, rs1, op)))  : ast )
                | _ => exit tt  : M (ast)
                end)
                : M (ast)
             else
               (_s871_ _s825_) >>= fun w__16 : option ((iop * mword 5 * mword 5 * mword 12)) =>
               (if ((match w__16 with | Some ((op, rd, rs1, imm)) => true | _ => false end)) then
                  (_s871_ _s825_) >>= fun w__17 : option ((iop * mword 5 * mword 5 * mword 12)) =>
                  (match w__17 with
                   | Some ((op, rd, rs1, imm)) => returnm ((ITYPE ((imm, rs1, rd, op)))  : ast )
                   | _ => exit tt  : M (ast)
                   end)
                   : M (ast)
                else
                  (_s888_ _s825_) >>= fun w__20 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                  (if ((match w__20 with | Some ((op, rd, rs1, shamt)) => true | _ => false end))
                   then
                     (_s888_ _s825_) >>= fun w__21 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                     (match w__21 with
                      | Some ((op, rd, rs1, shamt)) =>
                         returnm ((SHIFTIOP ((shamt, rs1, rd, op)))  : ast )
                      | _ => exit tt  : M (ast)
                      end)
                      : M (ast)
                   else
                     (_s905_ _s825_) >>= fun w__24 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                     (if ((match w__24 with | Some ((op, rd, rs1, rs2)) => true | _ => false end))
                      then
                        (_s905_ _s825_) >>= fun w__25 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                        (match w__25 with
                         | Some ((op, rd, rs1, rs2)) =>
                            returnm ((RTYPE ((rs2, rs1, rd, op)))  : ast )
                         | _ => exit tt  : M (ast)
                         end)
                         : M (ast)
                      else
                        (_s922_ _s825_) >>= fun w__28 : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)) =>
                        (if ((match w__28 with
                              | Some ((size, is_unsigned, aq, rl, rd, imm, rs1)) => true
                              | _ => false
                              end)) then
                           (_s922_ _s825_) >>= fun w__29 : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)) =>
                           (match w__29 with
                            | Some ((size, is_unsigned, aq, rl, rd, imm, rs1)) =>
                               returnm ((LOAD ((imm, rs1, rd, is_unsigned, size, aq, rl)))  : ast )
                            | _ => exit tt  : M (ast)
                            end)
                            : M (ast)
                         else
                           (_s952_ _s825_) >>= fun w__32 : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)) =>
                           (if ((match w__32 with
                                 | Some ((size, aq, rl, rs2, imm, rs1)) => true
                                 | _ => false
                                 end)) then
                              (_s952_ _s825_) >>= fun w__33 : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)) =>
                              (match w__33 with
                               | Some ((size, aq, rl, rs2, imm, rs1)) =>
                                  returnm ((STORE ((imm, rs2, rs1, size, aq, rl)))  : ast )
                               | _ => exit tt  : M (ast)
                               end)
                               : M (ast)
                            else
                              (_s980_ _s825_) >>= fun w__36 : option ((mword 5 * mword 5 * mword 12)) =>
                              (if ((match w__36 with
                                    | Some ((rd, rs1, imm)) => Z.eqb 64 64
                                    | _ => false
                                    end)) then
                                 (_s980_ _s825_) >>= fun w__37 : option ((mword 5 * mword 5 * mword 12)) =>
                                 (match w__37 with
                                  | Some ((rd, rs1, imm)) =>
                                     returnm ((ADDIW ((imm, rs1, rd)))  : ast )
                                  | _ => exit tt  : M (ast)
                                  end)
                                  : M (ast)
                               else
                                 (_s996_ _s825_) >>= fun w__40 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                                 (if ((match w__40 with
                                       | Some ((op, rd, rs1, shamt)) => Z.eqb 64 64
                                       | _ => false
                                       end)) then
                                    (_s996_ _s825_) >>= fun w__41 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                                    (match w__41 with
                                     | Some ((op, rd, rs1, shamt)) =>
                                        returnm ((SHIFTW ((shamt, rs1, rd, op)))  : ast )
                                     | _ => exit tt  : M (ast)
                                     end)
                                     : M (ast)
                                  else
                                    (_s1013_ _s825_) >>= fun w__44 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                                    (if ((match w__44 with
                                          | Some ((op, rd, rs1, rs2)) => Z.eqb 64 64
                                          | _ => false
                                          end)) then
                                       (_s1013_ _s825_) >>= fun w__45 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                                       (match w__45 with
                                        | Some ((op, rd, rs1, rs2)) =>
                                           returnm ((RTYPEW ((rs2, rs1, rd, op)))  : ast )
                                        | _ => exit tt  : M (ast)
                                        end)
                                        : M (ast)
                                     else
                                       (_s1030_ _s825_) >>= fun w__48 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                       (if ((match w__48 with
                                             | Some ((op, rd, rs1, shamt)) => Z.eqb 64 64
                                             | _ => false
                                             end)) then
                                          (_s1030_ _s825_) >>= fun w__49 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                          (match w__49 with
                                           | Some ((op, rd, rs1, shamt)) =>
                                              returnm ((SHIFTIWOP ((shamt, rs1, rd, op)))  : ast )
                                           | _ => exit tt  : M (ast)
                                           end)
                                           : M (ast)
                                        else
                                          (_s1047_ _s825_) >>= fun w__52 : option ((mword 4 * mword 4)) =>
                                          (if ((match w__52 with
                                                | Some ((pred, succ)) => true
                                                | _ => false
                                                end)) then
                                             (_s1047_ _s825_) >>= fun w__53 : option ((mword 4 * mword 4)) =>
                                             (match w__53 with
                                              | Some ((pred, succ)) =>
                                                 returnm ((FENCE ((pred, succ)))  : ast )
                                              | _ => exit tt  : M (ast)
                                              end)
                                              : M (ast)
                                           else
                                             (_s1059_ _s825_) >>= fun w__56 : option ((mword 4 * mword 4)) =>
                                             (if ((match w__56 with
                                                   | Some ((pred, succ)) => true
                                                   | _ => false
                                                   end)) then
                                                (_s1059_ _s825_) >>= fun w__57 : option ((mword 4 * mword 4)) =>
                                                (match w__57 with
                                                 | Some ((pred, succ)) =>
                                                    returnm ((FENCE_TSO ((pred, succ)))  : ast )
                                                 | _ => exit tt  : M (ast)
                                                 end)
                                                 : M (ast)
                                              else if ((generic_eq _s825_ "fence.i")) then
                                                returnm ((FENCEI
                                                            (tt))
                                                 : ast )
                                              else if ((generic_eq _s825_ "ecall")) then
                                                returnm ((ECALL
                                                            (tt))
                                                 : ast )
                                              else if ((generic_eq _s825_ "mret")) then
                                                returnm ((MRET
                                                            (tt))
                                                 : ast )
                                              else if ((generic_eq _s825_ "sret")) then
                                                returnm ((SRET
                                                            (tt))
                                                 : ast )
                                              else if ((generic_eq _s825_ "ebreak")) then
                                                returnm ((EBREAK
                                                            (tt))
                                                 : ast )
                                              else if ((generic_eq _s825_ "wfi")) then
                                                returnm ((WFI
                                                            (tt))
                                                 : ast )
                                              else
                                                (_s1071_ _s825_) >>= fun w__60 : option ((mword 5 * mword 5)) =>
                                                (if ((match w__60 with
                                                      | Some ((rs1, rs2)) => true
                                                      | _ => false
                                                      end)) then
                                                   (_s1071_ _s825_) >>= fun w__61 : option ((mword 5 * mword 5)) =>
                                                   (match w__61 with
                                                    | Some ((rs1, rs2)) =>
                                                       returnm ((SFENCE_VMA ((rs1, rs2)))  : ast )
                                                    | _ => exit tt  : M (ast)
                                                    end)
                                                    : M (ast)
                                                 else
                                                   (_s1083_ _s825_) >>= fun w__64 : option ((word_width * bool * bool * mword 5 * mword 5)) =>
                                                   (if ((match w__64 with
                                                         | Some ((size, aq, rl, rd, rs1)) => true
                                                         | _ => false
                                                         end)) then
                                                      (_s1083_ _s825_) >>= fun w__65 : option ((word_width * bool * bool * mword 5 * mword 5)) =>
                                                      (match w__65 with
                                                       | Some ((size, aq, rl, rd, rs1)) =>
                                                          returnm ((LOADRES
                                                                      ((aq, rl, rs1, size, rd)))
                                                           : ast )
                                                       | _ => exit tt  : M (ast)
                                                       end)
                                                       : M (ast)
                                                    else
                                                      (_s1101_ _s825_) >>= fun w__68 : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                      (if ((match w__68 with
                                                            | Some ((size, aq, rl, rd, rs1, rs2)) =>
                                                               true
                                                            | _ => false
                                                            end)) then
                                                         (_s1101_ _s825_) >>= fun w__69 : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                         (match w__69 with
                                                          | Some ((size, aq, rl, rd, rs1, rs2)) =>
                                                             returnm ((STORECON
                                                                         ((aq, rl, rs2, rs1, size, rd)))
                                                              : ast )
                                                          | _ => exit tt  : M (ast)
                                                          end)
                                                          : M (ast)
                                                       else
                                                         (_s1123_ _s825_) >>= fun w__72 : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                         (if ((match w__72 with
                                                               | Some
                                                                 ((op, width, aq, rl, rd, rs1, rs2)) =>
                                                                  true
                                                               | _ => false
                                                               end)) then
                                                            (_s1123_ _s825_) >>= fun w__73 : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                            (match w__73 with
                                                             | Some
                                                               ((op, width, aq, rl, rd, rs1, rs2)) =>
                                                                returnm ((AMO
                                                                            ((op, aq, rl, rs2, rs1, width, rd)))
                                                                 : ast )
                                                             | _ => exit tt  : M (ast)
                                                             end)
                                                             : M (ast)
                                                          else if ((generic_eq _s825_ "c.nop")) then
                                                            returnm ((C_NOP
                                                                        (tt))
                                                             : ast )
                                                          else
                                                            (_s1147_ _s825_) >>= fun w__76 : option ((mword 3 * mword 8)) =>
                                                            (if ((match w__76 with
                                                                  | Some ((rdc, nzimm)) =>
                                                                     neq_vec nzimm
                                                                       (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]
                                                                         : mword 8)
                                                                  | _ => false
                                                                  end)) then
                                                               (_s1147_ _s825_) >>= fun w__77 : option ((mword 3 * mword 8)) =>
                                                               (match w__77 with
                                                                | Some ((rdc, nzimm)) =>
                                                                   returnm ((C_ADDI4SPN
                                                                               ((rdc, nzimm)))
                                                                    : ast )
                                                                | _ => exit tt  : M (ast)
                                                                end)
                                                                : M (ast)
                                                             else
                                                               (_s1159_ _s825_) >>= fun w__80 : option ((mword 3 * mword 3 * mword 5)) =>
                                                               (if ((match w__80 with
                                                                     | Some ((rdc, rsc, uimm)) =>
                                                                        true
                                                                     | _ => false
                                                                     end)) then
                                                                  (_s1159_ _s825_) >>= fun w__81 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                  (match w__81 with
                                                                   | Some ((rdc, rsc, uimm)) =>
                                                                      returnm ((C_LW
                                                                                  ((uimm, rsc, rdc)))
                                                                       : ast )
                                                                   | _ => exit tt  : M (ast)
                                                                   end)
                                                                   : M (ast)
                                                                else
                                                                  (_s1175_ _s825_) >>= fun w__84 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                  (if ((match w__84 with
                                                                        | Some ((rdc, rsc, uimm)) =>
                                                                           Z.eqb 64 64
                                                                        | _ => false
                                                                        end)) then
                                                                     (_s1175_ _s825_) >>= fun w__85 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                     (match w__85 with
                                                                      | Some ((rdc, rsc, uimm)) =>
                                                                         returnm ((C_LD
                                                                                     ((uimm, rsc, rdc)))
                                                                          : ast )
                                                                      | _ => exit tt  : M (ast)
                                                                      end)
                                                                      : M (ast)
                                                                   else
                                                                     (_s1191_ _s825_) >>= fun w__88 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                     (if ((match w__88 with
                                                                           | Some
                                                                             ((rsc1, rsc2, uimm)) =>
                                                                              true
                                                                           | _ => false
                                                                           end)) then
                                                                        (_s1191_ _s825_) >>= fun w__89 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                        (match w__89 with
                                                                         | Some ((rsc1, rsc2, uimm)) =>
                                                                            returnm ((C_SW
                                                                                        ((uimm, rsc1, rsc2)))
                                                                             : ast )
                                                                         | _ => exit tt  : M (ast)
                                                                         end)
                                                                         : M (ast)
                                                                      else
                                                                        (_s1207_ _s825_) >>= fun w__92 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                        (if ((match w__92 with
                                                                              | Some
                                                                                ((rsc1, rsc2, uimm)) =>
                                                                                 Z.eqb 64 64
                                                                              | _ => false
                                                                              end)) then
                                                                           (_s1207_ _s825_) >>= fun w__93 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                           (match w__93 with
                                                                            | Some
                                                                              ((rsc1, rsc2, uimm)) =>
                                                                               returnm ((C_SD
                                                                                           ((uimm, rsc1, rsc2)))
                                                                                : ast )
                                                                            | _ =>
                                                                               exit tt  : M (ast)
                                                                            end)
                                                                            : M (ast)
                                                                         else
                                                                           (_s1223_ _s825_) >>= fun w__96 : option ((mword 5 * mword 6)) =>
                                                                           (if ((match w__96 with
                                                                                 | Some ((rsd, nzi)) =>
                                                                                    andb
                                                                                      (neq_vec nzi
                                                                                         (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                           : mword 6))
                                                                                      ((projT1
                                                                                        (neq_int
                                                                                           (projT1
                                                                                            (regidx_to_regno
                                                                                               rsd))
                                                                                           (projT1
                                                                                            (regidx_to_regno
                                                                                               zreg))))
                                                                                       : bool)
                                                                                 | _ => false
                                                                                 end)) then
                                                                              (_s1223_ _s825_) >>= fun w__97 : option ((mword 5 * mword 6)) =>
                                                                              (match w__97 with
                                                                               | Some ((rsd, nzi)) =>
                                                                                  returnm ((C_ADDI
                                                                                              ((nzi, rsd)))
                                                                                   : ast )
                                                                               | _ =>
                                                                                  exit tt  : M (ast)
                                                                               end)
                                                                               : M (ast)
                                                                            else
                                                                              (_s1235_ _s825_) >>= fun w__100 : option (mword 11) =>
                                                                              (if ((match w__100 with
                                                                                    | Some (imm) =>
                                                                                       Z.eqb 64 32
                                                                                    | _ => false
                                                                                    end)) then
                                                                                 (_s1235_ _s825_) >>= fun w__101 : option (mword 11) =>
                                                                                 (match w__101 with
                                                                                  | Some (imm) =>
                                                                                     returnm ((C_JAL
                                                                                                 (imm))
                                                                                      : ast )
                                                                                  | _ =>
                                                                                     exit tt
                                                                                      : M (ast)
                                                                                  end)
                                                                                  : M (ast)
                                                                               else
                                                                                 (_s1243_ _s825_) >>= fun w__104 : option ((mword 5 * mword 6)) =>
                                                                                 (if ((match w__104 with
                                                                                       | Some
                                                                                         ((rsd, imm)) =>
                                                                                          Z.eqb 64
                                                                                            64
                                                                                       | _ => false
                                                                                       end)) then
                                                                                    (_s1243_ _s825_) >>= fun w__105 : option ((mword 5 * mword 6)) =>
                                                                                    (match w__105 with
                                                                                     | Some
                                                                                       ((rsd, imm)) =>
                                                                                        returnm ((C_ADDIW
                                                                                                    ((imm, rsd)))
                                                                                         : ast )
                                                                                     | _ =>
                                                                                        exit tt
                                                                                         : M (ast)
                                                                                     end)
                                                                                     : M (ast)
                                                                                  else
                                                                                    (_s1255_ _s825_) >>= fun w__108 : option ((mword 5 * mword 6)) =>
                                                                                    (if ((match w__108 with
                                                                                          | Some
                                                                                            ((rd, imm)) =>
                                                                                             projT1
                                                                                             (neq_int
                                                                                                (projT1
                                                                                                 (regidx_to_regno
                                                                                                    rd))
                                                                                                (projT1
                                                                                                 (regidx_to_regno
                                                                                                    zreg)))
                                                                                          | _ =>
                                                                                             false
                                                                                          end)) then
                                                                                       (_s1255_
                                                                                          _s825_) >>= fun w__109 : option ((mword 5 * mword 6)) =>
                                                                                       (match w__109 with
                                                                                        | Some
                                                                                          ((rd, imm)) =>
                                                                                           returnm ((C_LI
                                                                                                       ((imm, rd)))
                                                                                            : ast )
                                                                                        | _ =>
                                                                                           exit tt
                                                                                            : M (ast)
                                                                                        end)
                                                                                        : M (ast)
                                                                                     else
                                                                                       (_s1267_
                                                                                          _s825_) >>= fun w__112 : option (mword 6) =>
                                                                                       (if ((match w__112 with
                                                                                             | Some
                                                                                               (imm) =>
                                                                                                neq_vec
                                                                                                  imm
                                                                                                  (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                    : mword 6)
                                                                                             | _ =>
                                                                                                false
                                                                                             end))
                                                                                        then
                                                                                          (_s1267_
                                                                                             _s825_) >>= fun w__113 : option (mword 6) =>
                                                                                          (match w__113 with
                                                                                           | Some
                                                                                             (imm) =>
                                                                                              returnm ((C_ADDI16SP
                                                                                                          (imm))
                                                                                               : ast )
                                                                                           | _ =>
                                                                                              exit tt
                                                                                               : M (ast)
                                                                                           end)
                                                                                           : M (ast)
                                                                                        else
                                                                                          (_s1275_
                                                                                             _s825_) >>= fun w__116 : option ((mword 5 * mword 6)) =>
                                                                                          (if ((match w__116 with
                                                                                                | Some
                                                                                                  ((rd, imm)) =>
                                                                                                   andb
                                                                                                     (projT1
                                                                                                      (neq_int
                                                                                                         (projT1
                                                                                                          (regidx_to_regno
                                                                                                             rd))
                                                                                                         (projT1
                                                                                                          (regidx_to_regno
                                                                                                             zreg))))
                                                                                                     ((andb
                                                                                                         (projT1
                                                                                                          (neq_int
                                                                                                             (projT1
                                                                                                              (regidx_to_regno
                                                                                                                 rd))
                                                                                                             (projT1
                                                                                                              (regidx_to_regno
                                                                                                                 sp))))
                                                                                                         (neq_vec
                                                                                                            imm
                                                                                                            (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                              : mword 6)))
                                                                                                      : bool)
                                                                                                | _ =>
                                                                                                   false
                                                                                                end))
                                                                                           then
                                                                                             (_s1275_
                                                                                                _s825_) >>= fun w__117 : option ((mword 5 * mword 6)) =>
                                                                                             (match w__117 with
                                                                                              | Some
                                                                                                ((rd, imm)) =>
                                                                                                 returnm ((C_LUI
                                                                                                             ((imm, rd)))
                                                                                                  : ast )
                                                                                              | _ =>
                                                                                                 exit tt
                                                                                                  : M (ast)
                                                                                              end)
                                                                                              : M (ast)
                                                                                           else
                                                                                             (_s1287_
                                                                                                _s825_) >>= fun w__120 : option ((mword 3 * mword 6)) =>
                                                                                             (if ((match w__120 with
                                                                                                   | Some
                                                                                                     ((rsd, shamt)) =>
                                                                                                      neq_vec
                                                                                                        shamt
                                                                                                        (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                          : mword 6)
                                                                                                   | _ =>
                                                                                                      false
                                                                                                   end))
                                                                                              then
                                                                                                (_s1287_
                                                                                                   _s825_) >>= fun w__121 : option ((mword 3 * mword 6)) =>
                                                                                                (match w__121 with
                                                                                                 | Some
                                                                                                   ((rsd, shamt)) =>
                                                                                                    returnm ((C_SRLI
                                                                                                                ((shamt, rsd)))
                                                                                                     : ast )
                                                                                                 | _ =>
                                                                                                    exit tt
                                                                                                     : M (ast)
                                                                                                 end)
                                                                                                 : M (ast)
                                                                                              else
                                                                                                (_s1299_
                                                                                                   _s825_) >>= fun w__124 : option ((mword 3 * mword 6)) =>
                                                                                                (if ((match w__124 with
                                                                                                      | Some
                                                                                                        ((rsd, shamt)) =>
                                                                                                         neq_vec
                                                                                                           shamt
                                                                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                             : mword 6)
                                                                                                      | _ =>
                                                                                                         false
                                                                                                      end))
                                                                                                 then
                                                                                                   (_s1299_
                                                                                                      _s825_) >>= fun w__125 : option ((mword 3 * mword 6)) =>
                                                                                                   (match w__125 with
                                                                                                    | Some
                                                                                                      ((rsd, shamt)) =>
                                                                                                       returnm ((C_SRAI
                                                                                                                   ((shamt, rsd)))
                                                                                                        : ast )
                                                                                                    | _ =>
                                                                                                       exit tt
                                                                                                        : M (ast)
                                                                                                    end)
                                                                                                    : M (ast)
                                                                                                 else
                                                                                                   (_s1311_
                                                                                                      _s825_) >>= fun w__128 : option ((mword 3 * mword 6)) =>
                                                                                                   (if
                                                                                                      ((match w__128 with
                                                                                                        | Some
                                                                                                          ((rsd, imm)) =>
                                                                                                           true
                                                                                                        | _ =>
                                                                                                           false
                                                                                                        end))
                                                                                                    then
                                                                                                      (_s1311_
                                                                                                         _s825_) >>= fun w__129 : option ((mword 3 * mword 6)) =>
                                                                                                      (match w__129 with
                                                                                                       | Some
                                                                                                         ((rsd, imm)) =>
                                                                                                          returnm ((C_ANDI
                                                                                                                      ((imm, rsd)))
                                                                                                           : ast )
                                                                                                       | _ =>
                                                                                                          exit tt
                                                                                                           : M (ast)
                                                                                                       end)
                                                                                                       : M (ast)
                                                                                                    else
                                                                                                      (_s1323_
                                                                                                         _s825_) >>= fun w__132 : option ((mword 3 * mword 3)) =>
                                                                                                      (if
                                                                                                         ((match w__132 with
                                                                                                           | Some
                                                                                                             ((rsd, rs2)) =>
                                                                                                              true
                                                                                                           | _ =>
                                                                                                              false
                                                                                                           end))
                                                                                                       then
                                                                                                         (_s1323_
                                                                                                            _s825_) >>= fun w__133 : option ((mword 3 * mword 3)) =>
                                                                                                         (match w__133 with
                                                                                                          | Some
                                                                                                            ((rsd, rs2)) =>
                                                                                                             returnm ((C_SUB
                                                                                                                         ((rsd, rs2)))
                                                                                                              : ast )
                                                                                                          | _ =>
                                                                                                             exit tt
                                                                                                              : M (ast)
                                                                                                          end)
                                                                                                          : M (ast)
                                                                                                       else
                                                                                                         (_s1335_
                                                                                                            _s825_) >>= fun w__136 : option ((mword 3 * mword 3)) =>
                                                                                                         (if
                                                                                                            ((match w__136 with
                                                                                                              | Some
                                                                                                                ((rsd, rs2)) =>
                                                                                                                 true
                                                                                                              | _ =>
                                                                                                                 false
                                                                                                              end))
                                                                                                          then
                                                                                                            (_s1335_
                                                                                                               _s825_) >>= fun w__137 : option ((mword 3 * mword 3)) =>
                                                                                                            (match w__137 with
                                                                                                             | Some
                                                                                                               ((rsd, rs2)) =>
                                                                                                                returnm ((C_XOR
                                                                                                                            ((rsd, rs2)))
                                                                                                                 : ast )
                                                                                                             | _ =>
                                                                                                                exit tt
                                                                                                                 : M (ast)
                                                                                                             end)
                                                                                                             : M (ast)
                                                                                                          else
                                                                                                            (_s1347_
                                                                                                               _s825_) >>= fun w__140 : option ((mword 3 * mword 3)) =>
                                                                                                            (if
                                                                                                               ((match w__140 with
                                                                                                                 | Some
                                                                                                                   ((rsd, rs2)) =>
                                                                                                                    true
                                                                                                                 | _ =>
                                                                                                                    false
                                                                                                                 end))
                                                                                                             then
                                                                                                               (_s1347_
                                                                                                                  _s825_) >>= fun w__141 : option ((mword 3 * mword 3)) =>
                                                                                                               (match w__141 with
                                                                                                                | Some
                                                                                                                  ((rsd, rs2)) =>
                                                                                                                   returnm ((C_OR
                                                                                                                               ((rsd, rs2)))
                                                                                                                    : ast )
                                                                                                                | _ =>
                                                                                                                   exit tt
                                                                                                                    : M (ast)
                                                                                                                end)
                                                                                                                : M (ast)
                                                                                                             else
                                                                                                               (_s1359_
                                                                                                                  _s825_) >>= fun w__144 : option ((mword 3 * mword 3)) =>
                                                                                                               (if
                                                                                                                  ((match w__144 with
                                                                                                                    | Some
                                                                                                                      ((rsd, rs2)) =>
                                                                                                                       true
                                                                                                                    | _ =>
                                                                                                                       false
                                                                                                                    end))
                                                                                                                then
                                                                                                                  (_s1359_
                                                                                                                     _s825_) >>= fun w__145 : option ((mword 3 * mword 3)) =>
                                                                                                                  (match w__145 with
                                                                                                                   | Some
                                                                                                                     ((rsd, rs2)) =>
                                                                                                                      returnm ((C_AND
                                                                                                                                  ((rsd, rs2)))
                                                                                                                       : ast )
                                                                                                                   | _ =>
                                                                                                                      exit tt
                                                                                                                       : M (ast)
                                                                                                                   end)
                                                                                                                   : M (ast)
                                                                                                                else
                                                                                                                  (_s1371_
                                                                                                                     _s825_) >>= fun w__148 : option ((mword 3 * mword 3)) =>
                                                                                                                  (if
                                                                                                                     ((match w__148 with
                                                                                                                       | Some
                                                                                                                         ((rsd, rs2)) =>
                                                                                                                          Z.eqb
                                                                                                                            64
                                                                                                                            64
                                                                                                                       | _ =>
                                                                                                                          false
                                                                                                                       end))
                                                                                                                   then
                                                                                                                     (_s1371_
                                                                                                                        _s825_) >>= fun w__149 : option ((mword 3 * mword 3)) =>
                                                                                                                     (match w__149 with
                                                                                                                      | Some
                                                                                                                        ((rsd, rs2)) =>
                                                                                                                         returnm ((C_SUBW
                                                                                                                                     ((rsd, rs2)))
                                                                                                                          : ast )
                                                                                                                      | _ =>
                                                                                                                         exit tt
                                                                                                                          : M (ast)
                                                                                                                      end)
                                                                                                                      : M (ast)
                                                                                                                   else
                                                                                                                     (_s1383_
                                                                                                                        _s825_) >>= fun w__152 : option ((mword 3 * mword 3)) =>
                                                                                                                     (if
                                                                                                                        ((match w__152 with
                                                                                                                          | Some
                                                                                                                            ((rsd, rs2)) =>
                                                                                                                             Z.eqb
                                                                                                                               64
                                                                                                                               64
                                                                                                                          | _ =>
                                                                                                                             false
                                                                                                                          end))
                                                                                                                      then
                                                                                                                        (_s1383_
                                                                                                                           _s825_) >>= fun w__153 : option ((mword 3 * mword 3)) =>
                                                                                                                        (match w__153 with
                                                                                                                         | Some
                                                                                                                           ((rsd, rs2)) =>
                                                                                                                            returnm ((C_ADDW
                                                                                                                                        ((rsd, rs2)))
                                                                                                                             : ast )
                                                                                                                         | _ =>
                                                                                                                            exit tt
                                                                                                                             : M (ast)
                                                                                                                         end)
                                                                                                                         : M (ast)
                                                                                                                      else
                                                                                                                        (_s1395_
                                                                                                                           _s825_) >>= fun w__156 : option (mword 11) =>
                                                                                                                        (if
                                                                                                                           ((match w__156 with
                                                                                                                             | Some
                                                                                                                               (imm) =>
                                                                                                                                true
                                                                                                                             | _ =>
                                                                                                                                false
                                                                                                                             end))
                                                                                                                         then
                                                                                                                           (_s1395_
                                                                                                                              _s825_) >>= fun w__157 : option (mword 11) =>
                                                                                                                           (match w__157 with
                                                                                                                            | Some
                                                                                                                              (imm) =>
                                                                                                                               returnm ((C_J
                                                                                                                                           (imm))
                                                                                                                                : ast )
                                                                                                                            | _ =>
                                                                                                                               exit tt
                                                                                                                                : M (ast)
                                                                                                                            end)
                                                                                                                            : M (ast)
                                                                                                                         else
                                                                                                                           (_s1403_
                                                                                                                              _s825_) >>= fun w__160 : option ((mword 3 * mword 8)) =>
                                                                                                                           (if
                                                                                                                              ((match w__160 with
                                                                                                                                | Some
                                                                                                                                  ((rs, imm)) =>
                                                                                                                                   true
                                                                                                                                | _ =>
                                                                                                                                   false
                                                                                                                                end))
                                                                                                                            then
                                                                                                                              (_s1403_
                                                                                                                                 _s825_) >>= fun w__161 : option ((mword 3 * mword 8)) =>
                                                                                                                              (match w__161 with
                                                                                                                               | Some
                                                                                                                                 ((rs, imm)) =>
                                                                                                                                  returnm ((C_BEQZ
                                                                                                                                              ((imm, rs)))
                                                                                                                                   : ast )
                                                                                                                               | _ =>
                                                                                                                                  exit tt
                                                                                                                                   : M (ast)
                                                                                                                               end)
                                                                                                                               : M (ast)
                                                                                                                            else
                                                                                                                              (_s1415_
                                                                                                                                 _s825_) >>= fun w__164 : option ((mword 3 * mword 8)) =>
                                                                                                                              (if
                                                                                                                                 ((match w__164 with
                                                                                                                                   | Some
                                                                                                                                     ((rs, imm)) =>
                                                                                                                                      true
                                                                                                                                   | _ =>
                                                                                                                                      false
                                                                                                                                   end))
                                                                                                                               then
                                                                                                                                 (_s1415_
                                                                                                                                    _s825_) >>= fun w__165 : option ((mword 3 * mword 8)) =>
                                                                                                                                 (match w__165 with
                                                                                                                                  | Some
                                                                                                                                    ((rs, imm)) =>
                                                                                                                                     returnm ((C_BNEZ
                                                                                                                                                 ((imm, rs)))
                                                                                                                                      : ast )
                                                                                                                                  | _ =>
                                                                                                                                     exit tt
                                                                                                                                      : M (ast)
                                                                                                                                  end)
                                                                                                                                  : M (ast)
                                                                                                                               else
                                                                                                                                 (_s1427_
                                                                                                                                    _s825_) >>= fun w__168 : option ((mword 5 * mword 6)) =>
                                                                                                                                 (if
                                                                                                                                    ((match w__168 with
                                                                                                                                      | Some
                                                                                                                                        ((rsd, shamt)) =>
                                                                                                                                         andb
                                                                                                                                           (neq_vec
                                                                                                                                              shamt
                                                                                                                                              (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                                                                : mword 6))
                                                                                                                                           ((projT1
                                                                                                                                             (neq_int
                                                                                                                                                (projT1
                                                                                                                                                 (regidx_to_regno
                                                                                                                                                    rsd))
                                                                                                                                                (projT1
                                                                                                                                                 (regidx_to_regno
                                                                                                                                                    zreg))))
                                                                                                                                            : bool)
                                                                                                                                      | _ =>
                                                                                                                                         false
                                                                                                                                      end))
                                                                                                                                  then
                                                                                                                                    (_s1427_
                                                                                                                                       _s825_) >>= fun w__169 : option ((mword 5 * mword 6)) =>
                                                                                                                                    (match w__169 with
                                                                                                                                     | Some
                                                                                                                                       ((rsd, shamt)) =>
                                                                                                                                        returnm ((C_SLLI
                                                                                                                                                    ((shamt, rsd)))
                                                                                                                                         : ast )
                                                                                                                                     | _ =>
                                                                                                                                        exit tt
                                                                                                                                         : M (ast)
                                                                                                                                     end)
                                                                                                                                     : M (ast)
                                                                                                                                  else
                                                                                                                                    (_s1439_
                                                                                                                                       _s825_) >>= fun w__172 : option ((mword 5 * mword 6)) =>
                                                                                                                                    (if
                                                                                                                                       ((match w__172 with
                                                                                                                                         | Some
                                                                                                                                           ((rd, uimm)) =>
                                                                                                                                            projT1
                                                                                                                                            (neq_int
                                                                                                                                               (projT1
                                                                                                                                                (regidx_to_regno
                                                                                                                                                   rd))
                                                                                                                                               (projT1
                                                                                                                                                (regidx_to_regno
                                                                                                                                                   zreg)))
                                                                                                                                         | _ =>
                                                                                                                                            false
                                                                                                                                         end))
                                                                                                                                     then
                                                                                                                                       (_s1439_
                                                                                                                                          _s825_) >>= fun w__173 : option ((mword 5 * mword 6)) =>
                                                                                                                                       (match w__173 with
                                                                                                                                        | Some
                                                                                                                                          ((rd, uimm)) =>
                                                                                                                                           returnm ((C_LWSP
                                                                                                                                                       ((uimm, rd)))
                                                                                                                                            : ast )
                                                                                                                                        | _ =>
                                                                                                                                           exit tt
                                                                                                                                            : M (ast)
                                                                                                                                        end)
                                                                                                                                        : M (ast)
                                                                                                                                     else
                                                                                                                                       (_s1451_
                                                                                                                                          _s825_) >>= fun w__176 : option ((mword 5 * mword 6)) =>
                                                                                                                                       (if
                                                                                                                                          ((match w__176 with
                                                                                                                                            | Some
                                                                                                                                              ((rd, uimm)) =>
                                                                                                                                               andb
                                                                                                                                                 (projT1
                                                                                                                                                  (neq_int
                                                                                                                                                     (projT1
                                                                                                                                                      (regidx_to_regno
                                                                                                                                                         rd))
                                                                                                                                                     (projT1
                                                                                                                                                      (regidx_to_regno
                                                                                                                                                         zreg))))
                                                                                                                                                 (Z.eqb
                                                                                                                                                    64
                                                                                                                                                    64)
                                                                                                                                            | _ =>
                                                                                                                                               false
                                                                                                                                            end))
                                                                                                                                        then
                                                                                                                                          (_s1451_
                                                                                                                                             _s825_) >>= fun w__177 : option ((mword 5 * mword 6)) =>
                                                                                                                                          (match w__177 with
                                                                                                                                           | Some
                                                                                                                                             ((rd, uimm)) =>
                                                                                                                                              returnm ((C_LDSP
                                                                                                                                                          ((uimm, rd)))
                                                                                                                                               : ast )
                                                                                                                                           | _ =>
                                                                                                                                              exit tt
                                                                                                                                               : M (ast)
                                                                                                                                           end)
                                                                                                                                           : M (ast)
                                                                                                                                        else
                                                                                                                                          (_s1463_
                                                                                                                                             _s825_) >>= fun w__180 : option ((mword 5 * mword 6)) =>
                                                                                                                                          (if
                                                                                                                                             ((match w__180 with
                                                                                                                                               | Some
                                                                                                                                                 ((rd, uimm)) =>
                                                                                                                                                  true
                                                                                                                                               | _ =>
                                                                                                                                                  false
                                                                                                                                               end))
                                                                                                                                           then
                                                                                                                                             (_s1463_
                                                                                                                                                _s825_) >>= fun w__181 : option ((mword 5 * mword 6)) =>
                                                                                                                                             (match w__181 with
                                                                                                                                              | Some
                                                                                                                                                ((rd, uimm)) =>
                                                                                                                                                 returnm ((C_SWSP
                                                                                                                                                             ((uimm, rd)))
                                                                                                                                                  : ast )
                                                                                                                                              | _ =>
                                                                                                                                                 exit tt
                                                                                                                                                  : M (ast)
                                                                                                                                              end)
                                                                                                                                              : M (ast)
                                                                                                                                           else
                                                                                                                                             (_s1475_
                                                                                                                                                _s825_) >>= fun w__184 : option ((mword 5 * mword 6)) =>
                                                                                                                                             (if
                                                                                                                                                ((match w__184 with
                                                                                                                                                  | Some
                                                                                                                                                    ((rs2, uimm)) =>
                                                                                                                                                     Z.eqb
                                                                                                                                                       64
                                                                                                                                                       64
                                                                                                                                                  | _ =>
                                                                                                                                                     false
                                                                                                                                                  end))
                                                                                                                                              then
                                                                                                                                                (_s1475_
                                                                                                                                                   _s825_) >>= fun w__185 : option ((mword 5 * mword 6)) =>
                                                                                                                                                (match w__185 with
                                                                                                                                                 | Some
                                                                                                                                                   ((rs2, uimm)) =>
                                                                                                                                                    returnm ((C_SDSP
                                                                                                                                                                ((uimm, rs2)))
                                                                                                                                                     : ast )
                                                                                                                                                 | _ =>
                                                                                                                                                    exit tt
                                                                                                                                                     : M (ast)
                                                                                                                                                 end)
                                                                                                                                                 : M (ast)
                                                                                                                                              else
                                                                                                                                                (_s1487_
                                                                                                                                                   _s825_) >>= fun w__188 : option (mword 5) =>
                                                                                                                                                (if
                                                                                                                                                   ((match w__188 with
                                                                                                                                                     | Some
                                                                                                                                                       (rs1) =>
                                                                                                                                                        projT1
                                                                                                                                                        (neq_int
                                                                                                                                                           (projT1
                                                                                                                                                            (regidx_to_regno
                                                                                                                                                               rs1))
                                                                                                                                                           (projT1
                                                                                                                                                            (regidx_to_regno
                                                                                                                                                               zreg)))
                                                                                                                                                     | _ =>
                                                                                                                                                        false
                                                                                                                                                     end))
                                                                                                                                                 then
                                                                                                                                                   (_s1487_
                                                                                                                                                      _s825_) >>= fun w__189 : option (mword 5) =>
                                                                                                                                                   (match w__189 with
                                                                                                                                                    | Some
                                                                                                                                                      (rs1) =>
                                                                                                                                                       returnm ((C_JR
                                                                                                                                                                   (rs1))
                                                                                                                                                        : ast )
                                                                                                                                                    | _ =>
                                                                                                                                                       exit tt
                                                                                                                                                        : M (ast)
                                                                                                                                                    end)
                                                                                                                                                    : M (ast)
                                                                                                                                                 else
                                                                                                                                                   (_s1495_
                                                                                                                                                      _s825_) >>= fun w__192 : option (mword 5) =>
                                                                                                                                                   (if
                                                                                                                                                      ((match w__192 with
                                                                                                                                                        | Some
                                                                                                                                                          (rs1) =>
                                                                                                                                                           projT1
                                                                                                                                                           (neq_int
                                                                                                                                                              (projT1
                                                                                                                                                               (regidx_to_regno
                                                                                                                                                                  rs1))
                                                                                                                                                              (projT1
                                                                                                                                                               (regidx_to_regno
                                                                                                                                                                  zreg)))
                                                                                                                                                        | _ =>
                                                                                                                                                           false
                                                                                                                                                        end))
                                                                                                                                                    then
                                                                                                                                                      (_s1495_
                                                                                                                                                         _s825_) >>= fun w__193 : option (mword 5) =>
                                                                                                                                                      (match w__193 with
                                                                                                                                                       | Some
                                                                                                                                                         (rs1) =>
                                                                                                                                                          returnm ((C_JALR
                                                                                                                                                                      (rs1))
                                                                                                                                                           : ast )
                                                                                                                                                       | _ =>
                                                                                                                                                          exit tt
                                                                                                                                                           : M (ast)
                                                                                                                                                       end)
                                                                                                                                                       : M (ast)
                                                                                                                                                    else
                                                                                                                                                      (_s1503_
                                                                                                                                                         _s825_) >>= fun w__196 : option ((mword 5 * mword 5)) =>
                                                                                                                                                      (if
                                                                                                                                                         ((match w__196 with
                                                                                                                                                           | Some
                                                                                                                                                             ((rd, rs2)) =>
                                                                                                                                                              andb
                                                                                                                                                                (projT1
                                                                                                                                                                 (neq_int
                                                                                                                                                                    (projT1
                                                                                                                                                                     (regidx_to_regno
                                                                                                                                                                        rd))
                                                                                                                                                                    (projT1
                                                                                                                                                                     (regidx_to_regno
                                                                                                                                                                        zreg))))
                                                                                                                                                                ((projT1
                                                                                                                                                                  (neq_int
                                                                                                                                                                     (projT1
                                                                                                                                                                      (regidx_to_regno
                                                                                                                                                                         rs2))
                                                                                                                                                                     (projT1
                                                                                                                                                                      (regidx_to_regno
                                                                                                                                                                         zreg))))
                                                                                                                                                                 : bool)
                                                                                                                                                           | _ =>
                                                                                                                                                              false
                                                                                                                                                           end))
                                                                                                                                                       then
                                                                                                                                                         (_s1503_
                                                                                                                                                            _s825_) >>= fun w__197 : option ((mword 5 * mword 5)) =>
                                                                                                                                                         (match w__197 with
                                                                                                                                                          | Some
                                                                                                                                                            ((rd, rs2)) =>
                                                                                                                                                             returnm ((C_MV
                                                                                                                                                                         ((rd, rs2)))
                                                                                                                                                              : ast )
                                                                                                                                                          | _ =>
                                                                                                                                                             exit tt
                                                                                                                                                              : M (ast)
                                                                                                                                                          end)
                                                                                                                                                          : M (ast)
                                                                                                                                                       else if
                                                                                                                                                         ((generic_eq
                                                                                                                                                             _s825_
                                                                                                                                                             "c.ebreak"))
                                                                                                                                                       then
                                                                                                                                                         returnm ((C_EBREAK
                                                                                                                                                                     (tt))
                                                                                                                                                          : ast )
                                                                                                                                                       else
                                                                                                                                                         (_s1515_
                                                                                                                                                            _s825_) >>= fun w__200 : option ((mword 5 * mword 5)) =>
                                                                                                                                                         (if
                                                                                                                                                            ((match w__200 with
                                                                                                                                                              | Some
                                                                                                                                                                ((rsd, rs2)) =>
                                                                                                                                                                 andb
                                                                                                                                                                   (projT1
                                                                                                                                                                    (neq_int
                                                                                                                                                                       (projT1
                                                                                                                                                                        (regidx_to_regno
                                                                                                                                                                           rsd))
                                                                                                                                                                       (projT1
                                                                                                                                                                        (regidx_to_regno
                                                                                                                                                                           zreg))))
                                                                                                                                                                   ((projT1
                                                                                                                                                                     (neq_int
                                                                                                                                                                        (projT1
                                                                                                                                                                         (regidx_to_regno
                                                                                                                                                                            rs2))
                                                                                                                                                                        (projT1
                                                                                                                                                                         (regidx_to_regno
                                                                                                                                                                            zreg))))
                                                                                                                                                                    : bool)
                                                                                                                                                              | _ =>
                                                                                                                                                                 false
                                                                                                                                                              end))
                                                                                                                                                          then
                                                                                                                                                            (_s1515_
                                                                                                                                                               _s825_) >>= fun w__201 : option ((mword 5 * mword 5)) =>
                                                                                                                                                            (match w__201 with
                                                                                                                                                             | Some
                                                                                                                                                               ((rsd, rs2)) =>
                                                                                                                                                                returnm ((C_ADD
                                                                                                                                                                            ((rsd, rs2)))
                                                                                                                                                                 : ast )
                                                                                                                                                             | _ =>
                                                                                                                                                                exit tt
                                                                                                                                                                 : M (ast)
                                                                                                                                                             end)
                                                                                                                                                             : M (ast)
                                                                                                                                                          else
                                                                                                                                                            (_s1527_
                                                                                                                                                               _s825_) >>= fun w__204 : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                            (if
                                                                                                                                                               ((match w__204 with
                                                                                                                                                                 | Some
                                                                                                                                                                   ((high, signed1, signed2, rd, rs1, rs2)) =>
                                                                                                                                                                    true
                                                                                                                                                                 | _ =>
                                                                                                                                                                    false
                                                                                                                                                                 end))
                                                                                                                                                             then
                                                                                                                                                               (_s1527_
                                                                                                                                                                  _s825_) >>= fun w__205 : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                               (match w__205 with
                                                                                                                                                                | Some
                                                                                                                                                                  ((high, signed1, signed2, rd, rs1, rs2)) =>
                                                                                                                                                                   returnm ((MUL
                                                                                                                                                                               ((rs2, rs1, rd, high, signed1, signed2)))
                                                                                                                                                                    : ast )
                                                                                                                                                                | _ =>
                                                                                                                                                                   exit tt
                                                                                                                                                                    : M (ast)
                                                                                                                                                                end)
                                                                                                                                                                : M (ast)
                                                                                                                                                             else
                                                                                                                                                               (_s1544_
                                                                                                                                                                  _s825_) >>= fun w__208 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                               (if
                                                                                                                                                                  ((match w__208 with
                                                                                                                                                                    | Some
                                                                                                                                                                      ((s, rd, rs1, rs2)) =>
                                                                                                                                                                       true
                                                                                                                                                                    | _ =>
                                                                                                                                                                       false
                                                                                                                                                                    end))
                                                                                                                                                                then
                                                                                                                                                                  (_s1544_
                                                                                                                                                                     _s825_) >>= fun w__209 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                  (match w__209 with
                                                                                                                                                                   | Some
                                                                                                                                                                     ((s, rd, rs1, rs2)) =>
                                                                                                                                                                      returnm ((DIV
                                                                                                                                                                                  ((rs2, rs1, rd, s)))
                                                                                                                                                                       : ast )
                                                                                                                                                                   | _ =>
                                                                                                                                                                      exit tt
                                                                                                                                                                       : M (ast)
                                                                                                                                                                   end)
                                                                                                                                                                   : M (ast)
                                                                                                                                                                else
                                                                                                                                                                  (_s1562_
                                                                                                                                                                     _s825_) >>= fun w__212 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                  (if
                                                                                                                                                                     ((match w__212 with
                                                                                                                                                                       | Some
                                                                                                                                                                         ((s, rd, rs1, rs2)) =>
                                                                                                                                                                          true
                                                                                                                                                                       | _ =>
                                                                                                                                                                          false
                                                                                                                                                                       end))
                                                                                                                                                                   then
                                                                                                                                                                     (_s1562_
                                                                                                                                                                        _s825_) >>= fun w__213 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                     (match w__213 with
                                                                                                                                                                      | Some
                                                                                                                                                                        ((s, rd, rs1, rs2)) =>
                                                                                                                                                                         returnm ((REM
                                                                                                                                                                                     ((rs2, rs1, rd, s)))
                                                                                                                                                                          : ast )
                                                                                                                                                                      | _ =>
                                                                                                                                                                         exit tt
                                                                                                                                                                          : M (ast)
                                                                                                                                                                      end)
                                                                                                                                                                      : M (ast)
                                                                                                                                                                   else
                                                                                                                                                                     (_s1580_
                                                                                                                                                                        _s825_) >>= fun w__216 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                     (if
                                                                                                                                                                        ((match w__216 with
                                                                                                                                                                          | Some
                                                                                                                                                                            ((rd, rs1, rs2)) =>
                                                                                                                                                                             Z.eqb
                                                                                                                                                                               64
                                                                                                                                                                               64
                                                                                                                                                                          | _ =>
                                                                                                                                                                             false
                                                                                                                                                                          end))
                                                                                                                                                                      then
                                                                                                                                                                        (_s1580_
                                                                                                                                                                           _s825_) >>= fun w__217 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                        (match w__217 with
                                                                                                                                                                         | Some
                                                                                                                                                                           ((rd, rs1, rs2)) =>
                                                                                                                                                                            returnm ((MULW
                                                                                                                                                                                        ((rs2, rs1, rd)))
                                                                                                                                                                             : ast )
                                                                                                                                                                         | _ =>
                                                                                                                                                                            exit tt
                                                                                                                                                                             : M (ast)
                                                                                                                                                                         end)
                                                                                                                                                                         : M (ast)
                                                                                                                                                                      else
                                                                                                                                                                        (_s1596_
                                                                                                                                                                           _s825_) >>= fun w__220 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                        (if
                                                                                                                                                                           ((match w__220 with
                                                                                                                                                                             | Some
                                                                                                                                                                               ((s, rd, rs1, rs2)) =>
                                                                                                                                                                                Z.eqb
                                                                                                                                                                                  64
                                                                                                                                                                                  64
                                                                                                                                                                             | _ =>
                                                                                                                                                                                false
                                                                                                                                                                             end))
                                                                                                                                                                         then
                                                                                                                                                                           (_s1596_
                                                                                                                                                                              _s825_) >>= fun w__221 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                           (match w__221 with
                                                                                                                                                                            | Some
                                                                                                                                                                              ((s, rd, rs1, rs2)) =>
                                                                                                                                                                               returnm ((DIVW
                                                                                                                                                                                           ((rs2, rs1, rd, s)))
                                                                                                                                                                                : ast )
                                                                                                                                                                            | _ =>
                                                                                                                                                                               exit tt
                                                                                                                                                                                : M (ast)
                                                                                                                                                                            end)
                                                                                                                                                                            : M (ast)
                                                                                                                                                                         else
                                                                                                                                                                           (_s1615_
                                                                                                                                                                              _s825_) >>= fun w__224 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                           (if
                                                                                                                                                                              ((match w__224 with
                                                                                                                                                                                | Some
                                                                                                                                                                                  ((s, rd, rs1, rs2)) =>
                                                                                                                                                                                   Z.eqb
                                                                                                                                                                                     64
                                                                                                                                                                                     64
                                                                                                                                                                                | _ =>
                                                                                                                                                                                   false
                                                                                                                                                                                end))
                                                                                                                                                                            then
                                                                                                                                                                              (_s1615_
                                                                                                                                                                                 _s825_) >>= fun w__225 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                              (match w__225 with
                                                                                                                                                                               | Some
                                                                                                                                                                                 ((s, rd, rs1, rs2)) =>
                                                                                                                                                                                  returnm ((REMW
                                                                                                                                                                                              ((rs2, rs1, rd, s)))
                                                                                                                                                                                   : ast )
                                                                                                                                                                               | _ =>
                                                                                                                                                                                  exit tt
                                                                                                                                                                                   : M (ast)
                                                                                                                                                                               end)
                                                                                                                                                                               : M (ast)
                                                                                                                                                                            else
                                                                                                                                                                              (_s1634_
                                                                                                                                                                                 _s825_) >>= fun w__228 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                              (if
                                                                                                                                                                                 ((match w__228 with
                                                                                                                                                                                   | Some
                                                                                                                                                                                     ((op, rd, rs1, csr)) =>
                                                                                                                                                                                      true
                                                                                                                                                                                   | _ =>
                                                                                                                                                                                      false
                                                                                                                                                                                   end))
                                                                                                                                                                               then
                                                                                                                                                                                 (_s1634_
                                                                                                                                                                                    _s825_) >>= fun w__229 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                                 (match w__229 with
                                                                                                                                                                                  | Some
                                                                                                                                                                                    ((op, rd, rs1, csr)) =>
                                                                                                                                                                                     returnm ((CSR
                                                                                                                                                                                                 ((csr, rs1, rd, true, op)))
                                                                                                                                                                                      : ast )
                                                                                                                                                                                  | _ =>
                                                                                                                                                                                     exit tt
                                                                                                                                                                                      : M (ast)
                                                                                                                                                                                  end)
                                                                                                                                                                                  : M (ast)
                                                                                                                                                                               else
                                                                                                                                                                                 (_s1652_
                                                                                                                                                                                    _s825_) >>= fun w__232 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                                 (if
                                                                                                                                                                                    ((match w__232 with
                                                                                                                                                                                      | Some
                                                                                                                                                                                        ((op, rd, rs1, csr)) =>
                                                                                                                                                                                         true
                                                                                                                                                                                      | _ =>
                                                                                                                                                                                         false
                                                                                                                                                                                      end))
                                                                                                                                                                                  then
                                                                                                                                                                                    (_s1652_
                                                                                                                                                                                       _s825_) >>= fun w__233 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                                    (match w__233 with
                                                                                                                                                                                     | Some
                                                                                                                                                                                       ((op, rd, rs1, csr)) =>
                                                                                                                                                                                        returnm ((CSR
                                                                                                                                                                                                    ((csr, rs1, rd, false, op)))
                                                                                                                                                                                         : ast )
                                                                                                                                                                                     | _ =>
                                                                                                                                                                                        exit tt
                                                                                                                                                                                         : M (ast)
                                                                                                                                                                                     end)
                                                                                                                                                                                     : M (ast)
                                                                                                                                                                                  else if
                                                                                                                                                                                    ((generic_eq
                                                                                                                                                                                        _s825_
                                                                                                                                                                                        "uret"))
                                                                                                                                                                                  then
                                                                                                                                                                                    returnm ((URET
                                                                                                                                                                                                (tt))
                                                                                                                                                                                     : ast )
                                                                                                                                                                                  else
                                                                                                                                                                                    (_s1669_
                                                                                                                                                                                       _s825_) >>= fun w__236 : option (mword 32) =>
                                                                                                                                                                                    (if
                                                                                                                                                                                       ((match w__236 with
                                                                                                                                                                                         | Some
                                                                                                                                                                                           (s) =>
                                                                                                                                                                                            true
                                                                                                                                                                                         | _ =>
                                                                                                                                                                                            false
                                                                                                                                                                                         end))
                                                                                                                                                                                     then
                                                                                                                                                                                       (_s1669_
                                                                                                                                                                                          _s825_) >>= fun w__237 : option (mword 32) =>
                                                                                                                                                                                       (match w__237 with
                                                                                                                                                                                        | Some
                                                                                                                                                                                          (s) =>
                                                                                                                                                                                           returnm ((ILLEGAL
                                                                                                                                                                                                       (s))
                                                                                                                                                                                            : ast )
                                                                                                                                                                                        | _ =>
                                                                                                                                                                                           exit tt
                                                                                                                                                                                            : M (ast)
                                                                                                                                                                                        end)
                                                                                                                                                                                        : M (ast)
                                                                                                                                                                                     else
                                                                                                                                                                                       (_s1677_
                                                                                                                                                                                          _s825_) >>= fun w__240 : option (mword 16) =>
                                                                                                                                                                                       (if
                                                                                                                                                                                          ((match w__240 with
                                                                                                                                                                                            | Some
                                                                                                                                                                                              (s) =>
                                                                                                                                                                                               true
                                                                                                                                                                                            | _ =>
                                                                                                                                                                                               false
                                                                                                                                                                                            end))
                                                                                                                                                                                        then
                                                                                                                                                                                          (_s1677_
                                                                                                                                                                                             _s825_) >>= fun w__241 : option (mword 16) =>
                                                                                                                                                                                          (match w__241 with
                                                                                                                                                                                           | Some
                                                                                                                                                                                             (s) =>
                                                                                                                                                                                              returnm ((C_ILLEGAL
                                                                                                                                                                                                          (s))
                                                                                                                                                                                               : ast )
                                                                                                                                                                                           | _ =>
                                                                                                                                                                                              exit tt
                                                                                                                                                                                               : M (ast)
                                                                                                                                                                                           end)
                                                                                                                                                                                           : M (ast)
                                                                                                                                                                                        else
                                                                                                                                                                                          assert_exp' false "Pattern match failure at unknown location" >>= fun _ =>
                                                                                                                                                                                          exit tt)
                                                                                                                                                                                        : M (ast))
                                                                                                                                                                                     : M (ast))
                                                                                                                                                                                  : M (ast))
                                                                                                                                                                               : M (ast))
                                                                                                                                                                            : M (ast))
                                                                                                                                                                         : M (ast))
                                                                                                                                                                      : M (ast))
                                                                                                                                                                   : M (ast))
                                                                                                                                                                : M (ast))
                                                                                                                                                             : M (ast))
                                                                                                                                                          : M (ast))
                                                                                                                                                       : M (ast))
                                                                                                                                                    : M (ast))
                                                                                                                                                 : M (ast))
                                                                                                                                              : M (ast))
                                                                                                                                           : M (ast))
                                                                                                                                        : M (ast))
                                                                                                                                     : M (ast))
                                                                                                                                  : M (ast))
                                                                                                                               : M (ast))
                                                                                                                            : M (ast))
                                                                                                                         : M (ast))
                                                                                                                      : M (ast))
                                                                                                                   : M (ast))
                                                                                                                : M (ast))
                                                                                                             : M (ast))
                                                                                                          : M (ast))
                                                                                                       : M (ast))
                                                                                                    : M (ast))
                                                                                                 : M (ast))
                                                                                              : M (ast))
                                                                                           : M (ast))
                                                                                        : M (ast))
                                                                                     : M (ast))
                                                                                  : M (ast))
                                                                               : M (ast))
                                                                            : M (ast))
                                                                         : M (ast))
                                                                      : M (ast))
                                                                   : M (ast))
                                                                : M (ast))
                                                             : M (ast))
                                                          : M (ast))
                                                       : M (ast))
                                                    : M (ast))
                                                 : M (ast))
                                              : M (ast))
                                           : M (ast))
                                        : M (ast))
                                     : M (ast))
                                  : M (ast))
                               : M (ast))
                            : M (ast))
                         : M (ast))
                      : M (ast))
                   : M (ast))
                : M (ast))
             : M (ast))
          : M (ast))
       : M (ast))
    : M (ast).

Definition assembly_forwards_matches (arg_ : ast) 
: bool :=
   
   match arg_ with
   | UTYPE ((imm, rd, op)) => true
   | RISCV_JAL ((imm, rd)) => true
   | RISCV_JALR ((imm, rs1, rd)) => true
   | BTYPE ((imm, rs2, rs1, op)) => true
   | ITYPE ((imm, rs1, rd, op)) => true
   | SHIFTIOP ((shamt, rs1, rd, op)) => true
   | RTYPE ((rs2, rs1, rd, op)) => true
   | LOAD ((imm, rs1, rd, is_unsigned, size, aq, rl)) => true
   | STORE ((imm, rs2, rs1, size, aq, rl)) => true
   | ADDIW ((imm, rs1, rd)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTW ((shamt, rs1, rd, op)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | RTYPEW ((rs2, rs1, rd, op)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | SHIFTIWOP ((shamt, rs1, rd, op)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | FENCE ((pred, succ)) => true
   | FENCE_TSO ((pred, succ)) => true
   | FENCEI (tt) => true
   | ECALL (tt) => true
   | MRET (tt) => true
   | SRET (tt) => true
   | EBREAK (tt) => true
   | WFI (tt) => true
   | SFENCE_VMA ((rs1, rs2)) => true
   | LOADRES ((aq, rl, rs1, size, rd)) => true
   | STORECON ((aq, rl, rs2, rs1, size, rd)) => true
   | AMO ((op, aq, rl, rs2, rs1, width, rd)) => true
   | C_NOP (tt) => true
   | C_ADDI4SPN ((rdc, nzimm)) =>
      if ((neq_vec nzimm (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  : mword 8))) then true else false
   | C_LW ((uimm, rsc, rdc)) => true
   | C_LD ((uimm, rsc, rdc)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_SW ((uimm, rsc1, rsc2)) => true
   | C_SD ((uimm, rsc1, rsc2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_ADDI ((nzi, rsd)) =>
      if ((andb (neq_vec nzi (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))
             ((projT1
               (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
              : bool))) then
        true
      else false
   | C_JAL (imm) => if sumbool_of_bool ((Z.eqb 64 32)) then true else false
   | C_ADDIW ((imm, rsd)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_LI ((imm, rd)) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_ADDI16SP (imm) =>
      if ((neq_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))) then true else false
   | C_LUI ((imm, rd)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg))))
                             ((andb
                                 (projT1
                                  (neq_int (projT1 (regidx_to_regno rd))
                                     (projT1
                                      (regidx_to_regno sp))))
                                 (neq_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6)))
                              : bool))) then
        true
      else false
   | C_SRLI ((shamt, rsd)) =>
      if ((neq_vec shamt (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))) then true else false
   | C_SRAI ((shamt, rsd)) =>
      if ((neq_vec shamt (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))) then true else false
   | C_ANDI ((imm, rsd)) => true
   | C_SUB ((rsd, rs2)) => true
   | C_XOR ((rsd, rs2)) => true
   | C_OR ((rsd, rs2)) => true
   | C_AND ((rsd, rs2)) => true
   | C_SUBW ((rsd, rs2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_ADDW ((rsd, rs2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_J (imm) => true
   | C_BEQZ ((imm, rs)) => true
   | C_BNEZ ((imm, rs)) => true
   | C_SLLI ((shamt, rsd)) =>
      if ((andb (neq_vec shamt (vec_of_bits [B0;B0;B0;B0;B0;B0]  : mword 6))
             ((projT1
               (neq_int (projT1 (regidx_to_regno rsd)) (projT1 (regidx_to_regno zreg))))
              : bool))) then
        true
      else false
   | C_LWSP ((uimm, rd)) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_LDSP ((uimm, rd)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg))))
                             (Z.eqb 64 64))) then
        true
      else false
   | C_SWSP ((uimm, rd)) => true
   | C_SDSP ((uimm, rs2)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | C_JR (rs1) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_JALR (rs1) =>
      if sumbool_of_bool ((projT1
                           (neq_int (projT1 (regidx_to_regno rs1)) (projT1 (regidx_to_regno zreg)))))
      then
        true
      else false
   | C_MV ((rd, rs2)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rd)) (projT1 (regidx_to_regno zreg))))
                             ((projT1
                               (neq_int (projT1 (regidx_to_regno rs2))
                                  (projT1
                                   (regidx_to_regno zreg))))
                              : bool))) then
        true
      else false
   | C_EBREAK (tt) => true
   | C_ADD ((rsd, rs2)) =>
      if sumbool_of_bool ((andb
                             (projT1
                              (neq_int (projT1 (regidx_to_regno rsd))
                                 (projT1
                                  (regidx_to_regno zreg))))
                             ((projT1
                               (neq_int (projT1 (regidx_to_regno rs2))
                                  (projT1
                                   (regidx_to_regno zreg))))
                              : bool))) then
        true
      else false
   | MUL ((rs2, rs1, rd, high, signed1, signed2)) => true
   | DIV ((rs2, rs1, rd, s)) => true
   | REM ((rs2, rs1, rd, s)) => true
   | MULW ((rs2, rs1, rd)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | DIVW ((rs2, rs1, rd, s)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | REMW ((rs2, rs1, rd, s)) => if sumbool_of_bool ((Z.eqb 64 64)) then true else false
   | CSR ((csr, rs1, rd, true, op)) => true
   | CSR ((csr, rs1, rd, false, op)) => true
   | URET (tt) => true
   | ILLEGAL (s) => true
   | C_ILLEGAL (s) => true
   end.

Definition _s2549_ (_s2550_ : string) 
: M (option (mword 16)) :=
   
   let _s2551_ := _s2550_ in
   (if ((string_startswith _s2551_ "c.illegal")) then
      (match (string_drop _s2551_ (projT1 (string_length "c.illegal"))) with
       | _s2552_ =>
          (spc_matches_prefix _s2552_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s2553_ _)) =>
                       match (string_drop _s2552_ _s2553_) with
                       | _s2554_ =>
                          match (hex_bits_16_matches_prefix _s2554_) with
                          | Some ((s, existT _ _s2555_ _)) =>
                             let p0_ := string_drop _s2554_ _s2555_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 16))
       end)
       : M (option (mword 16))
    else returnm (None  : option (mword 16)))
    : M (option (mword 16)).

Definition _s2541_ (_s2542_ : string) 
: M (option (mword 32)) :=
   
   let _s2543_ := _s2542_ in
   (if ((string_startswith _s2543_ "illegal")) then
      (match (string_drop _s2543_ (projT1 (string_length "illegal"))) with
       | _s2544_ =>
          (spc_matches_prefix _s2544_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s2545_ _)) =>
                       match (string_drop _s2544_ _s2545_) with
                       | _s2546_ =>
                          match (hex_bits_32_matches_prefix _s2546_) with
                          | Some ((s, existT _ _s2547_ _)) =>
                             let p0_ := string_drop _s2546_ _s2547_ in
                             if ((generic_eq p0_ "")) then Some (s)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 32))
       end)
       : M (option (mword 32))
    else returnm (None  : option (mword 32)))
    : M (option (mword 32)).

Definition _s2524_ (_s2525_ : string) 
: M (option ((csrop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s2525_ with
    | _s2526_ =>
       (csr_mnemonic_matches_prefix _s2526_) >>= fun w__0 : option ((csrop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2527_ _)) =>
           (match (string_drop _s2526_ _s2527_) with
            | _s2528_ =>
               (spc_matches_prefix _s2528_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2529_ _)) =>
                   (match (string_drop _s2528_ _s2529_) with
                    | _s2530_ =>
                       (reg_name_matches_prefix _s2530_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2531_ _)) =>
                           (match (string_drop _s2530_ _s2531_) with
                            | _s2532_ =>
                               (sep_matches_prefix _s2532_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2533_ _)) =>
                                   (match (string_drop _s2532_ _s2533_) with
                                    | _s2534_ =>
                                       (reg_name_matches_prefix _s2534_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2535_ _)) =>
                                           (match (string_drop _s2534_ _s2535_) with
                                            | _s2536_ =>
                                               (sep_matches_prefix _s2536_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s2537_ _)) =>
                                                   (match (string_drop _s2536_ _s2537_) with
                                                    | _s2538_ =>
                                                       (csr_name_map_matches_prefix _s2538_) >>= fun w__6 : option ((mword 12 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((csr, existT _ _s2539_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s2538_ _s2539_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, csr))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                    end)
                                                    : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                end)
                                                : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                            end)
                                            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                        | _ =>
                                           returnm (None
                                            : option ((csrop * mword 5 * mword 5 * mword 12)))
                                        end)
                                        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                    end)
                                    : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                | _ =>
                                   returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                                end)
                                : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                            end)
                            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                        end)
                        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                    end)
                    : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                end)
                : M (option ((csrop * mword 5 * mword 5 * mword 12)))
            end)
            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((csrop * mword 5 * mword 5 * mword 12))).

Definition _s2506_ (_s2507_ : string) 
: M (option ((csrop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s2507_ with
    | _s2508_ =>
       (csr_mnemonic_matches_prefix _s2508_) >>= fun w__0 : option ((csrop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2509_ _)) =>
           let _s2510_ := string_drop _s2508_ _s2509_ in
           (if ((string_startswith _s2510_ "i")) then
              (match (string_drop _s2510_ (projT1 (string_length "i"))) with
               | _s2511_ =>
                  (spc_matches_prefix _s2511_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s2512_ _)) =>
                      (match (string_drop _s2511_ _s2512_) with
                       | _s2513_ =>
                          (reg_name_matches_prefix _s2513_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s2514_ _)) =>
                              (match (string_drop _s2513_ _s2514_) with
                               | _s2515_ =>
                                  (sep_matches_prefix _s2515_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s2516_ _)) =>
                                      (match (string_drop _s2515_ _s2516_) with
                                       | _s2517_ =>
                                          (match (hex_bits_5_matches_prefix _s2517_) with
                                           | Some ((rs1, existT _ _s2518_ _)) =>
                                              (match (string_drop _s2517_ _s2518_) with
                                               | _s2519_ =>
                                                  (sep_matches_prefix _s2519_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__4 with
                                                   | Some ((tt, existT _ _s2520_ _)) =>
                                                      (match (string_drop _s2519_ _s2520_) with
                                                       | _s2521_ =>
                                                          (csr_name_map_matches_prefix _s2521_) >>= fun w__5 : option ((mword 12 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__5 with
                                                                    | Some
                                                                      ((csr, existT _ _s2522_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s2521_ _s2522_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((op, rd, rs1, csr))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                       end)
                                                       : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((csrop * mword 5 * mword 5 * mword 12)))
                                                   end)
                                                   : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                               end)
                                               : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                           | _ =>
                                              returnm (None
                                               : option ((csrop * mword 5 * mword 5 * mword 12)))
                                           end)
                                           : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                                   | _ =>
                                      returnm (None
                                       : option ((csrop * mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((csrop * mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((csrop * mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((csrop * mword 5 * mword 5 * mword 12)))
            else returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12))))
            : M (option ((csrop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((csrop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((csrop * mword 5 * mword 5 * mword 12))).

Definition _s2487_ (_s2488_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s2489_ := _s2488_ in
   (if ((string_startswith _s2489_ "rem")) then
      (match (string_drop _s2489_ (projT1 (string_length "rem"))) with
       | _s2490_ =>
          (maybe_not_u_matches_prefix _s2490_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s2491_ _)) =>
              let _s2492_ := string_drop _s2490_ _s2491_ in
              (if ((string_startswith _s2492_ "w")) then
                 (match (string_drop _s2492_ (projT1 (string_length "w"))) with
                  | _s2493_ =>
                     (spc_matches_prefix _s2493_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some ((tt, existT _ _s2494_ _)) =>
                         (match (string_drop _s2493_ _s2494_) with
                          | _s2495_ =>
                             (reg_name_matches_prefix _s2495_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some ((rd, existT _ _s2496_ _)) =>
                                 (match (string_drop _s2495_ _s2496_) with
                                  | _s2497_ =>
                                     (sep_matches_prefix _s2497_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some ((tt, existT _ _s2498_ _)) =>
                                         (match (string_drop _s2497_ _s2498_) with
                                          | _s2499_ =>
                                             (reg_name_matches_prefix _s2499_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some ((rs1, existT _ _s2500_ _)) =>
                                                 (match (string_drop _s2499_ _s2500_) with
                                                  | _s2501_ =>
                                                     (sep_matches_prefix _s2501_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     (match w__5 with
                                                      | Some ((tt, existT _ _s2502_ _)) =>
                                                         (match (string_drop _s2501_ _s2502_) with
                                                          | _s2503_ =>
                                                             (reg_name_matches_prefix _s2503_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                               0)})) =>
                                                             returnm ((match w__6 with
                                                                       | Some
                                                                         ((rs2, existT _ _s2504_ _)) =>
                                                                          let p0_ :=
                                                                            string_drop _s2503_
                                                                              _s2504_ in
                                                                          if ((generic_eq p0_ ""))
                                                                          then
                                                                            Some
                                                                              ((s, rd, rs1, rs2))
                                                                          else None
                                                                       | _ => None
                                                                       end)
                                                              : option ((bool * mword 5 * mword 5 * mword 5)))
                                                          end)
                                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                      | _ =>
                                                         returnm (None
                                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                                      end)
                                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                  end)
                                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((bool * mword 5 * mword 5 * mword 5)))
                                              end)
                                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                          end)
                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None
                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                      end)
                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                  end)
                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                              | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                              end)
                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                          end)
                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                      | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                      end)
                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                  end)
                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
               else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s2468_ (_s2469_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s2470_ := _s2469_ in
   (if ((string_startswith _s2470_ "div")) then
      (match (string_drop _s2470_ (projT1 (string_length "div"))) with
       | _s2471_ =>
          (maybe_not_u_matches_prefix _s2471_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s2472_ _)) =>
              let _s2473_ := string_drop _s2471_ _s2472_ in
              (if ((string_startswith _s2473_ "w")) then
                 (match (string_drop _s2473_ (projT1 (string_length "w"))) with
                  | _s2474_ =>
                     (spc_matches_prefix _s2474_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some ((tt, existT _ _s2475_ _)) =>
                         (match (string_drop _s2474_ _s2475_) with
                          | _s2476_ =>
                             (reg_name_matches_prefix _s2476_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some ((rd, existT _ _s2477_ _)) =>
                                 (match (string_drop _s2476_ _s2477_) with
                                  | _s2478_ =>
                                     (sep_matches_prefix _s2478_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some ((tt, existT _ _s2479_ _)) =>
                                         (match (string_drop _s2478_ _s2479_) with
                                          | _s2480_ =>
                                             (reg_name_matches_prefix _s2480_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some ((rs1, existT _ _s2481_ _)) =>
                                                 (match (string_drop _s2480_ _s2481_) with
                                                  | _s2482_ =>
                                                     (sep_matches_prefix _s2482_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     (match w__5 with
                                                      | Some ((tt, existT _ _s2483_ _)) =>
                                                         (match (string_drop _s2482_ _s2483_) with
                                                          | _s2484_ =>
                                                             (reg_name_matches_prefix _s2484_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                               0)})) =>
                                                             returnm ((match w__6 with
                                                                       | Some
                                                                         ((rs2, existT _ _s2485_ _)) =>
                                                                          let p0_ :=
                                                                            string_drop _s2484_
                                                                              _s2485_ in
                                                                          if ((generic_eq p0_ ""))
                                                                          then
                                                                            Some
                                                                              ((s, rd, rs1, rs2))
                                                                          else None
                                                                       | _ => None
                                                                       end)
                                                              : option ((bool * mword 5 * mword 5 * mword 5)))
                                                          end)
                                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                      | _ =>
                                                         returnm (None
                                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                                      end)
                                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                  end)
                                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((bool * mword 5 * mword 5 * mword 5)))
                                              end)
                                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                          end)
                                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                      | _ =>
                                         returnm (None
                                          : option ((bool * mword 5 * mword 5 * mword 5)))
                                      end)
                                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                  end)
                                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
                              | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                              end)
                              : M (option ((bool * mword 5 * mword 5 * mword 5)))
                          end)
                          : M (option ((bool * mword 5 * mword 5 * mword 5)))
                      | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                      end)
                      : M (option ((bool * mword 5 * mword 5 * mword 5)))
                  end)
                  : M (option ((bool * mword 5 * mword 5 * mword 5)))
               else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s2452_ (_s2453_ : string) 
: M (option ((mword 5 * mword 5 * mword 5))) :=
   
   let _s2454_ := _s2453_ in
   (if ((string_startswith _s2454_ "mulw")) then
      (match (string_drop _s2454_ (projT1 (string_length "mulw"))) with
       | _s2455_ =>
          (spc_matches_prefix _s2455_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2456_ _)) =>
              (match (string_drop _s2455_ _s2456_) with
               | _s2457_ =>
                  (reg_name_matches_prefix _s2457_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2458_ _)) =>
                      (match (string_drop _s2457_ _s2458_) with
                       | _s2459_ =>
                          (sep_matches_prefix _s2459_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2460_ _)) =>
                              (match (string_drop _s2459_ _s2460_) with
                               | _s2461_ =>
                                  (reg_name_matches_prefix _s2461_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s2462_ _)) =>
                                      (match (string_drop _s2461_ _s2462_) with
                                       | _s2463_ =>
                                          (sep_matches_prefix _s2463_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s2464_ _)) =>
                                              (match (string_drop _s2463_ _s2464_) with
                                               | _s2465_ =>
                                                  (reg_name_matches_prefix _s2465_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some ((rs2, existT _ _s2466_ _)) =>
                                                               let p0_ :=
                                                                 string_drop _s2465_ _s2466_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rd, rs1, rs2))
                                                               else None
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5 * mword 5))).

Definition _s2434_ (_s2435_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s2436_ := _s2435_ in
   (if ((string_startswith _s2436_ "rem")) then
      (match (string_drop _s2436_ (projT1 (string_length "rem"))) with
       | _s2437_ =>
          (maybe_not_u_matches_prefix _s2437_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s2438_ _)) =>
              (match (string_drop _s2437_ _s2438_) with
               | _s2439_ =>
                  (spc_matches_prefix _s2439_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s2440_ _)) =>
                      (match (string_drop _s2439_ _s2440_) with
                       | _s2441_ =>
                          (reg_name_matches_prefix _s2441_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s2442_ _)) =>
                              (match (string_drop _s2441_ _s2442_) with
                               | _s2443_ =>
                                  (sep_matches_prefix _s2443_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s2444_ _)) =>
                                      (match (string_drop _s2443_ _s2444_) with
                                       | _s2445_ =>
                                          (reg_name_matches_prefix _s2445_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs1, existT _ _s2446_ _)) =>
                                              (match (string_drop _s2445_ _s2446_) with
                                               | _s2447_ =>
                                                  (sep_matches_prefix _s2447_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s2448_ _)) =>
                                                      (match (string_drop _s2447_ _s2448_) with
                                                       | _s2449_ =>
                                                          (reg_name_matches_prefix _s2449_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs2, existT _ _s2450_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s2449_ _s2450_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((s, rd, rs1, rs2))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s2416_ (_s2417_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s2418_ := _s2417_ in
   (if ((string_startswith _s2418_ "div")) then
      (match (string_drop _s2418_ (projT1 (string_length "div"))) with
       | _s2419_ =>
          (maybe_not_u_matches_prefix _s2419_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s2420_ _)) =>
              (match (string_drop _s2419_ _s2420_) with
               | _s2421_ =>
                  (spc_matches_prefix _s2421_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s2422_ _)) =>
                      (match (string_drop _s2421_ _s2422_) with
                       | _s2423_ =>
                          (reg_name_matches_prefix _s2423_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s2424_ _)) =>
                              (match (string_drop _s2423_ _s2424_) with
                               | _s2425_ =>
                                  (sep_matches_prefix _s2425_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s2426_ _)) =>
                                      (match (string_drop _s2425_ _s2426_) with
                                       | _s2427_ =>
                                          (reg_name_matches_prefix _s2427_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs1, existT _ _s2428_ _)) =>
                                              (match (string_drop _s2427_ _s2428_) with
                                               | _s2429_ =>
                                                  (sep_matches_prefix _s2429_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s2430_ _)) =>
                                                      (match (string_drop _s2429_ _s2430_) with
                                                       | _s2431_ =>
                                                          (reg_name_matches_prefix _s2431_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs2, existT _ _s2432_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s2431_ _s2432_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((s, rd, rs1, rs2))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((bool * mword 5 * mword 5 * mword 5)))
                           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((bool * mword 5 * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((bool * mword 5 * mword 5 * mword 5)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5))))
    : M (option ((bool * mword 5 * mword 5 * mword 5))).

Definition _s2399_ (_s2400_ : string) 
: M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5))) :=
   
   (match _s2400_ with
    | _s2401_ =>
       (mul_mnemonic_matches_prefix _s2401_) >>= fun w__0 : option (((bool * bool * bool) * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (((high, signed1, signed2), existT _ _s2402_ _)) =>
           (match (string_drop _s2401_ _s2402_) with
            | _s2403_ =>
               (spc_matches_prefix _s2403_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2404_ _)) =>
                   (match (string_drop _s2403_ _s2404_) with
                    | _s2405_ =>
                       (reg_name_matches_prefix _s2405_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2406_ _)) =>
                           (match (string_drop _s2405_ _s2406_) with
                            | _s2407_ =>
                               (sep_matches_prefix _s2407_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2408_ _)) =>
                                   (match (string_drop _s2407_ _s2408_) with
                                    | _s2409_ =>
                                       (reg_name_matches_prefix _s2409_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2410_ _)) =>
                                           (match (string_drop _s2409_ _s2410_) with
                                            | _s2411_ =>
                                               (sep_matches_prefix _s2411_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s2412_ _)) =>
                                                   (match (string_drop _s2411_ _s2412_) with
                                                    | _s2413_ =>
                                                       (reg_name_matches_prefix _s2413_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s2414_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s2413_ _s2414_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((high, signed1, signed2, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None
                                    : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                        | _ =>
                           returnm (None
                            : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5))).

Definition _s2387_ (_s2388_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s2389_ := _s2388_ in
   (if ((string_startswith _s2389_ "c.add")) then
      (match (string_drop _s2389_ (projT1 (string_length "c.add"))) with
       | _s2390_ =>
          (spc_matches_prefix _s2390_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2391_ _)) =>
              (match (string_drop _s2390_ _s2391_) with
               | _s2392_ =>
                  (reg_name_matches_prefix _s2392_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2393_ _)) =>
                      (match (string_drop _s2392_ _s2393_) with
                       | _s2394_ =>
                          (sep_matches_prefix _s2394_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2395_ _)) =>
                              (match (string_drop _s2394_ _s2395_) with
                               | _s2396_ =>
                                  (reg_name_matches_prefix _s2396_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2397_ _)) =>
                                               let p0_ := string_drop _s2396_ _s2397_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s2375_ (_s2376_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s2377_ := _s2376_ in
   (if ((string_startswith _s2377_ "c.mv")) then
      (match (string_drop _s2377_ (projT1 (string_length "c.mv"))) with
       | _s2378_ =>
          (spc_matches_prefix _s2378_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2379_ _)) =>
              (match (string_drop _s2378_ _s2379_) with
               | _s2380_ =>
                  (reg_name_matches_prefix _s2380_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2381_ _)) =>
                      (match (string_drop _s2380_ _s2381_) with
                       | _s2382_ =>
                          (sep_matches_prefix _s2382_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2383_ _)) =>
                              (match (string_drop _s2382_ _s2383_) with
                               | _s2384_ =>
                                  (reg_name_matches_prefix _s2384_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2385_ _)) =>
                                               let p0_ := string_drop _s2384_ _s2385_ in
                                               if ((generic_eq p0_ "")) then Some ((rd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s2367_ (_s2368_ : string) 
: M (option (mword 5)) :=
   
   let _s2369_ := _s2368_ in
   (if ((string_startswith _s2369_ "c.jalr")) then
      (match (string_drop _s2369_ (projT1 (string_length "c.jalr"))) with
       | _s2370_ =>
          (spc_matches_prefix _s2370_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2371_ _)) =>
              (match (string_drop _s2370_ _s2371_) with
               | _s2372_ =>
                  (reg_name_matches_prefix _s2372_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((rs1, existT _ _s2373_ _)) =>
                               let p0_ := string_drop _s2372_ _s2373_ in
                               if ((generic_eq p0_ "")) then Some (rs1)
                               else None
                            | _ => None
                            end)
                   : option (mword 5))
               end)
               : M (option (mword 5))
           | _ => returnm (None  : option (mword 5))
           end)
           : M (option (mword 5))
       end)
       : M (option (mword 5))
    else returnm (None  : option (mword 5)))
    : M (option (mword 5)).

Definition _s2359_ (_s2360_ : string) 
: M (option (mword 5)) :=
   
   let _s2361_ := _s2360_ in
   (if ((string_startswith _s2361_ "c.jr")) then
      (match (string_drop _s2361_ (projT1 (string_length "c.jr"))) with
       | _s2362_ =>
          (spc_matches_prefix _s2362_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2363_ _)) =>
              (match (string_drop _s2362_ _s2363_) with
               | _s2364_ =>
                  (reg_name_matches_prefix _s2364_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((rs1, existT _ _s2365_ _)) =>
                               let p0_ := string_drop _s2364_ _s2365_ in
                               if ((generic_eq p0_ "")) then Some (rs1)
                               else None
                            | _ => None
                            end)
                   : option (mword 5))
               end)
               : M (option (mword 5))
           | _ => returnm (None  : option (mword 5))
           end)
           : M (option (mword 5))
       end)
       : M (option (mword 5))
    else returnm (None  : option (mword 5)))
    : M (option (mword 5)).

Definition _s2347_ (_s2348_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2349_ := _s2348_ in
   (if ((string_startswith _s2349_ "c.sdsp")) then
      (match (string_drop _s2349_ (projT1 (string_length "c.sdsp"))) with
       | _s2350_ =>
          (spc_matches_prefix _s2350_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2351_ _)) =>
              (match (string_drop _s2350_ _s2351_) with
               | _s2352_ =>
                  (reg_name_matches_prefix _s2352_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs2, existT _ _s2353_ _)) =>
                      (match (string_drop _s2352_ _s2353_) with
                       | _s2354_ =>
                          (sep_matches_prefix _s2354_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2355_ _)) =>
                                       match (string_drop _s2354_ _s2355_) with
                                       | _s2356_ =>
                                          match (hex_bits_6_matches_prefix _s2356_) with
                                          | Some ((uimm, existT _ _s2357_ _)) =>
                                             let p0_ := string_drop _s2356_ _s2357_ in
                                             if ((generic_eq p0_ "")) then Some ((rs2, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2335_ (_s2336_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2337_ := _s2336_ in
   (if ((string_startswith _s2337_ "c.swsp")) then
      (match (string_drop _s2337_ (projT1 (string_length "c.swsp"))) with
       | _s2338_ =>
          (spc_matches_prefix _s2338_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2339_ _)) =>
              (match (string_drop _s2338_ _s2339_) with
               | _s2340_ =>
                  (reg_name_matches_prefix _s2340_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2341_ _)) =>
                      (match (string_drop _s2340_ _s2341_) with
                       | _s2342_ =>
                          (sep_matches_prefix _s2342_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2343_ _)) =>
                                       match (string_drop _s2342_ _s2343_) with
                                       | _s2344_ =>
                                          match (hex_bits_6_matches_prefix _s2344_) with
                                          | Some ((uimm, existT _ _s2345_ _)) =>
                                             let p0_ := string_drop _s2344_ _s2345_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2323_ (_s2324_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2325_ := _s2324_ in
   (if ((string_startswith _s2325_ "c.ldsp")) then
      (match (string_drop _s2325_ (projT1 (string_length "c.ldsp"))) with
       | _s2326_ =>
          (spc_matches_prefix _s2326_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2327_ _)) =>
              (match (string_drop _s2326_ _s2327_) with
               | _s2328_ =>
                  (reg_name_matches_prefix _s2328_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2329_ _)) =>
                      (match (string_drop _s2328_ _s2329_) with
                       | _s2330_ =>
                          (sep_matches_prefix _s2330_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2331_ _)) =>
                                       match (string_drop _s2330_ _s2331_) with
                                       | _s2332_ =>
                                          match (hex_bits_6_matches_prefix _s2332_) with
                                          | Some ((uimm, existT _ _s2333_ _)) =>
                                             let p0_ := string_drop _s2332_ _s2333_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2311_ (_s2312_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2313_ := _s2312_ in
   (if ((string_startswith _s2313_ "c.lwsp")) then
      (match (string_drop _s2313_ (projT1 (string_length "c.lwsp"))) with
       | _s2314_ =>
          (spc_matches_prefix _s2314_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2315_ _)) =>
              (match (string_drop _s2314_ _s2315_) with
               | _s2316_ =>
                  (reg_name_matches_prefix _s2316_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2317_ _)) =>
                      (match (string_drop _s2316_ _s2317_) with
                       | _s2318_ =>
                          (sep_matches_prefix _s2318_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2319_ _)) =>
                                       match (string_drop _s2318_ _s2319_) with
                                       | _s2320_ =>
                                          match (hex_bits_6_matches_prefix _s2320_) with
                                          | Some ((uimm, existT _ _s2321_ _)) =>
                                             let p0_ := string_drop _s2320_ _s2321_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, uimm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2299_ (_s2300_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2301_ := _s2300_ in
   (if ((string_startswith _s2301_ "c.slli")) then
      (match (string_drop _s2301_ (projT1 (string_length "c.slli"))) with
       | _s2302_ =>
          (spc_matches_prefix _s2302_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2303_ _)) =>
              (match (string_drop _s2302_ _s2303_) with
               | _s2304_ =>
                  (reg_name_matches_prefix _s2304_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2305_ _)) =>
                      (match (string_drop _s2304_ _s2305_) with
                       | _s2306_ =>
                          (sep_matches_prefix _s2306_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2307_ _)) =>
                                       match (string_drop _s2306_ _s2307_) with
                                       | _s2308_ =>
                                          match (hex_bits_6_matches_prefix _s2308_) with
                                          | Some ((shamt, existT _ _s2309_ _)) =>
                                             let p0_ := string_drop _s2308_ _s2309_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, shamt))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2287_ (_s2288_ : string) 
: M (option ((mword 3 * mword 8))) :=
   
   let _s2289_ := _s2288_ in
   (if ((string_startswith _s2289_ "c.bnez")) then
      (match (string_drop _s2289_ (projT1 (string_length "c.bnez"))) with
       | _s2290_ =>
          (spc_matches_prefix _s2290_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2291_ _)) =>
              (match (string_drop _s2290_ _s2291_) with
               | _s2292_ =>
                  (creg_name_matches_prefix _s2292_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs, existT _ _s2293_ _)) =>
                      (match (string_drop _s2292_ _s2293_) with
                       | _s2294_ =>
                          (sep_matches_prefix _s2294_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2295_ _)) =>
                                       match (string_drop _s2294_ _s2295_) with
                                       | _s2296_ =>
                                          match (hex_bits_8_matches_prefix _s2296_) with
                                          | Some ((imm, existT _ _s2297_ _)) =>
                                             let p0_ := string_drop _s2296_ _s2297_ in
                                             if ((generic_eq p0_ "")) then Some ((rs, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8)))
                       end)
                       : M (option ((mword 3 * mword 8)))
                   | _ => returnm (None  : option ((mword 3 * mword 8)))
                   end)
                   : M (option ((mword 3 * mword 8)))
               end)
               : M (option ((mword 3 * mword 8)))
           | _ => returnm (None  : option ((mword 3 * mword 8)))
           end)
           : M (option ((mword 3 * mword 8)))
       end)
       : M (option ((mword 3 * mword 8)))
    else returnm (None  : option ((mword 3 * mword 8))))
    : M (option ((mword 3 * mword 8))).

Definition _s2275_ (_s2276_ : string) 
: M (option ((mword 3 * mword 8))) :=
   
   let _s2277_ := _s2276_ in
   (if ((string_startswith _s2277_ "c.beqz")) then
      (match (string_drop _s2277_ (projT1 (string_length "c.beqz"))) with
       | _s2278_ =>
          (spc_matches_prefix _s2278_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2279_ _)) =>
              (match (string_drop _s2278_ _s2279_) with
               | _s2280_ =>
                  (creg_name_matches_prefix _s2280_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs, existT _ _s2281_ _)) =>
                      (match (string_drop _s2280_ _s2281_) with
                       | _s2282_ =>
                          (sep_matches_prefix _s2282_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2283_ _)) =>
                                       match (string_drop _s2282_ _s2283_) with
                                       | _s2284_ =>
                                          match (hex_bits_8_matches_prefix _s2284_) with
                                          | Some ((imm, existT _ _s2285_ _)) =>
                                             let p0_ := string_drop _s2284_ _s2285_ in
                                             if ((generic_eq p0_ "")) then Some ((rs, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8)))
                       end)
                       : M (option ((mword 3 * mword 8)))
                   | _ => returnm (None  : option ((mword 3 * mword 8)))
                   end)
                   : M (option ((mword 3 * mword 8)))
               end)
               : M (option ((mword 3 * mword 8)))
           | _ => returnm (None  : option ((mword 3 * mword 8)))
           end)
           : M (option ((mword 3 * mword 8)))
       end)
       : M (option ((mword 3 * mword 8)))
    else returnm (None  : option ((mword 3 * mword 8))))
    : M (option ((mword 3 * mword 8))).

Definition _s2267_ (_s2268_ : string) 
: M (option (mword 11)) :=
   
   let _s2269_ := _s2268_ in
   (if ((string_startswith _s2269_ "c.j")) then
      (match (string_drop _s2269_ (projT1 (string_length "c.j"))) with
       | _s2270_ =>
          (spc_matches_prefix _s2270_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s2271_ _)) =>
                       match (string_drop _s2270_ _s2271_) with
                       | _s2272_ =>
                          match (hex_bits_11_matches_prefix _s2272_) with
                          | Some ((imm, existT _ _s2273_ _)) =>
                             let p0_ := string_drop _s2272_ _s2273_ in
                             if ((generic_eq p0_ "")) then Some (imm)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 11))
       end)
       : M (option (mword 11))
    else returnm (None  : option (mword 11)))
    : M (option (mword 11)).

Definition _s2255_ (_s2256_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s2257_ := _s2256_ in
   (if ((string_startswith _s2257_ "c.addw")) then
      (match (string_drop _s2257_ (projT1 (string_length "c.addw"))) with
       | _s2258_ =>
          (spc_matches_prefix _s2258_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2259_ _)) =>
              (match (string_drop _s2258_ _s2259_) with
               | _s2260_ =>
                  (creg_name_matches_prefix _s2260_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2261_ _)) =>
                      (match (string_drop _s2260_ _s2261_) with
                       | _s2262_ =>
                          (sep_matches_prefix _s2262_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2263_ _)) =>
                              (match (string_drop _s2262_ _s2263_) with
                               | _s2264_ =>
                                  (creg_name_matches_prefix _s2264_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2265_ _)) =>
                                               let p0_ := string_drop _s2264_ _s2265_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s2243_ (_s2244_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s2245_ := _s2244_ in
   (if ((string_startswith _s2245_ "c.subw")) then
      (match (string_drop _s2245_ (projT1 (string_length "c.subw"))) with
       | _s2246_ =>
          (spc_matches_prefix _s2246_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2247_ _)) =>
              (match (string_drop _s2246_ _s2247_) with
               | _s2248_ =>
                  (creg_name_matches_prefix _s2248_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2249_ _)) =>
                      (match (string_drop _s2248_ _s2249_) with
                       | _s2250_ =>
                          (sep_matches_prefix _s2250_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2251_ _)) =>
                              (match (string_drop _s2250_ _s2251_) with
                               | _s2252_ =>
                                  (creg_name_matches_prefix _s2252_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2253_ _)) =>
                                               let p0_ := string_drop _s2252_ _s2253_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s2231_ (_s2232_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s2233_ := _s2232_ in
   (if ((string_startswith _s2233_ "c.and")) then
      (match (string_drop _s2233_ (projT1 (string_length "c.and"))) with
       | _s2234_ =>
          (spc_matches_prefix _s2234_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2235_ _)) =>
              (match (string_drop _s2234_ _s2235_) with
               | _s2236_ =>
                  (creg_name_matches_prefix _s2236_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2237_ _)) =>
                      (match (string_drop _s2236_ _s2237_) with
                       | _s2238_ =>
                          (sep_matches_prefix _s2238_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2239_ _)) =>
                              (match (string_drop _s2238_ _s2239_) with
                               | _s2240_ =>
                                  (creg_name_matches_prefix _s2240_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2241_ _)) =>
                                               let p0_ := string_drop _s2240_ _s2241_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s2219_ (_s2220_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s2221_ := _s2220_ in
   (if ((string_startswith _s2221_ "c.or")) then
      (match (string_drop _s2221_ (projT1 (string_length "c.or"))) with
       | _s2222_ =>
          (spc_matches_prefix _s2222_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2223_ _)) =>
              (match (string_drop _s2222_ _s2223_) with
               | _s2224_ =>
                  (creg_name_matches_prefix _s2224_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2225_ _)) =>
                      (match (string_drop _s2224_ _s2225_) with
                       | _s2226_ =>
                          (sep_matches_prefix _s2226_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2227_ _)) =>
                              (match (string_drop _s2226_ _s2227_) with
                               | _s2228_ =>
                                  (creg_name_matches_prefix _s2228_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2229_ _)) =>
                                               let p0_ := string_drop _s2228_ _s2229_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s2207_ (_s2208_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s2209_ := _s2208_ in
   (if ((string_startswith _s2209_ "c.xor")) then
      (match (string_drop _s2209_ (projT1 (string_length "c.xor"))) with
       | _s2210_ =>
          (spc_matches_prefix _s2210_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2211_ _)) =>
              (match (string_drop _s2210_ _s2211_) with
               | _s2212_ =>
                  (creg_name_matches_prefix _s2212_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2213_ _)) =>
                      (match (string_drop _s2212_ _s2213_) with
                       | _s2214_ =>
                          (sep_matches_prefix _s2214_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2215_ _)) =>
                              (match (string_drop _s2214_ _s2215_) with
                               | _s2216_ =>
                                  (creg_name_matches_prefix _s2216_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2217_ _)) =>
                                               let p0_ := string_drop _s2216_ _s2217_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s2195_ (_s2196_ : string) 
: M (option ((mword 3 * mword 3))) :=
   
   let _s2197_ := _s2196_ in
   (if ((string_startswith _s2197_ "c.sub")) then
      (match (string_drop _s2197_ (projT1 (string_length "c.sub"))) with
       | _s2198_ =>
          (spc_matches_prefix _s2198_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2199_ _)) =>
              (match (string_drop _s2198_ _s2199_) with
               | _s2200_ =>
                  (creg_name_matches_prefix _s2200_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2201_ _)) =>
                      (match (string_drop _s2200_ _s2201_) with
                       | _s2202_ =>
                          (sep_matches_prefix _s2202_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2203_ _)) =>
                              (match (string_drop _s2202_ _s2203_) with
                               | _s2204_ =>
                                  (creg_name_matches_prefix _s2204_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2205_ _)) =>
                                               let p0_ := string_drop _s2204_ _s2205_ in
                                               if ((generic_eq p0_ "")) then Some ((rsd, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3)))
                               end)
                               : M (option ((mword 3 * mword 3)))
                           | _ => returnm (None  : option ((mword 3 * mword 3)))
                           end)
                           : M (option ((mword 3 * mword 3)))
                       end)
                       : M (option ((mword 3 * mword 3)))
                   | _ => returnm (None  : option ((mword 3 * mword 3)))
                   end)
                   : M (option ((mword 3 * mword 3)))
               end)
               : M (option ((mword 3 * mword 3)))
           | _ => returnm (None  : option ((mword 3 * mword 3)))
           end)
           : M (option ((mword 3 * mword 3)))
       end)
       : M (option ((mword 3 * mword 3)))
    else returnm (None  : option ((mword 3 * mword 3))))
    : M (option ((mword 3 * mword 3))).

Definition _s2183_ (_s2184_ : string) 
: M (option ((mword 3 * mword 6))) :=
   
   let _s2185_ := _s2184_ in
   (if ((string_startswith _s2185_ "c.andi")) then
      (match (string_drop _s2185_ (projT1 (string_length "c.andi"))) with
       | _s2186_ =>
          (spc_matches_prefix _s2186_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2187_ _)) =>
              (match (string_drop _s2186_ _s2187_) with
               | _s2188_ =>
                  (creg_name_matches_prefix _s2188_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2189_ _)) =>
                      (match (string_drop _s2188_ _s2189_) with
                       | _s2190_ =>
                          (sep_matches_prefix _s2190_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2191_ _)) =>
                                       match (string_drop _s2190_ _s2191_) with
                                       | _s2192_ =>
                                          match (hex_bits_6_matches_prefix _s2192_) with
                                          | Some ((imm, existT _ _s2193_ _)) =>
                                             let p0_ := string_drop _s2192_ _s2193_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6)))
                       end)
                       : M (option ((mword 3 * mword 6)))
                   | _ => returnm (None  : option ((mword 3 * mword 6)))
                   end)
                   : M (option ((mword 3 * mword 6)))
               end)
               : M (option ((mword 3 * mword 6)))
           | _ => returnm (None  : option ((mword 3 * mword 6)))
           end)
           : M (option ((mword 3 * mword 6)))
       end)
       : M (option ((mword 3 * mword 6)))
    else returnm (None  : option ((mword 3 * mword 6))))
    : M (option ((mword 3 * mword 6))).

Definition _s2171_ (_s2172_ : string) 
: M (option ((mword 3 * mword 6))) :=
   
   let _s2173_ := _s2172_ in
   (if ((string_startswith _s2173_ "c.srai")) then
      (match (string_drop _s2173_ (projT1 (string_length "c.srai"))) with
       | _s2174_ =>
          (spc_matches_prefix _s2174_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2175_ _)) =>
              (match (string_drop _s2174_ _s2175_) with
               | _s2176_ =>
                  (creg_name_matches_prefix _s2176_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2177_ _)) =>
                      (match (string_drop _s2176_ _s2177_) with
                       | _s2178_ =>
                          (sep_matches_prefix _s2178_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2179_ _)) =>
                                       match (string_drop _s2178_ _s2179_) with
                                       | _s2180_ =>
                                          match (hex_bits_6_matches_prefix _s2180_) with
                                          | Some ((shamt, existT _ _s2181_ _)) =>
                                             let p0_ := string_drop _s2180_ _s2181_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, shamt))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6)))
                       end)
                       : M (option ((mword 3 * mword 6)))
                   | _ => returnm (None  : option ((mword 3 * mword 6)))
                   end)
                   : M (option ((mword 3 * mword 6)))
               end)
               : M (option ((mword 3 * mword 6)))
           | _ => returnm (None  : option ((mword 3 * mword 6)))
           end)
           : M (option ((mword 3 * mword 6)))
       end)
       : M (option ((mword 3 * mword 6)))
    else returnm (None  : option ((mword 3 * mword 6))))
    : M (option ((mword 3 * mword 6))).

Definition _s2159_ (_s2160_ : string) 
: M (option ((mword 3 * mword 6))) :=
   
   let _s2161_ := _s2160_ in
   (if ((string_startswith _s2161_ "c.srli")) then
      (match (string_drop _s2161_ (projT1 (string_length "c.srli"))) with
       | _s2162_ =>
          (spc_matches_prefix _s2162_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2163_ _)) =>
              (match (string_drop _s2162_ _s2163_) with
               | _s2164_ =>
                  (creg_name_matches_prefix _s2164_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2165_ _)) =>
                      (match (string_drop _s2164_ _s2165_) with
                       | _s2166_ =>
                          (sep_matches_prefix _s2166_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2167_ _)) =>
                                       match (string_drop _s2166_ _s2167_) with
                                       | _s2168_ =>
                                          match (hex_bits_6_matches_prefix _s2168_) with
                                          | Some ((shamt, existT _ _s2169_ _)) =>
                                             let p0_ := string_drop _s2168_ _s2169_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, shamt))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6)))
                       end)
                       : M (option ((mword 3 * mword 6)))
                   | _ => returnm (None  : option ((mword 3 * mword 6)))
                   end)
                   : M (option ((mword 3 * mword 6)))
               end)
               : M (option ((mword 3 * mword 6)))
           | _ => returnm (None  : option ((mword 3 * mword 6)))
           end)
           : M (option ((mword 3 * mword 6)))
       end)
       : M (option ((mword 3 * mword 6)))
    else returnm (None  : option ((mword 3 * mword 6))))
    : M (option ((mword 3 * mword 6))).

Definition _s2147_ (_s2148_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2149_ := _s2148_ in
   (if ((string_startswith _s2149_ "c.lui")) then
      (match (string_drop _s2149_ (projT1 (string_length "c.lui"))) with
       | _s2150_ =>
          (spc_matches_prefix _s2150_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2151_ _)) =>
              (match (string_drop _s2150_ _s2151_) with
               | _s2152_ =>
                  (reg_name_matches_prefix _s2152_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2153_ _)) =>
                      (match (string_drop _s2152_ _s2153_) with
                       | _s2154_ =>
                          (sep_matches_prefix _s2154_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2155_ _)) =>
                                       match (string_drop _s2154_ _s2155_) with
                                       | _s2156_ =>
                                          match (hex_bits_6_matches_prefix _s2156_) with
                                          | Some ((imm, existT _ _s2157_ _)) =>
                                             let p0_ := string_drop _s2156_ _s2157_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2139_ (_s2140_ : string) 
: M (option (mword 6)) :=
   
   let _s2141_ := _s2140_ in
   (if ((string_startswith _s2141_ "c.addi16sp")) then
      (match (string_drop _s2141_ (projT1 (string_length "c.addi16sp"))) with
       | _s2142_ =>
          (spc_matches_prefix _s2142_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s2143_ _)) =>
                       match (string_drop _s2142_ _s2143_) with
                       | _s2144_ =>
                          match (hex_bits_6_matches_prefix _s2144_) with
                          | Some ((imm, existT _ _s2145_ _)) =>
                             let p0_ := string_drop _s2144_ _s2145_ in
                             if ((generic_eq p0_ "")) then Some (imm)
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 6))
       end)
       : M (option (mword 6))
    else returnm (None  : option (mword 6)))
    : M (option (mword 6)).

Definition _s2127_ (_s2128_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2129_ := _s2128_ in
   (if ((string_startswith _s2129_ "c.li")) then
      (match (string_drop _s2129_ (projT1 (string_length "c.li"))) with
       | _s2130_ =>
          (spc_matches_prefix _s2130_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2131_ _)) =>
              (match (string_drop _s2130_ _s2131_) with
               | _s2132_ =>
                  (reg_name_matches_prefix _s2132_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2133_ _)) =>
                      (match (string_drop _s2132_ _s2133_) with
                       | _s2134_ =>
                          (sep_matches_prefix _s2134_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2135_ _)) =>
                                       match (string_drop _s2134_ _s2135_) with
                                       | _s2136_ =>
                                          match (hex_bits_6_matches_prefix _s2136_) with
                                          | Some ((imm, existT _ _s2137_ _)) =>
                                             let p0_ := string_drop _s2136_ _s2137_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2115_ (_s2116_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2117_ := _s2116_ in
   (if ((string_startswith _s2117_ "c.addiw")) then
      (match (string_drop _s2117_ (projT1 (string_length "c.addiw"))) with
       | _s2118_ =>
          (spc_matches_prefix _s2118_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2119_ _)) =>
              (match (string_drop _s2118_ _s2119_) with
               | _s2120_ =>
                  (reg_name_matches_prefix _s2120_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2121_ _)) =>
                      (match (string_drop _s2120_ _s2121_) with
                       | _s2122_ =>
                          (sep_matches_prefix _s2122_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2123_ _)) =>
                                       match (string_drop _s2122_ _s2123_) with
                                       | _s2124_ =>
                                          match (hex_bits_6_matches_prefix _s2124_) with
                                          | Some ((imm, existT _ _s2125_ _)) =>
                                             let p0_ := string_drop _s2124_ _s2125_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2107_ (_s2108_ : string) 
: M (option (mword 11)) :=
   
   let _s2109_ := _s2108_ in
   (if ((string_startswith _s2109_ "c.jal")) then
      (match (string_drop _s2109_ (projT1 (string_length "c.jal"))) with
       | _s2110_ =>
          (spc_matches_prefix _s2110_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s2111_ _)) =>
                       match (string_drop _s2110_ _s2111_) with
                       | _s2112_ =>
                          match (hex_bits_12_matches_prefix _s2112_) with
                          | Some ((v__814, existT _ _s2113_ _)) =>
                             if ((eq_vec (subrange_vec_dec v__814 0 0)
                                    (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then
                               let imm : mword 11 := subrange_vec_dec v__814 11 1 in
                               let imm : mword 11 := subrange_vec_dec v__814 11 1 in
                               let p0_ := string_drop _s2112_ _s2113_ in
                               if ((generic_eq p0_ "")) then Some (imm)
                               else None
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option (mword 11))
       end)
       : M (option (mword 11))
    else returnm (None  : option (mword 11)))
    : M (option (mword 11)).

Definition _s2095_ (_s2096_ : string) 
: M (option ((mword 5 * mword 6))) :=
   
   let _s2097_ := _s2096_ in
   (if ((string_startswith _s2097_ "c.addi")) then
      (match (string_drop _s2097_ (projT1 (string_length "c.addi"))) with
       | _s2098_ =>
          (spc_matches_prefix _s2098_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2099_ _)) =>
              (match (string_drop _s2098_ _s2099_) with
               | _s2100_ =>
                  (reg_name_matches_prefix _s2100_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s2101_ _)) =>
                      (match (string_drop _s2100_ _s2101_) with
                       | _s2102_ =>
                          (sep_matches_prefix _s2102_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2103_ _)) =>
                                       match (string_drop _s2102_ _s2103_) with
                                       | _s2104_ =>
                                          match (hex_bits_6_matches_prefix _s2104_) with
                                          | Some ((nzi, existT _ _s2105_ _)) =>
                                             let p0_ := string_drop _s2104_ _s2105_ in
                                             if ((generic_eq p0_ "")) then Some ((rsd, nzi))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6)))
                       end)
                       : M (option ((mword 5 * mword 6)))
                   | _ => returnm (None  : option ((mword 5 * mword 6)))
                   end)
                   : M (option ((mword 5 * mword 6)))
               end)
               : M (option ((mword 5 * mword 6)))
           | _ => returnm (None  : option ((mword 5 * mword 6)))
           end)
           : M (option ((mword 5 * mword 6)))
       end)
       : M (option ((mword 5 * mword 6)))
    else returnm (None  : option ((mword 5 * mword 6))))
    : M (option ((mword 5 * mword 6))).

Definition _s2079_ (_s2080_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s2081_ := _s2080_ in
   (if ((string_startswith _s2081_ "c.sd")) then
      (match (string_drop _s2081_ (projT1 (string_length "c.sd"))) with
       | _s2082_ =>
          (spc_matches_prefix _s2082_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2083_ _)) =>
              (match (string_drop _s2082_ _s2083_) with
               | _s2084_ =>
                  (creg_name_matches_prefix _s2084_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsc1, existT _ _s2085_ _)) =>
                      (match (string_drop _s2084_ _s2085_) with
                       | _s2086_ =>
                          (sep_matches_prefix _s2086_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2087_ _)) =>
                              (match (string_drop _s2086_ _s2087_) with
                               | _s2088_ =>
                                  (creg_name_matches_prefix _s2088_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc2, existT _ _s2089_ _)) =>
                                      (match (string_drop _s2088_ _s2089_) with
                                       | _s2090_ =>
                                          (sep_matches_prefix _s2090_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2091_ _)) =>
                                                       match (string_drop _s2090_ _s2091_) with
                                                       | _s2092_ =>
                                                          match (hex_bits_8_matches_prefix _s2092_) with
                                                          | Some ((v__816, existT _ _s2093_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__816 2 0)
                                                                    (vec_of_bits [B0;B0;B0]
                                                                      : mword (2 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__816 7 3 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__816 7 3 in
                                                               let p0_ :=
                                                                 string_drop _s2092_ _s2093_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rsc1, rsc2, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s2063_ (_s2064_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s2065_ := _s2064_ in
   (if ((string_startswith _s2065_ "c.sw")) then
      (match (string_drop _s2065_ (projT1 (string_length "c.sw"))) with
       | _s2066_ =>
          (spc_matches_prefix _s2066_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2067_ _)) =>
              (match (string_drop _s2066_ _s2067_) with
               | _s2068_ =>
                  (creg_name_matches_prefix _s2068_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsc1, existT _ _s2069_ _)) =>
                      (match (string_drop _s2068_ _s2069_) with
                       | _s2070_ =>
                          (sep_matches_prefix _s2070_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2071_ _)) =>
                              (match (string_drop _s2070_ _s2071_) with
                               | _s2072_ =>
                                  (creg_name_matches_prefix _s2072_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc2, existT _ _s2073_ _)) =>
                                      (match (string_drop _s2072_ _s2073_) with
                                       | _s2074_ =>
                                          (sep_matches_prefix _s2074_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2075_ _)) =>
                                                       match (string_drop _s2074_ _s2075_) with
                                                       | _s2076_ =>
                                                          match (hex_bits_7_matches_prefix _s2076_) with
                                                          | Some ((v__818, existT _ _s2077_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__818 1 0)
                                                                    (vec_of_bits [B0;B0]
                                                                      : mword (1 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__818 6 2 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__818 6 2 in
                                                               let p0_ :=
                                                                 string_drop _s2076_ _s2077_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rsc1, rsc2, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s2047_ (_s2048_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s2049_ := _s2048_ in
   (if ((string_startswith _s2049_ "c.ld")) then
      (match (string_drop _s2049_ (projT1 (string_length "c.ld"))) with
       | _s2050_ =>
          (spc_matches_prefix _s2050_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2051_ _)) =>
              (match (string_drop _s2050_ _s2051_) with
               | _s2052_ =>
                  (creg_name_matches_prefix _s2052_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s2053_ _)) =>
                      (match (string_drop _s2052_ _s2053_) with
                       | _s2054_ =>
                          (sep_matches_prefix _s2054_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2055_ _)) =>
                              (match (string_drop _s2054_ _s2055_) with
                               | _s2056_ =>
                                  (creg_name_matches_prefix _s2056_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc, existT _ _s2057_ _)) =>
                                      (match (string_drop _s2056_ _s2057_) with
                                       | _s2058_ =>
                                          (sep_matches_prefix _s2058_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2059_ _)) =>
                                                       match (string_drop _s2058_ _s2059_) with
                                                       | _s2060_ =>
                                                          match (hex_bits_8_matches_prefix _s2060_) with
                                                          | Some ((v__820, existT _ _s2061_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__820 2 0)
                                                                    (vec_of_bits [B0;B0;B0]
                                                                      : mword (2 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__820 7 3 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__820 7 3 in
                                                               let p0_ :=
                                                                 string_drop _s2060_ _s2061_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rdc, rsc, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s2031_ (_s2032_ : string) 
: M (option ((mword 3 * mword 3 * mword 5))) :=
   
   let _s2033_ := _s2032_ in
   (if ((string_startswith _s2033_ "c.lw")) then
      (match (string_drop _s2033_ (projT1 (string_length "c.lw"))) with
       | _s2034_ =>
          (spc_matches_prefix _s2034_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2035_ _)) =>
              (match (string_drop _s2034_ _s2035_) with
               | _s2036_ =>
                  (creg_name_matches_prefix _s2036_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s2037_ _)) =>
                      (match (string_drop _s2036_ _s2037_) with
                       | _s2038_ =>
                          (sep_matches_prefix _s2038_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2039_ _)) =>
                              (match (string_drop _s2038_ _s2039_) with
                               | _s2040_ =>
                                  (creg_name_matches_prefix _s2040_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc, existT _ _s2041_ _)) =>
                                      (match (string_drop _s2040_ _s2041_) with
                                       | _s2042_ =>
                                          (sep_matches_prefix _s2042_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2043_ _)) =>
                                                       match (string_drop _s2042_ _s2043_) with
                                                       | _s2044_ =>
                                                          match (hex_bits_7_matches_prefix _s2044_) with
                                                          | Some ((v__822, existT _ _s2045_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__822 1 0)
                                                                    (vec_of_bits [B0;B0]
                                                                      : mword (1 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__822 6 2 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__822 6 2 in
                                                               let p0_ :=
                                                                 string_drop _s2044_ _s2045_ in
                                                               if ((generic_eq p0_ "")) then
                                                                 Some
                                                                   ((rdc, rsc, uimm))
                                                               else None
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5)))
                                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5))))
    : M (option ((mword 3 * mword 3 * mword 5))).

Definition _s2019_ (_s2020_ : string) 
: M (option ((mword 3 * mword 8))) :=
   
   let _s2021_ := _s2020_ in
   (if ((string_startswith _s2021_ "c.addi4spn")) then
      (match (string_drop _s2021_ (projT1 (string_length "c.addi4spn"))) with
       | _s2022_ =>
          (spc_matches_prefix _s2022_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2023_ _)) =>
              (match (string_drop _s2022_ _s2023_) with
               | _s2024_ =>
                  (creg_name_matches_prefix _s2024_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s2025_ _)) =>
                      (match (string_drop _s2024_ _s2025_) with
                       | _s2026_ =>
                          (sep_matches_prefix _s2026_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2027_ _)) =>
                                       match (string_drop _s2026_ _s2027_) with
                                       | _s2028_ =>
                                          match (hex_bits_10_matches_prefix _s2028_) with
                                          | Some ((v__824, existT _ _s2029_ _)) =>
                                             if ((eq_vec (subrange_vec_dec v__824 1 0)
                                                    (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))
                                             then
                                               let nzimm : mword 8 := subrange_vec_dec v__824 9 2 in
                                               let nzimm : mword 8 := subrange_vec_dec v__824 9 2 in
                                               let p0_ := string_drop _s2028_ _s2029_ in
                                               if ((generic_eq p0_ "")) then Some ((rdc, nzimm))
                                               else None
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8)))
                       end)
                       : M (option ((mword 3 * mword 8)))
                   | _ => returnm (None  : option ((mword 3 * mword 8)))
                   end)
                   : M (option ((mword 3 * mword 8)))
               end)
               : M (option ((mword 3 * mword 8)))
           | _ => returnm (None  : option ((mword 3 * mword 8)))
           end)
           : M (option ((mword 3 * mword 8)))
       end)
       : M (option ((mword 3 * mword 8)))
    else returnm (None  : option ((mword 3 * mword 8))))
    : M (option ((mword 3 * mword 8))).

Definition _s1995_ (_s1996_ : string) 
: M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1996_ with
    | _s1997_ =>
       (amo_mnemonic_matches_prefix _s1997_) >>= fun w__0 : option ((amoop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1998_ _)) =>
           let _s1999_ := string_drop _s1997_ _s1998_ in
           (if ((string_startswith _s1999_ ".")) then
              (match (string_drop _s1999_ (projT1 (string_length "."))) with
               | _s2000_ =>
                  (size_mnemonic_matches_prefix _s2000_) >>= fun w__1 : option ((word_width * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((width, existT _ _s2001_ _)) =>
                      (match (string_drop _s2000_ _s2001_) with
                       | _s2002_ =>
                          (maybe_aq_matches_prefix _s2002_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((aq, existT _ _s2003_ _)) =>
                              (match (string_drop _s2002_ _s2003_) with
                               | _s2004_ =>
                                  (maybe_rl_matches_prefix _s2004_) >>= fun w__3 : option ((bool * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rl, existT _ _s2005_ _)) =>
                                      (match (string_drop _s2004_ _s2005_) with
                                       | _s2006_ =>
                                          (spc_matches_prefix _s2006_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s2007_ _)) =>
                                              (match (string_drop _s2006_ _s2007_) with
                                               | _s2008_ =>
                                                  (reg_name_matches_prefix _s2008_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((rd, existT _ _s2009_ _)) =>
                                                      (match (string_drop _s2008_ _s2009_) with
                                                       | _s2010_ =>
                                                          (sep_matches_prefix _s2010_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((tt, existT _ _s2011_ _)) =>
                                                              (match (string_drop _s2010_ _s2011_) with
                                                               | _s2012_ =>
                                                                  (reg_name_matches_prefix _s2012_) >>= fun w__7 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__7 with
                                                                   | Some
                                                                     ((rs1, existT _ _s2013_ _)) =>
                                                                      (match (string_drop _s2012_
                                                                                _s2013_) with
                                                                       | _s2014_ =>
                                                                          (sep_matches_prefix
                                                                             _s2014_) >>= fun w__8 : option ((unit * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          (match w__8 with
                                                                           | Some
                                                                             ((tt, existT _ _s2015_ _)) =>
                                                                              (match (string_drop
                                                                                        _s2014_
                                                                                        _s2015_) with
                                                                               | _s2016_ =>
                                                                                  (reg_name_matches_prefix
                                                                                     _s2016_) >>= fun w__9 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                    0)})) =>
                                                                                  returnm ((match w__9 with
                                                                                            | Some
                                                                                              ((rs2, existT _ _s2017_ _)) =>
                                                                                               let p0_ :=
                                                                                                 string_drop
                                                                                                   _s2016_
                                                                                                   _s2017_ in
                                                                                               if ((generic_eq
                                                                                                      p0_
                                                                                                      ""))
                                                                                               then
                                                                                                 Some
                                                                                                   ((op, width, aq, rl, rd, rs1, rs2))
                                                                                               else
                                                                                                 None
                                                                                            | _ =>
                                                                                               None
                                                                                            end)
                                                                                   : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                               end)
                                                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                           | _ =>
                                                                              returnm (None
                                                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                           end)
                                                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                       end)
                                                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   end)
                                                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                               end)
                                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           end)
                                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
            else
              returnm (None
               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5))))
            : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
        | _ =>
           returnm (None
            : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5))).

Definition _s1973_ (_s1974_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5))) :=
   
   let _s1975_ := _s1974_ in
   (if ((string_startswith _s1975_ "sc.")) then
      (match (string_drop _s1975_ (projT1 (string_length "sc."))) with
       | _s1976_ =>
          (size_mnemonic_matches_prefix _s1976_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s1977_ _)) =>
              (match (string_drop _s1976_ _s1977_) with
               | _s1978_ =>
                  (maybe_aq_matches_prefix _s1978_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s1979_ _)) =>
                      (match (string_drop _s1978_ _s1979_) with
                       | _s1980_ =>
                          (maybe_rl_matches_prefix _s1980_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s1981_ _)) =>
                              (match (string_drop _s1980_ _s1981_) with
                               | _s1982_ =>
                                  (spc_matches_prefix _s1982_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1983_ _)) =>
                                      (match (string_drop _s1982_ _s1983_) with
                                       | _s1984_ =>
                                          (reg_name_matches_prefix _s1984_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rd, existT _ _s1985_ _)) =>
                                              (match (string_drop _s1984_ _s1985_) with
                                               | _s1986_ =>
                                                  (sep_matches_prefix _s1986_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s1987_ _)) =>
                                                      (match (string_drop _s1986_ _s1987_) with
                                                       | _s1988_ =>
                                                          (reg_name_matches_prefix _s1988_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((rs1, existT _ _s1989_ _)) =>
                                                              (match (string_drop _s1988_ _s1989_) with
                                                               | _s1990_ =>
                                                                  (sep_matches_prefix _s1990_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__7 with
                                                                   | Some ((tt, existT _ _s1991_ _)) =>
                                                                      (match (string_drop _s1990_
                                                                                _s1991_) with
                                                                       | _s1992_ =>
                                                                          (reg_name_matches_prefix
                                                                             _s1992_) >>= fun w__8 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          returnm ((match w__8 with
                                                                                    | Some
                                                                                      ((rs2, existT _ _s1993_ _)) =>
                                                                                       let p0_ :=
                                                                                         string_drop
                                                                                           _s1992_
                                                                                           _s1993_ in
                                                                                       if ((generic_eq
                                                                                              p0_ ""))
                                                                                       then
                                                                                         Some
                                                                                           ((size, aq, rl, rd, rs1, rs2))
                                                                                       else None
                                                                                    | _ => None
                                                                                    end)
                                                                           : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                       end)
                                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
           | _ =>
              returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5))))
    : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5))).

Definition _s1955_ (_s1956_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 5))) :=
   
   let _s1957_ := _s1956_ in
   (if ((string_startswith _s1957_ "lr.")) then
      (match (string_drop _s1957_ (projT1 (string_length "lr."))) with
       | _s1958_ =>
          (size_mnemonic_matches_prefix _s1958_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s1959_ _)) =>
              (match (string_drop _s1958_ _s1959_) with
               | _s1960_ =>
                  (maybe_aq_matches_prefix _s1960_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s1961_ _)) =>
                      (match (string_drop _s1960_ _s1961_) with
                       | _s1962_ =>
                          (maybe_rl_matches_prefix _s1962_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s1963_ _)) =>
                              (match (string_drop _s1962_ _s1963_) with
                               | _s1964_ =>
                                  (spc_matches_prefix _s1964_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1965_ _)) =>
                                      (match (string_drop _s1964_ _s1965_) with
                                       | _s1966_ =>
                                          (reg_name_matches_prefix _s1966_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rd, existT _ _s1967_ _)) =>
                                              (match (string_drop _s1966_ _s1967_) with
                                               | _s1968_ =>
                                                  (sep_matches_prefix _s1968_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s1969_ _)) =>
                                                      (match (string_drop _s1968_ _s1969_) with
                                                       | _s1970_ =>
                                                          (reg_name_matches_prefix _s1970_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs1, existT _ _s1971_ _)) =>
                                                                       let p0_ :=
                                                                         string_drop _s1970_ _s1971_ in
                                                                       if ((generic_eq p0_ "")) then
                                                                         Some
                                                                           ((size, aq, rl, rd, rs1))
                                                                       else None
                                                                    | _ => None
                                                                    end)
                                                           : option ((word_width * bool * bool * mword 5 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
                   | _ => returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 5)))
           | _ => returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5))))
    : M (option ((word_width * bool * bool * mword 5 * mword 5))).

Definition _s1943_ (_s1944_ : string) 
: M (option ((mword 5 * mword 5))) :=
   
   let _s1945_ := _s1944_ in
   (if ((string_startswith _s1945_ "sfence.vma")) then
      (match (string_drop _s1945_ (projT1 (string_length "sfence.vma"))) with
       | _s1946_ =>
          (spc_matches_prefix _s1946_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1947_ _)) =>
              (match (string_drop _s1946_ _s1947_) with
               | _s1948_ =>
                  (reg_name_matches_prefix _s1948_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs1, existT _ _s1949_ _)) =>
                      (match (string_drop _s1948_ _s1949_) with
                       | _s1950_ =>
                          (sep_matches_prefix _s1950_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1951_ _)) =>
                              (match (string_drop _s1950_ _s1951_) with
                               | _s1952_ =>
                                  (reg_name_matches_prefix _s1952_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s1953_ _)) =>
                                               let p0_ := string_drop _s1952_ _s1953_ in
                                               if ((generic_eq p0_ "")) then Some ((rs1, rs2))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5)))
                               end)
                               : M (option ((mword 5 * mword 5)))
                           | _ => returnm (None  : option ((mword 5 * mword 5)))
                           end)
                           : M (option ((mword 5 * mword 5)))
                       end)
                       : M (option ((mword 5 * mword 5)))
                   | _ => returnm (None  : option ((mword 5 * mword 5)))
                   end)
                   : M (option ((mword 5 * mword 5)))
               end)
               : M (option ((mword 5 * mword 5)))
           | _ => returnm (None  : option ((mword 5 * mword 5)))
           end)
           : M (option ((mword 5 * mword 5)))
       end)
       : M (option ((mword 5 * mword 5)))
    else returnm (None  : option ((mword 5 * mword 5))))
    : M (option ((mword 5 * mword 5))).

Definition _s1931_ (_s1932_ : string) 
: M (option ((mword 4 * mword 4))) :=
   
   let _s1933_ := _s1932_ in
   (if ((string_startswith _s1933_ "fence.tso")) then
      (match (string_drop _s1933_ (projT1 (string_length "fence.tso"))) with
       | _s1934_ =>
          (spc_matches_prefix _s1934_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1935_ _)) =>
              (match (string_drop _s1934_ _s1935_) with
               | _s1936_ =>
                  (fence_bits_matches_prefix _s1936_) >>= fun w__1 : option ((mword 4 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((pred, existT _ _s1937_ _)) =>
                      (match (string_drop _s1936_ _s1937_) with
                       | _s1938_ =>
                          (sep_matches_prefix _s1938_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1939_ _)) =>
                              (match (string_drop _s1938_ _s1939_) with
                               | _s1940_ =>
                                  (fence_bits_matches_prefix _s1940_) >>= fun w__3 : option ((mword 4 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((succ, existT _ _s1941_ _)) =>
                                               let p0_ := string_drop _s1940_ _s1941_ in
                                               if ((generic_eq p0_ "")) then Some ((pred, succ))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 4 * mword 4)))
                               end)
                               : M (option ((mword 4 * mword 4)))
                           | _ => returnm (None  : option ((mword 4 * mword 4)))
                           end)
                           : M (option ((mword 4 * mword 4)))
                       end)
                       : M (option ((mword 4 * mword 4)))
                   | _ => returnm (None  : option ((mword 4 * mword 4)))
                   end)
                   : M (option ((mword 4 * mword 4)))
               end)
               : M (option ((mword 4 * mword 4)))
           | _ => returnm (None  : option ((mword 4 * mword 4)))
           end)
           : M (option ((mword 4 * mword 4)))
       end)
       : M (option ((mword 4 * mword 4)))
    else returnm (None  : option ((mword 4 * mword 4))))
    : M (option ((mword 4 * mword 4))).

Definition _s1919_ (_s1920_ : string) 
: M (option ((mword 4 * mword 4))) :=
   
   let _s1921_ := _s1920_ in
   (if ((string_startswith _s1921_ "fence")) then
      (match (string_drop _s1921_ (projT1 (string_length "fence"))) with
       | _s1922_ =>
          (spc_matches_prefix _s1922_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1923_ _)) =>
              (match (string_drop _s1922_ _s1923_) with
               | _s1924_ =>
                  (fence_bits_matches_prefix _s1924_) >>= fun w__1 : option ((mword 4 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((pred, existT _ _s1925_ _)) =>
                      (match (string_drop _s1924_ _s1925_) with
                       | _s1926_ =>
                          (sep_matches_prefix _s1926_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1927_ _)) =>
                              (match (string_drop _s1926_ _s1927_) with
                               | _s1928_ =>
                                  (fence_bits_matches_prefix _s1928_) >>= fun w__3 : option ((mword 4 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((succ, existT _ _s1929_ _)) =>
                                               let p0_ := string_drop _s1928_ _s1929_ in
                                               if ((generic_eq p0_ "")) then Some ((pred, succ))
                                               else None
                                            | _ => None
                                            end)
                                   : option ((mword 4 * mword 4)))
                               end)
                               : M (option ((mword 4 * mword 4)))
                           | _ => returnm (None  : option ((mword 4 * mword 4)))
                           end)
                           : M (option ((mword 4 * mword 4)))
                       end)
                       : M (option ((mword 4 * mword 4)))
                   | _ => returnm (None  : option ((mword 4 * mword 4)))
                   end)
                   : M (option ((mword 4 * mword 4)))
               end)
               : M (option ((mword 4 * mword 4)))
           | _ => returnm (None  : option ((mword 4 * mword 4)))
           end)
           : M (option ((mword 4 * mword 4)))
       end)
       : M (option ((mword 4 * mword 4)))
    else returnm (None  : option ((mword 4 * mword 4))))
    : M (option ((mword 4 * mword 4))).

Definition _s1902_ (_s1903_ : string) 
: M (option ((sopw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1903_ with
    | _s1904_ =>
       (shiftiwop_mnemonic_matches_prefix _s1904_) >>= fun w__0 : option ((sopw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1905_ _)) =>
           (match (string_drop _s1904_ _s1905_) with
            | _s1906_ =>
               (spc_matches_prefix _s1906_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1907_ _)) =>
                   (match (string_drop _s1906_ _s1907_) with
                    | _s1908_ =>
                       (reg_name_matches_prefix _s1908_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1909_ _)) =>
                           (match (string_drop _s1908_ _s1909_) with
                            | _s1910_ =>
                               (sep_matches_prefix _s1910_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1911_ _)) =>
                                   (match (string_drop _s1910_ _s1911_) with
                                    | _s1912_ =>
                                       (reg_name_matches_prefix _s1912_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1913_ _)) =>
                                           (match (string_drop _s1912_ _s1913_) with
                                            | _s1914_ =>
                                               (sep_matches_prefix _s1914_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s1915_ _)) =>
                                                            match (string_drop _s1914_ _s1915_) with
                                                            | _s1916_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s1916_) with
                                                               | Some ((shamt, existT _ _s1917_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1916_ _s1917_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sopw * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((sopw * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sopw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sopw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sopw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sopw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sopw * mword 5 * mword 5 * mword 5))).

Definition _s1885_ (_s1886_ : string) 
: M (option ((ropw * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1886_ with
    | _s1887_ =>
       (rtypew_mnemonic_matches_prefix _s1887_) >>= fun w__0 : option ((ropw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1888_ _)) =>
           (match (string_drop _s1887_ _s1888_) with
            | _s1889_ =>
               (spc_matches_prefix _s1889_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1890_ _)) =>
                   (match (string_drop _s1889_ _s1890_) with
                    | _s1891_ =>
                       (reg_name_matches_prefix _s1891_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1892_ _)) =>
                           (match (string_drop _s1891_ _s1892_) with
                            | _s1893_ =>
                               (sep_matches_prefix _s1893_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1894_ _)) =>
                                   (match (string_drop _s1893_ _s1894_) with
                                    | _s1895_ =>
                                       (reg_name_matches_prefix _s1895_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1896_ _)) =>
                                           (match (string_drop _s1895_ _s1896_) with
                                            | _s1897_ =>
                                               (sep_matches_prefix _s1897_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s1898_ _)) =>
                                                   (match (string_drop _s1897_ _s1898_) with
                                                    | _s1899_ =>
                                                       (reg_name_matches_prefix _s1899_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s1900_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s1899_ _s1900_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((ropw * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((ropw * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((ropw * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((ropw * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((ropw * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((ropw * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((ropw * mword 5 * mword 5 * mword 5))).

Definition _s1868_ (_s1869_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1869_ with
    | _s1870_ =>
       (shiftw_mnemonic_matches_prefix _s1870_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1871_ _)) =>
           (match (string_drop _s1870_ _s1871_) with
            | _s1872_ =>
               (spc_matches_prefix _s1872_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1873_ _)) =>
                   (match (string_drop _s1872_ _s1873_) with
                    | _s1874_ =>
                       (reg_name_matches_prefix _s1874_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1875_ _)) =>
                           (match (string_drop _s1874_ _s1875_) with
                            | _s1876_ =>
                               (sep_matches_prefix _s1876_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1877_ _)) =>
                                   (match (string_drop _s1876_ _s1877_) with
                                    | _s1878_ =>
                                       (reg_name_matches_prefix _s1878_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1879_ _)) =>
                                           (match (string_drop _s1878_ _s1879_) with
                                            | _s1880_ =>
                                               (sep_matches_prefix _s1880_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s1881_ _)) =>
                                                            match (string_drop _s1880_ _s1881_) with
                                                            | _s1882_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s1882_) with
                                                               | Some ((shamt, existT _ _s1883_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1882_ _s1883_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 5))).

Definition _s1852_ (_s1853_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s1854_ := _s1853_ in
   (if ((string_startswith _s1854_ "addiw")) then
      (match (string_drop _s1854_ (projT1 (string_length "addiw"))) with
       | _s1855_ =>
          (spc_matches_prefix _s1855_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1856_ _)) =>
              (match (string_drop _s1855_ _s1856_) with
               | _s1857_ =>
                  (reg_name_matches_prefix _s1857_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1858_ _)) =>
                      (match (string_drop _s1857_ _s1858_) with
                       | _s1859_ =>
                          (sep_matches_prefix _s1859_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1860_ _)) =>
                              (match (string_drop _s1859_ _s1860_) with
                               | _s1861_ =>
                                  (reg_name_matches_prefix _s1861_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s1862_ _)) =>
                                      (match (string_drop _s1861_ _s1862_) with
                                       | _s1863_ =>
                                          (sep_matches_prefix _s1863_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s1864_ _)) =>
                                                       match (string_drop _s1863_ _s1864_) with
                                                       | _s1865_ =>
                                                          match (hex_bits_12_matches_prefix _s1865_) with
                                                          | Some ((imm, existT _ _s1866_ _)) =>
                                                             let p0_ := string_drop _s1865_ _s1866_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s1824_ (_s1825_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))) :=
   
   let _s1826_ := _s1825_ in
   (if ((string_startswith _s1826_ "s")) then
      (match (string_drop _s1826_ (projT1 (string_length "s"))) with
       | _s1827_ =>
          (size_mnemonic_matches_prefix _s1827_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s1828_ _)) =>
              (match (string_drop _s1827_ _s1828_) with
               | _s1829_ =>
                  (maybe_aq_matches_prefix _s1829_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s1830_ _)) =>
                      (match (string_drop _s1829_ _s1830_) with
                       | _s1831_ =>
                          (maybe_rl_matches_prefix _s1831_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s1832_ _)) =>
                              (match (string_drop _s1831_ _s1832_) with
                               | _s1833_ =>
                                  (spc_matches_prefix _s1833_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s1834_ _)) =>
                                      (match (string_drop _s1833_ _s1834_) with
                                       | _s1835_ =>
                                          (reg_name_matches_prefix _s1835_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs2, existT _ _s1836_ _)) =>
                                              (match (string_drop _s1835_ _s1836_) with
                                               | _s1837_ =>
                                                  (sep_matches_prefix _s1837_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s1838_ _)) =>
                                                      (match (string_drop _s1837_ _s1838_) with
                                                       | _s1839_ =>
                                                          (match (hex_bits_12_matches_prefix _s1839_) with
                                                           | Some ((imm, existT _ _s1840_ _)) =>
                                                              (match (string_drop _s1839_ _s1840_) with
                                                               | _s1841_ =>
                                                                  (opt_spc_matches_prefix _s1841_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__6 with
                                                                   | Some ((tt, existT _ _s1842_ _)) =>
                                                                      let _s1843_ :=
                                                                        string_drop _s1841_ _s1842_ in
                                                                      (if ((string_startswith
                                                                              _s1843_ "(")) then
                                                                         (match (string_drop _s1843_
                                                                                   (projT1
                                                                                    (string_length
                                                                                       "("))) with
                                                                          | _s1844_ =>
                                                                             (opt_spc_matches_prefix
                                                                                _s1844_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                               0)})) =>
                                                                             (match w__7 with
                                                                              | Some
                                                                                ((tt, existT _ _s1845_ _)) =>
                                                                                 (match (string_drop
                                                                                           _s1844_
                                                                                           _s1845_) with
                                                                                  | _s1846_ =>
                                                                                     (reg_name_matches_prefix
                                                                                        _s1846_) >>= fun w__8 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                       0)})) =>
                                                                                     (match w__8 with
                                                                                      | Some
                                                                                        ((rs1, existT _ _s1847_ _)) =>
                                                                                         (match (string_drop
                                                                                                   _s1846_
                                                                                                   _s1847_) with
                                                                                          | _s1848_ =>
                                                                                             (opt_spc_matches_prefix
                                                                                                _s1848_) >>= fun w__9 : option ((unit * {n : Z & ArithFact (n >=
                                                                                               0)})) =>
                                                                                             returnm ((match w__9 with
                                                                                                       | Some
                                                                                                         ((tt, existT _ _s1849_ _)) =>
                                                                                                          let _s1850_ :=
                                                                                                            string_drop
                                                                                                              _s1848_
                                                                                                              _s1849_ in
                                                                                                          if
                                                                                                            ((string_startswith
                                                                                                                _s1850_
                                                                                                                ")"))
                                                                                                          then
                                                                                                            let p0_ :=
                                                                                                              string_drop
                                                                                                                _s1850_
                                                                                                                (projT1
                                                                                                                 (string_length
                                                                                                                    ")")) in
                                                                                                            if
                                                                                                              ((generic_eq
                                                                                                                  p0_
                                                                                                                  ""))
                                                                                                            then
                                                                                                              Some
                                                                                                                ((size, aq, rl, rs2, imm, rs1))
                                                                                                            else
                                                                                                              None
                                                                                                          else
                                                                                                            None
                                                                                                       | _ =>
                                                                                                          None
                                                                                                       end)
                                                                                              : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                          end)
                                                                                          : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      | _ =>
                                                                                         returnm (None
                                                                                          : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      end)
                                                                                      : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                  end)
                                                                                  : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                              | _ =>
                                                                                 returnm (None
                                                                                  : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                              end)
                                                                              : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                          end)
                                                                          : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                       else
                                                                         returnm (None
                                                                          : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))))
                                                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
           | _ =>
              returnm (None  : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))))
    : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5))).

Definition _s1794_ (_s1795_ : string) 
: M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))) :=
   
   let _s1796_ := _s1795_ in
   (if ((string_startswith _s1796_ "l")) then
      (match (string_drop _s1796_ (projT1 (string_length "l"))) with
       | _s1797_ =>
          (size_mnemonic_matches_prefix _s1797_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s1798_ _)) =>
              (match (string_drop _s1797_ _s1798_) with
               | _s1799_ =>
                  (maybe_u_matches_prefix _s1799_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((is_unsigned, existT _ _s1800_ _)) =>
                      (match (string_drop _s1799_ _s1800_) with
                       | _s1801_ =>
                          (maybe_aq_matches_prefix _s1801_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((aq, existT _ _s1802_ _)) =>
                              (match (string_drop _s1801_ _s1802_) with
                               | _s1803_ =>
                                  (maybe_rl_matches_prefix _s1803_) >>= fun w__3 : option ((bool * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rl, existT _ _s1804_ _)) =>
                                      (match (string_drop _s1803_ _s1804_) with
                                       | _s1805_ =>
                                          (spc_matches_prefix _s1805_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s1806_ _)) =>
                                              (match (string_drop _s1805_ _s1806_) with
                                               | _s1807_ =>
                                                  (reg_name_matches_prefix _s1807_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((rd, existT _ _s1808_ _)) =>
                                                      (match (string_drop _s1807_ _s1808_) with
                                                       | _s1809_ =>
                                                          (sep_matches_prefix _s1809_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((tt, existT _ _s1810_ _)) =>
                                                              (match (string_drop _s1809_ _s1810_) with
                                                               | _s1811_ =>
                                                                  (match (hex_bits_12_matches_prefix
                                                                            _s1811_) with
                                                                   | Some
                                                                     ((imm, existT _ _s1812_ _)) =>
                                                                      (match (string_drop _s1811_
                                                                                _s1812_) with
                                                                       | _s1813_ =>
                                                                          (opt_spc_matches_prefix
                                                                             _s1813_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          (match w__7 with
                                                                           | Some
                                                                             ((tt, existT _ _s1814_ _)) =>
                                                                              let _s1815_ :=
                                                                                string_drop _s1813_
                                                                                  _s1814_ in
                                                                              (if ((string_startswith
                                                                                      _s1815_ "("))
                                                                               then
                                                                                 (match (string_drop
                                                                                           _s1815_
                                                                                           (projT1
                                                                                            (string_length
                                                                                               "("))) with
                                                                                  | _s1816_ =>
                                                                                     (opt_spc_matches_prefix
                                                                                        _s1816_) >>= fun w__8 : option ((unit * {n : Z & ArithFact (n >=
                                                                                       0)})) =>
                                                                                     (match w__8 with
                                                                                      | Some
                                                                                        ((tt, existT _ _s1817_ _)) =>
                                                                                         (match (string_drop
                                                                                                   _s1816_
                                                                                                   _s1817_) with
                                                                                          | _s1818_ =>
                                                                                             (reg_name_matches_prefix
                                                                                                _s1818_) >>= fun w__9 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                               0)})) =>
                                                                                             (match w__9 with
                                                                                              | Some
                                                                                                ((rs1, existT _ _s1819_ _)) =>
                                                                                                 (match (string_drop
                                                                                                           _s1818_
                                                                                                           _s1819_) with
                                                                                                  | _s1820_ =>
                                                                                                     (opt_spc_matches_prefix
                                                                                                        _s1820_) >>= fun w__10 : option ((unit * {n : Z & ArithFact (n >=
                                                                                                       0)})) =>
                                                                                                     returnm ((match w__10 with
                                                                                                               | Some
                                                                                                                 ((tt, existT _ _s1821_ _)) =>
                                                                                                                  let _s1822_ :=
                                                                                                                    string_drop
                                                                                                                      _s1820_
                                                                                                                      _s1821_ in
                                                                                                                  if
                                                                                                                    ((string_startswith
                                                                                                                        _s1822_
                                                                                                                        ")"))
                                                                                                                  then
                                                                                                                    let p0_ :=
                                                                                                                      string_drop
                                                                                                                        _s1822_
                                                                                                                        (projT1
                                                                                                                         (string_length
                                                                                                                            ")")) in
                                                                                                                    if
                                                                                                                      ((generic_eq
                                                                                                                          p0_
                                                                                                                          ""))
                                                                                                                    then
                                                                                                                      Some
                                                                                                                        ((size, is_unsigned, aq, rl, rd, imm, rs1))
                                                                                                                    else
                                                                                                                      None
                                                                                                                  else
                                                                                                                    None
                                                                                                               | _ =>
                                                                                                                  None
                                                                                                               end)
                                                                                                      : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                                  end)
                                                                                                  : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                              | _ =>
                                                                                                 returnm (None
                                                                                                  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                              end)
                                                                                              : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                          end)
                                                                                          : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      | _ =>
                                                                                         returnm (None
                                                                                          : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                      end)
                                                                                      : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                                  end)
                                                                                  : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                               else
                                                                                 returnm (None
                                                                                  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))))
                                                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                           | _ =>
                                                                              returnm (None
                                                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                           end)
                                                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                       end)
                                                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                               end)
                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                           end)
                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                       end)
                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                                   end)
                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                               end)
                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                           end)
                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                       end)
                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
                   end)
                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
               end)
               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
           | _ =>
              returnm (None
               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
           end)
           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
       end)
       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)))
    else returnm (None  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))))
    : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5))).

Definition _s1777_ (_s1778_ : string) 
: M (option ((rop * mword 5 * mword 5 * mword 5))) :=
   
   (match _s1778_ with
    | _s1779_ =>
       (rtype_mnemonic_matches_prefix _s1779_) >>= fun w__0 : option ((rop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1780_ _)) =>
           (match (string_drop _s1779_ _s1780_) with
            | _s1781_ =>
               (spc_matches_prefix _s1781_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1782_ _)) =>
                   (match (string_drop _s1781_ _s1782_) with
                    | _s1783_ =>
                       (reg_name_matches_prefix _s1783_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1784_ _)) =>
                           (match (string_drop _s1783_ _s1784_) with
                            | _s1785_ =>
                               (sep_matches_prefix _s1785_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1786_ _)) =>
                                   (match (string_drop _s1785_ _s1786_) with
                                    | _s1787_ =>
                                       (reg_name_matches_prefix _s1787_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1788_ _)) =>
                                           (match (string_drop _s1787_ _s1788_) with
                                            | _s1789_ =>
                                               (sep_matches_prefix _s1789_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s1790_ _)) =>
                                                   (match (string_drop _s1789_ _s1790_) with
                                                    | _s1791_ =>
                                                       (reg_name_matches_prefix _s1791_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s1792_ _)) =>
                                                                    let p0_ :=
                                                                      string_drop _s1791_ _s1792_ in
                                                                    if ((generic_eq p0_ "")) then
                                                                      Some
                                                                        ((op, rd, rs1, rs2))
                                                                    else None
                                                                 | _ => None
                                                                 end)
                                                        : option ((rop * mword 5 * mword 5 * mword 5)))
                                                    end)
                                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((rop * mword 5 * mword 5 * mword 5)))
                                                end)
                                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                            end)
                                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                        | _ =>
                                           returnm (None
                                            : option ((rop * mword 5 * mword 5 * mword 5)))
                                        end)
                                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                    end)
                                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                                | _ =>
                                   returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                                end)
                                : M (option ((rop * mword 5 * mword 5 * mword 5)))
                            end)
                            : M (option ((rop * mword 5 * mword 5 * mword 5)))
                        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                        end)
                        : M (option ((rop * mword 5 * mword 5 * mword 5)))
                    end)
                    : M (option ((rop * mword 5 * mword 5 * mword 5)))
                | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
                end)
                : M (option ((rop * mword 5 * mword 5 * mword 5)))
            end)
            : M (option ((rop * mword 5 * mword 5 * mword 5)))
        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5)))
        end)
        : M (option ((rop * mword 5 * mword 5 * mword 5)))
    end)
    : M (option ((rop * mword 5 * mword 5 * mword 5))).

Definition _s1760_ (_s1761_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 6))) :=
   
   (match _s1761_ with
    | _s1762_ =>
       (shiftiop_mnemonic_matches_prefix _s1762_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1763_ _)) =>
           (match (string_drop _s1762_ _s1763_) with
            | _s1764_ =>
               (spc_matches_prefix _s1764_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1765_ _)) =>
                   (match (string_drop _s1764_ _s1765_) with
                    | _s1766_ =>
                       (reg_name_matches_prefix _s1766_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1767_ _)) =>
                           (match (string_drop _s1766_ _s1767_) with
                            | _s1768_ =>
                               (sep_matches_prefix _s1768_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1769_ _)) =>
                                   (match (string_drop _s1768_ _s1769_) with
                                    | _s1770_ =>
                                       (reg_name_matches_prefix _s1770_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1771_ _)) =>
                                           (match (string_drop _s1770_ _s1771_) with
                                            | _s1772_ =>
                                               (sep_matches_prefix _s1772_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s1773_ _)) =>
                                                            match (string_drop _s1772_ _s1773_) with
                                                            | _s1774_ =>
                                                               match (hex_bits_6_matches_prefix
                                                                        _s1774_) with
                                                               | Some ((shamt, existT _ _s1775_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1774_ _s1775_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, shamt))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 6)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 6)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                                | _ =>
                                   returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 6)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 6)))
                        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 6)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 6)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 6)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 6)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 6)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 6))).

Definition _s1743_ (_s1744_ : string) 
: M (option ((iop * mword 5 * mword 5 * mword 12))) :=
   
   (match _s1744_ with
    | _s1745_ =>
       (itype_mnemonic_matches_prefix _s1745_) >>= fun w__0 : option ((iop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1746_ _)) =>
           (match (string_drop _s1745_ _s1746_) with
            | _s1747_ =>
               (spc_matches_prefix _s1747_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1748_ _)) =>
                   (match (string_drop _s1747_ _s1748_) with
                    | _s1749_ =>
                       (reg_name_matches_prefix _s1749_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1750_ _)) =>
                           (match (string_drop _s1749_ _s1750_) with
                            | _s1751_ =>
                               (sep_matches_prefix _s1751_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1752_ _)) =>
                                   (match (string_drop _s1751_ _s1752_) with
                                    | _s1753_ =>
                                       (reg_name_matches_prefix _s1753_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s1754_ _)) =>
                                           (match (string_drop _s1753_ _s1754_) with
                                            | _s1755_ =>
                                               (sep_matches_prefix _s1755_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s1756_ _)) =>
                                                            match (string_drop _s1755_ _s1756_) with
                                                            | _s1757_ =>
                                                               match (hex_bits_12_matches_prefix
                                                                        _s1757_) with
                                                               | Some ((imm, existT _ _s1758_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1757_ _s1758_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rd, rs1, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((iop * mword 5 * mword 5 * mword 12)))
                                            end)
                                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                        | _ =>
                                           returnm (None
                                            : option ((iop * mword 5 * mword 5 * mword 12)))
                                        end)
                                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                    end)
                                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                                | _ =>
                                   returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                                end)
                                : M (option ((iop * mword 5 * mword 5 * mword 12)))
                            end)
                            : M (option ((iop * mword 5 * mword 5 * mword 12)))
                        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                        end)
                        : M (option ((iop * mword 5 * mword 5 * mword 12)))
                    end)
                    : M (option ((iop * mword 5 * mword 5 * mword 12)))
                | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
                end)
                : M (option ((iop * mword 5 * mword 5 * mword 12)))
            end)
            : M (option ((iop * mword 5 * mword 5 * mword 12)))
        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12)))
        end)
        : M (option ((iop * mword 5 * mword 5 * mword 12)))
    end)
    : M (option ((iop * mword 5 * mword 5 * mword 12))).

Definition _s1726_ (_s1727_ : string) 
: M (option ((bop * mword 5 * mword 5 * mword 13))) :=
   
   (match _s1727_ with
    | _s1728_ =>
       (btype_mnemonic_matches_prefix _s1728_) >>= fun w__0 : option ((bop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1729_ _)) =>
           (match (string_drop _s1728_ _s1729_) with
            | _s1730_ =>
               (spc_matches_prefix _s1730_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1731_ _)) =>
                   (match (string_drop _s1730_ _s1731_) with
                    | _s1732_ =>
                       (reg_name_matches_prefix _s1732_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rs1, existT _ _s1733_ _)) =>
                           (match (string_drop _s1732_ _s1733_) with
                            | _s1734_ =>
                               (sep_matches_prefix _s1734_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s1735_ _)) =>
                                   (match (string_drop _s1734_ _s1735_) with
                                    | _s1736_ =>
                                       (reg_name_matches_prefix _s1736_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs2, existT _ _s1737_ _)) =>
                                           (match (string_drop _s1736_ _s1737_) with
                                            | _s1738_ =>
                                               (sep_matches_prefix _s1738_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s1739_ _)) =>
                                                            match (string_drop _s1738_ _s1739_) with
                                                            | _s1740_ =>
                                                               match (hex_bits_13_matches_prefix
                                                                        _s1740_) with
                                                               | Some ((imm, existT _ _s1741_ _)) =>
                                                                  let p0_ :=
                                                                    string_drop _s1740_ _s1741_ in
                                                                  if ((generic_eq p0_ "")) then
                                                                    Some
                                                                      ((op, rs1, rs2, imm))
                                                                  else None
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((bop * mword 5 * mword 5 * mword 13)))
                                            end)
                                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                        | _ =>
                                           returnm (None
                                            : option ((bop * mword 5 * mword 5 * mword 13)))
                                        end)
                                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                    end)
                                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                                | _ =>
                                   returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                                end)
                                : M (option ((bop * mword 5 * mword 5 * mword 13)))
                            end)
                            : M (option ((bop * mword 5 * mword 5 * mword 13)))
                        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                        end)
                        : M (option ((bop * mword 5 * mword 5 * mword 13)))
                    end)
                    : M (option ((bop * mword 5 * mword 5 * mword 13)))
                | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
                end)
                : M (option ((bop * mword 5 * mword 5 * mword 13)))
            end)
            : M (option ((bop * mword 5 * mword 5 * mword 13)))
        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13)))
        end)
        : M (option ((bop * mword 5 * mword 5 * mword 13)))
    end)
    : M (option ((bop * mword 5 * mword 5 * mword 13))).

Definition _s1710_ (_s1711_ : string) 
: M (option ((mword 5 * mword 5 * mword 12))) :=
   
   let _s1712_ := _s1711_ in
   (if ((string_startswith _s1712_ "jalr")) then
      (match (string_drop _s1712_ (projT1 (string_length "jalr"))) with
       | _s1713_ =>
          (spc_matches_prefix _s1713_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1714_ _)) =>
              (match (string_drop _s1713_ _s1714_) with
               | _s1715_ =>
                  (reg_name_matches_prefix _s1715_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1716_ _)) =>
                      (match (string_drop _s1715_ _s1716_) with
                       | _s1717_ =>
                          (sep_matches_prefix _s1717_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s1718_ _)) =>
                              (match (string_drop _s1717_ _s1718_) with
                               | _s1719_ =>
                                  (reg_name_matches_prefix _s1719_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s1720_ _)) =>
                                      (match (string_drop _s1719_ _s1720_) with
                                       | _s1721_ =>
                                          (sep_matches_prefix _s1721_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s1722_ _)) =>
                                                       match (string_drop _s1721_ _s1722_) with
                                                       | _s1723_ =>
                                                          match (hex_bits_12_matches_prefix _s1723_) with
                                                          | Some ((imm, existT _ _s1724_ _)) =>
                                                             let p0_ := string_drop _s1723_ _s1724_ in
                                                             if ((generic_eq p0_ "")) then
                                                               Some
                                                                 ((rd, rs1, imm))
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12)))
                                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12))))
    : M (option ((mword 5 * mword 5 * mword 12))).

Definition _s1698_ (_s1699_ : string) 
: M (option ((mword 5 * mword 21))) :=
   
   let _s1700_ := _s1699_ in
   (if ((string_startswith _s1700_ "jal")) then
      (match (string_drop _s1700_ (projT1 (string_length "jal"))) with
       | _s1701_ =>
          (spc_matches_prefix _s1701_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s1702_ _)) =>
              (match (string_drop _s1701_ _s1702_) with
               | _s1703_ =>
                  (reg_name_matches_prefix _s1703_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s1704_ _)) =>
                      (match (string_drop _s1703_ _s1704_) with
                       | _s1705_ =>
                          (sep_matches_prefix _s1705_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s1706_ _)) =>
                                       match (string_drop _s1705_ _s1706_) with
                                       | _s1707_ =>
                                          match (hex_bits_21_matches_prefix _s1707_) with
                                          | Some ((imm, existT _ _s1708_ _)) =>
                                             let p0_ := string_drop _s1707_ _s1708_ in
                                             if ((generic_eq p0_ "")) then Some ((rd, imm))
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 21)))
                       end)
                       : M (option ((mword 5 * mword 21)))
                   | _ => returnm (None  : option ((mword 5 * mword 21)))
                   end)
                   : M (option ((mword 5 * mword 21)))
               end)
               : M (option ((mword 5 * mword 21)))
           | _ => returnm (None  : option ((mword 5 * mword 21)))
           end)
           : M (option ((mword 5 * mword 21)))
       end)
       : M (option ((mword 5 * mword 21)))
    else returnm (None  : option ((mword 5 * mword 21))))
    : M (option ((mword 5 * mword 21))).

Definition _s1685_ (_s1686_ : string) 
: M (option ((uop * mword 5 * mword 20))) :=
   
   (match _s1686_ with
    | _s1687_ =>
       (utype_mnemonic_matches_prefix _s1687_) >>= fun w__0 : option ((uop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s1688_ _)) =>
           (match (string_drop _s1687_ _s1688_) with
            | _s1689_ =>
               (spc_matches_prefix _s1689_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s1690_ _)) =>
                   (match (string_drop _s1689_ _s1690_) with
                    | _s1691_ =>
                       (reg_name_matches_prefix _s1691_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s1692_ _)) =>
                           (match (string_drop _s1691_ _s1692_) with
                            | _s1693_ =>
                               (sep_matches_prefix _s1693_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some ((tt, existT _ _s1694_ _)) =>
                                            match (string_drop _s1693_ _s1694_) with
                                            | _s1695_ =>
                                               match (hex_bits_20_matches_prefix _s1695_) with
                                               | Some ((imm, existT _ _s1696_ _)) =>
                                                  let p0_ := string_drop _s1695_ _s1696_ in
                                                  if ((generic_eq p0_ "")) then Some ((op, rd, imm))
                                                  else None
                                               | _ => None
                                               end
                                            end
                                         | _ => None
                                         end)
                                : option ((uop * mword 5 * mword 20)))
                            end)
                            : M (option ((uop * mword 5 * mword 20)))
                        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                        end)
                        : M (option ((uop * mword 5 * mword 20)))
                    end)
                    : M (option ((uop * mword 5 * mword 20)))
                | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
                end)
                : M (option ((uop * mword 5 * mword 20)))
            end)
            : M (option ((uop * mword 5 * mword 20)))
        | _ => returnm (None  : option ((uop * mword 5 * mword 20)))
        end)
        : M (option ((uop * mword 5 * mword 20)))
    end)
    : M (option ((uop * mword 5 * mword 20))).

Definition assembly_backwards_matches (arg_ : string) 
: M (bool) :=
   
   let _s1697_ := arg_ in
   (_s1685_ _s1697_) >>= fun w__0 : option ((uop * mword 5 * mword 20)) =>
   (if ((match w__0 with | Some ((op, rd, imm)) => true | _ => false end)) then
      (_s1685_ _s1697_) >>= fun w__1 : option ((uop * mword 5 * mword 20)) =>
      (match w__1 with
       | Some ((op, rd, imm)) =>
          returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
       | _ => exit tt  : M (bool)
       end)
       : M (bool)
    else
      (_s1698_ _s1697_) >>= fun w__4 : option ((mword 5 * mword 21)) =>
      (if ((match w__4 with | Some ((rd, imm)) => true | _ => false end)) then
         (_s1698_ _s1697_) >>= fun w__5 : option ((mword 5 * mword 21)) =>
         (match w__5 with
          | Some ((rd, imm)) =>
             returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
          | _ => exit tt  : M (bool)
          end)
          : M (bool)
       else
         (_s1710_ _s1697_) >>= fun w__8 : option ((mword 5 * mword 5 * mword 12)) =>
         (if ((match w__8 with | Some ((rd, rs1, imm)) => true | _ => false end)) then
            (_s1710_ _s1697_) >>= fun w__9 : option ((mword 5 * mword 5 * mword 12)) =>
            (match w__9 with
             | Some ((rd, rs1, imm)) =>
                returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
             | _ => exit tt  : M (bool)
             end)
             : M (bool)
          else
            (_s1726_ _s1697_) >>= fun w__12 : option ((bop * mword 5 * mword 5 * mword 13)) =>
            (if ((match w__12 with | Some ((op, rs1, rs2, imm)) => true | _ => false end)) then
               (_s1726_ _s1697_) >>= fun w__13 : option ((bop * mword 5 * mword 5 * mword 13)) =>
               (match w__13 with
                | Some ((op, rs1, rs2, imm)) =>
                   returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
                | _ => exit tt  : M (bool)
                end)
                : M (bool)
             else
               (_s1743_ _s1697_) >>= fun w__16 : option ((iop * mword 5 * mword 5 * mword 12)) =>
               (if ((match w__16 with | Some ((op, rd, rs1, imm)) => true | _ => false end)) then
                  (_s1743_ _s1697_) >>= fun w__17 : option ((iop * mword 5 * mword 5 * mword 12)) =>
                  (match w__17 with
                   | Some ((op, rd, rs1, imm)) =>
                      returnm (projT1 (build_ex true  : {_bool : bool & ArithFact (_bool = true)}))
                   | _ => exit tt  : M (bool)
                   end)
                   : M (bool)
                else
                  (_s1760_ _s1697_) >>= fun w__20 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                  (if ((match w__20 with | Some ((op, rd, rs1, shamt)) => true | _ => false end))
                   then
                     (_s1760_ _s1697_) >>= fun w__21 : option ((sop * mword 5 * mword 5 * mword 6)) =>
                     (match w__21 with
                      | Some ((op, rd, rs1, shamt)) =>
                         returnm (projT1
                         (build_ex
                         true
                          : {_bool : bool & ArithFact (_bool = true)}))
                      | _ => exit tt  : M (bool)
                      end)
                      : M (bool)
                   else
                     (_s1777_ _s1697_) >>= fun w__24 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                     (if ((match w__24 with | Some ((op, rd, rs1, rs2)) => true | _ => false end))
                      then
                        (_s1777_ _s1697_) >>= fun w__25 : option ((rop * mword 5 * mword 5 * mword 5)) =>
                        (match w__25 with
                         | Some ((op, rd, rs1, rs2)) =>
                            returnm (projT1
                            (build_ex
                            true
                             : {_bool : bool & ArithFact (_bool = true)}))
                         | _ => exit tt  : M (bool)
                         end)
                         : M (bool)
                      else
                        (_s1794_ _s1697_) >>= fun w__28 : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)) =>
                        (if ((match w__28 with
                              | Some ((size, is_unsigned, aq, rl, rd, imm, rs1)) => true
                              | _ => false
                              end)) then
                           (_s1794_ _s1697_) >>= fun w__29 : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5)) =>
                           (match w__29 with
                            | Some ((size, is_unsigned, aq, rl, rd, imm, rs1)) =>
                               returnm (projT1
                               (build_ex
                               true
                                : {_bool : bool & ArithFact (_bool = true)}))
                            | _ => exit tt  : M (bool)
                            end)
                            : M (bool)
                         else
                           (_s1824_ _s1697_) >>= fun w__32 : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)) =>
                           (if ((match w__32 with
                                 | Some ((size, aq, rl, rs2, imm, rs1)) => true
                                 | _ => false
                                 end)) then
                              (_s1824_ _s1697_) >>= fun w__33 : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5)) =>
                              (match w__33 with
                               | Some ((size, aq, rl, rs2, imm, rs1)) =>
                                  returnm (projT1
                                  (build_ex
                                  true
                                   : {_bool : bool & ArithFact (_bool = true)}))
                               | _ => exit tt  : M (bool)
                               end)
                               : M (bool)
                            else
                              (_s1852_ _s1697_) >>= fun w__36 : option ((mword 5 * mword 5 * mword 12)) =>
                              (if ((match w__36 with
                                    | Some ((rd, rs1, imm)) => Z.eqb 64 64
                                    | _ => false
                                    end)) then
                                 (_s1852_ _s1697_) >>= fun w__37 : option ((mword 5 * mword 5 * mword 12)) =>
                                 (match w__37 with
                                  | Some ((rd, rs1, imm)) =>
                                     returnm (projT1
                                     (build_ex
                                     true
                                      : {_bool : bool & ArithFact (_bool = true)}))
                                  | _ => exit tt  : M (bool)
                                  end)
                                  : M (bool)
                               else
                                 (_s1868_ _s1697_) >>= fun w__40 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                                 (if ((match w__40 with
                                       | Some ((op, rd, rs1, shamt)) => Z.eqb 64 64
                                       | _ => false
                                       end)) then
                                    (_s1868_ _s1697_) >>= fun w__41 : option ((sop * mword 5 * mword 5 * mword 5)) =>
                                    (match w__41 with
                                     | Some ((op, rd, rs1, shamt)) =>
                                        returnm (projT1
                                        (build_ex
                                        true
                                         : {_bool : bool & ArithFact (_bool = true)}))
                                     | _ => exit tt  : M (bool)
                                     end)
                                     : M (bool)
                                  else
                                    (_s1885_ _s1697_) >>= fun w__44 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                                    (if ((match w__44 with
                                          | Some ((op, rd, rs1, rs2)) => Z.eqb 64 64
                                          | _ => false
                                          end)) then
                                       (_s1885_ _s1697_) >>= fun w__45 : option ((ropw * mword 5 * mword 5 * mword 5)) =>
                                       (match w__45 with
                                        | Some ((op, rd, rs1, rs2)) =>
                                           returnm (projT1
                                           (build_ex
                                           true
                                            : {_bool : bool & ArithFact (_bool = true)}))
                                        | _ => exit tt  : M (bool)
                                        end)
                                        : M (bool)
                                     else
                                       (_s1902_ _s1697_) >>= fun w__48 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                       (if ((match w__48 with
                                             | Some ((op, rd, rs1, shamt)) => Z.eqb 64 64
                                             | _ => false
                                             end)) then
                                          (_s1902_ _s1697_) >>= fun w__49 : option ((sopw * mword 5 * mword 5 * mword 5)) =>
                                          (match w__49 with
                                           | Some ((op, rd, rs1, shamt)) =>
                                              returnm (projT1
                                              (build_ex
                                              true
                                               : {_bool : bool & ArithFact (_bool = true)}))
                                           | _ => exit tt  : M (bool)
                                           end)
                                           : M (bool)
                                        else
                                          (_s1919_ _s1697_) >>= fun w__52 : option ((mword 4 * mword 4)) =>
                                          (if ((match w__52 with
                                                | Some ((pred, succ)) => true
                                                | _ => false
                                                end)) then
                                             (_s1919_ _s1697_) >>= fun w__53 : option ((mword 4 * mword 4)) =>
                                             (match w__53 with
                                              | Some ((pred, succ)) =>
                                                 returnm (projT1
                                                 (build_ex
                                                 true
                                                  : {_bool : bool & ArithFact (_bool = true)}))
                                              | _ => exit tt  : M (bool)
                                              end)
                                              : M (bool)
                                           else
                                             (_s1931_ _s1697_) >>= fun w__56 : option ((mword 4 * mword 4)) =>
                                             (if ((match w__56 with
                                                   | Some ((pred, succ)) => true
                                                   | _ => false
                                                   end)) then
                                                (_s1931_ _s1697_) >>= fun w__57 : option ((mword 4 * mword 4)) =>
                                                (match w__57 with
                                                 | Some ((pred, succ)) =>
                                                    returnm (projT1
                                                    (build_ex
                                                    true
                                                     : {_bool : bool & ArithFact (_bool = true)}))
                                                 | _ => exit tt  : M (bool)
                                                 end)
                                                 : M (bool)
                                              else if ((generic_eq _s1697_ "fence.i")) then
                                                returnm (projT1
                                                (build_ex
                                                true
                                                 : {_bool : bool & ArithFact (_bool = true)}))
                                              else if ((generic_eq _s1697_ "ecall")) then
                                                returnm (projT1
                                                (build_ex
                                                true
                                                 : {_bool : bool & ArithFact (_bool = true)}))
                                              else if ((generic_eq _s1697_ "mret")) then
                                                returnm (projT1
                                                (build_ex
                                                true
                                                 : {_bool : bool & ArithFact (_bool = true)}))
                                              else if ((generic_eq _s1697_ "sret")) then
                                                returnm (projT1
                                                (build_ex
                                                true
                                                 : {_bool : bool & ArithFact (_bool = true)}))
                                              else if ((generic_eq _s1697_ "ebreak")) then
                                                returnm (projT1
                                                (build_ex
                                                true
                                                 : {_bool : bool & ArithFact (_bool = true)}))
                                              else if ((generic_eq _s1697_ "wfi")) then
                                                returnm (projT1
                                                (build_ex
                                                true
                                                 : {_bool : bool & ArithFact (_bool = true)}))
                                              else
                                                (_s1943_ _s1697_) >>= fun w__60 : option ((mword 5 * mword 5)) =>
                                                (if ((match w__60 with
                                                      | Some ((rs1, rs2)) => true
                                                      | _ => false
                                                      end)) then
                                                   (_s1943_ _s1697_) >>= fun w__61 : option ((mword 5 * mword 5)) =>
                                                   (match w__61 with
                                                    | Some ((rs1, rs2)) =>
                                                       returnm (projT1
                                                       (build_ex
                                                       true
                                                        : {_bool : bool & ArithFact (_bool = true)}))
                                                    | _ => exit tt  : M (bool)
                                                    end)
                                                    : M (bool)
                                                 else
                                                   (_s1955_ _s1697_) >>= fun w__64 : option ((word_width * bool * bool * mword 5 * mword 5)) =>
                                                   (if ((match w__64 with
                                                         | Some ((size, aq, rl, rd, rs1)) => true
                                                         | _ => false
                                                         end)) then
                                                      (_s1955_ _s1697_) >>= fun w__65 : option ((word_width * bool * bool * mword 5 * mword 5)) =>
                                                      (match w__65 with
                                                       | Some ((size, aq, rl, rd, rs1)) =>
                                                          returnm (projT1
                                                          (build_ex
                                                          true
                                                           : {_bool : bool & ArithFact (_bool = true)}))
                                                       | _ => exit tt  : M (bool)
                                                       end)
                                                       : M (bool)
                                                    else
                                                      (_s1973_ _s1697_) >>= fun w__68 : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                      (if ((match w__68 with
                                                            | Some ((size, aq, rl, rd, rs1, rs2)) =>
                                                               true
                                                            | _ => false
                                                            end)) then
                                                         (_s1973_ _s1697_) >>= fun w__69 : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                         (match w__69 with
                                                          | Some ((size, aq, rl, rd, rs1, rs2)) =>
                                                             returnm (projT1
                                                             (build_ex
                                                             true
                                                              : {_bool : bool & ArithFact (_bool =
                                                               true)}))
                                                          | _ => exit tt  : M (bool)
                                                          end)
                                                          : M (bool)
                                                       else
                                                         (_s1995_ _s1697_) >>= fun w__72 : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                         (if ((match w__72 with
                                                               | Some
                                                                 ((op, width, aq, rl, rd, rs1, rs2)) =>
                                                                  true
                                                               | _ => false
                                                               end)) then
                                                            (_s1995_ _s1697_) >>= fun w__73 : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                            (match w__73 with
                                                             | Some
                                                               ((op, width, aq, rl, rd, rs1, rs2)) =>
                                                                returnm (projT1
                                                                (build_ex
                                                                true
                                                                 : {_bool : bool & ArithFact (_bool =
                                                                  true)}))
                                                             | _ => exit tt  : M (bool)
                                                             end)
                                                             : M (bool)
                                                          else if ((generic_eq _s1697_ "c.nop"))
                                                          then
                                                            returnm (projT1
                                                            (build_ex
                                                            true
                                                             : {_bool : bool & ArithFact (_bool =
                                                              true)}))
                                                          else
                                                            (_s2019_ _s1697_) >>= fun w__76 : option ((mword 3 * mword 8)) =>
                                                            (if ((match w__76 with
                                                                  | Some ((rdc, nzimm)) =>
                                                                     neq_vec nzimm
                                                                       (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]
                                                                         : mword 8)
                                                                  | _ => false
                                                                  end)) then
                                                               (_s2019_ _s1697_) >>= fun w__77 : option ((mword 3 * mword 8)) =>
                                                               (match w__77 with
                                                                | Some ((rdc, nzimm)) =>
                                                                   returnm (projT1
                                                                   (build_ex
                                                                   true
                                                                    : {_bool : bool & ArithFact (_bool =
                                                                     true)}))
                                                                | _ => exit tt  : M (bool)
                                                                end)
                                                                : M (bool)
                                                             else
                                                               (_s2031_ _s1697_) >>= fun w__80 : option ((mword 3 * mword 3 * mword 5)) =>
                                                               (if ((match w__80 with
                                                                     | Some ((rdc, rsc, uimm)) =>
                                                                        true
                                                                     | _ => false
                                                                     end)) then
                                                                  (_s2031_ _s1697_) >>= fun w__81 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                  (match w__81 with
                                                                   | Some ((rdc, rsc, uimm)) =>
                                                                      returnm (projT1
                                                                      (build_ex
                                                                      true
                                                                       : {_bool : bool & ArithFact (_bool =
                                                                        true)}))
                                                                   | _ => exit tt  : M (bool)
                                                                   end)
                                                                   : M (bool)
                                                                else
                                                                  (_s2047_ _s1697_) >>= fun w__84 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                  (if ((match w__84 with
                                                                        | Some ((rdc, rsc, uimm)) =>
                                                                           Z.eqb 64 64
                                                                        | _ => false
                                                                        end)) then
                                                                     (_s2047_ _s1697_) >>= fun w__85 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                     (match w__85 with
                                                                      | Some ((rdc, rsc, uimm)) =>
                                                                         returnm (projT1
                                                                         (build_ex
                                                                         true
                                                                          : {_bool : bool & ArithFact (_bool =
                                                                           true)}))
                                                                      | _ => exit tt  : M (bool)
                                                                      end)
                                                                      : M (bool)
                                                                   else
                                                                     (_s2063_ _s1697_) >>= fun w__88 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                     (if ((match w__88 with
                                                                           | Some
                                                                             ((rsc1, rsc2, uimm)) =>
                                                                              true
                                                                           | _ => false
                                                                           end)) then
                                                                        (_s2063_ _s1697_) >>= fun w__89 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                        (match w__89 with
                                                                         | Some ((rsc1, rsc2, uimm)) =>
                                                                            returnm (projT1
                                                                            (build_ex
                                                                            true
                                                                             : {_bool : bool & ArithFact (_bool =
                                                                              true)}))
                                                                         | _ => exit tt  : M (bool)
                                                                         end)
                                                                         : M (bool)
                                                                      else
                                                                        (_s2079_ _s1697_) >>= fun w__92 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                        (if ((match w__92 with
                                                                              | Some
                                                                                ((rsc1, rsc2, uimm)) =>
                                                                                 Z.eqb 64 64
                                                                              | _ => false
                                                                              end)) then
                                                                           (_s2079_ _s1697_) >>= fun w__93 : option ((mword 3 * mword 3 * mword 5)) =>
                                                                           (match w__93 with
                                                                            | Some
                                                                              ((rsc1, rsc2, uimm)) =>
                                                                               returnm (projT1
                                                                               (build_ex
                                                                               true
                                                                                : {_bool : bool & ArithFact (_bool =
                                                                                 true)}))
                                                                            | _ =>
                                                                               exit tt  : M (bool)
                                                                            end)
                                                                            : M (bool)
                                                                         else
                                                                           (_s2095_ _s1697_) >>= fun w__96 : option ((mword 5 * mword 6)) =>
                                                                           (if ((match w__96 with
                                                                                 | Some ((rsd, nzi)) =>
                                                                                    andb
                                                                                      (neq_vec nzi
                                                                                         (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                           : mword 6))
                                                                                      ((projT1
                                                                                        (neq_int
                                                                                           (projT1
                                                                                            (regidx_to_regno
                                                                                               rsd))
                                                                                           (projT1
                                                                                            (regidx_to_regno
                                                                                               zreg))))
                                                                                       : bool)
                                                                                 | _ => false
                                                                                 end)) then
                                                                              (_s2095_ _s1697_) >>= fun w__97 : option ((mword 5 * mword 6)) =>
                                                                              (match w__97 with
                                                                               | Some ((rsd, nzi)) =>
                                                                                  returnm (projT1
                                                                                  (build_ex
                                                                                  true
                                                                                   : {_bool : bool & ArithFact (_bool =
                                                                                    true)}))
                                                                               | _ =>
                                                                                  exit tt
                                                                                   : M (bool)
                                                                               end)
                                                                               : M (bool)
                                                                            else
                                                                              (_s2107_ _s1697_) >>= fun w__100 : option (mword 11) =>
                                                                              (if ((match w__100 with
                                                                                    | Some (imm) =>
                                                                                       Z.eqb 64 32
                                                                                    | _ => false
                                                                                    end)) then
                                                                                 (_s2107_ _s1697_) >>= fun w__101 : option (mword 11) =>
                                                                                 (match w__101 with
                                                                                  | Some (imm) =>
                                                                                     returnm (projT1
                                                                                     (build_ex
                                                                                     true
                                                                                      : {_bool : bool & ArithFact (_bool =
                                                                                       true)}))
                                                                                  | _ =>
                                                                                     exit tt
                                                                                      : M (bool)
                                                                                  end)
                                                                                  : M (bool)
                                                                               else
                                                                                 (_s2115_ _s1697_) >>= fun w__104 : option ((mword 5 * mword 6)) =>
                                                                                 (if ((match w__104 with
                                                                                       | Some
                                                                                         ((rsd, imm)) =>
                                                                                          Z.eqb 64
                                                                                            64
                                                                                       | _ => false
                                                                                       end)) then
                                                                                    (_s2115_ _s1697_) >>= fun w__105 : option ((mword 5 * mword 6)) =>
                                                                                    (match w__105 with
                                                                                     | Some
                                                                                       ((rsd, imm)) =>
                                                                                        returnm (projT1
                                                                                        (build_ex
                                                                                        true
                                                                                         : {_bool : bool & ArithFact (_bool =
                                                                                          true)}))
                                                                                     | _ =>
                                                                                        exit tt
                                                                                         : M (bool)
                                                                                     end)
                                                                                     : M (bool)
                                                                                  else
                                                                                    (_s2127_ _s1697_) >>= fun w__108 : option ((mword 5 * mword 6)) =>
                                                                                    (if ((match w__108 with
                                                                                          | Some
                                                                                            ((rd, imm)) =>
                                                                                             projT1
                                                                                             (neq_int
                                                                                                (projT1
                                                                                                 (regidx_to_regno
                                                                                                    rd))
                                                                                                (projT1
                                                                                                 (regidx_to_regno
                                                                                                    zreg)))
                                                                                          | _ =>
                                                                                             false
                                                                                          end)) then
                                                                                       (_s2127_
                                                                                          _s1697_) >>= fun w__109 : option ((mword 5 * mword 6)) =>
                                                                                       (match w__109 with
                                                                                        | Some
                                                                                          ((rd, imm)) =>
                                                                                           returnm (projT1
                                                                                           (build_ex
                                                                                           true
                                                                                            : {_bool : bool & ArithFact (_bool =
                                                                                             true)}))
                                                                                        | _ =>
                                                                                           exit tt
                                                                                            : M (bool)
                                                                                        end)
                                                                                        : M (bool)
                                                                                     else
                                                                                       (_s2139_
                                                                                          _s1697_) >>= fun w__112 : option (mword 6) =>
                                                                                       (if ((match w__112 with
                                                                                             | Some
                                                                                               (imm) =>
                                                                                                neq_vec
                                                                                                  imm
                                                                                                  (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                    : mword 6)
                                                                                             | _ =>
                                                                                                false
                                                                                             end))
                                                                                        then
                                                                                          (_s2139_
                                                                                             _s1697_) >>= fun w__113 : option (mword 6) =>
                                                                                          (match w__113 with
                                                                                           | Some
                                                                                             (imm) =>
                                                                                              returnm (projT1
                                                                                              (build_ex
                                                                                              true
                                                                                               : {_bool : bool & ArithFact (_bool =
                                                                                                true)}))
                                                                                           | _ =>
                                                                                              exit tt
                                                                                               : M (bool)
                                                                                           end)
                                                                                           : M (bool)
                                                                                        else
                                                                                          (_s2147_
                                                                                             _s1697_) >>= fun w__116 : option ((mword 5 * mword 6)) =>
                                                                                          (if ((match w__116 with
                                                                                                | Some
                                                                                                  ((rd, imm)) =>
                                                                                                   andb
                                                                                                     (projT1
                                                                                                      (neq_int
                                                                                                         (projT1
                                                                                                          (regidx_to_regno
                                                                                                             rd))
                                                                                                         (projT1
                                                                                                          (regidx_to_regno
                                                                                                             zreg))))
                                                                                                     ((andb
                                                                                                         (projT1
                                                                                                          (neq_int
                                                                                                             (projT1
                                                                                                              (regidx_to_regno
                                                                                                                 rd))
                                                                                                             (projT1
                                                                                                              (regidx_to_regno
                                                                                                                 sp))))
                                                                                                         (neq_vec
                                                                                                            imm
                                                                                                            (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                              : mword 6)))
                                                                                                      : bool)
                                                                                                | _ =>
                                                                                                   false
                                                                                                end))
                                                                                           then
                                                                                             (_s2147_
                                                                                                _s1697_) >>= fun w__117 : option ((mword 5 * mword 6)) =>
                                                                                             (match w__117 with
                                                                                              | Some
                                                                                                ((rd, imm)) =>
                                                                                                 returnm (projT1
                                                                                                 (build_ex
                                                                                                 true
                                                                                                  : {_bool : bool & ArithFact (_bool =
                                                                                                   true)}))
                                                                                              | _ =>
                                                                                                 exit tt
                                                                                                  : M (bool)
                                                                                              end)
                                                                                              : M (bool)
                                                                                           else
                                                                                             (_s2159_
                                                                                                _s1697_) >>= fun w__120 : option ((mword 3 * mword 6)) =>
                                                                                             (if ((match w__120 with
                                                                                                   | Some
                                                                                                     ((rsd, shamt)) =>
                                                                                                      neq_vec
                                                                                                        shamt
                                                                                                        (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                          : mword 6)
                                                                                                   | _ =>
                                                                                                      false
                                                                                                   end))
                                                                                              then
                                                                                                (_s2159_
                                                                                                   _s1697_) >>= fun w__121 : option ((mword 3 * mword 6)) =>
                                                                                                (match w__121 with
                                                                                                 | Some
                                                                                                   ((rsd, shamt)) =>
                                                                                                    returnm (projT1
                                                                                                    (build_ex
                                                                                                    true
                                                                                                     : {_bool : bool & ArithFact (_bool =
                                                                                                      true)}))
                                                                                                 | _ =>
                                                                                                    exit tt
                                                                                                     : M (bool)
                                                                                                 end)
                                                                                                 : M (bool)
                                                                                              else
                                                                                                (_s2171_
                                                                                                   _s1697_) >>= fun w__124 : option ((mword 3 * mword 6)) =>
                                                                                                (if ((match w__124 with
                                                                                                      | Some
                                                                                                        ((rsd, shamt)) =>
                                                                                                         neq_vec
                                                                                                           shamt
                                                                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                             : mword 6)
                                                                                                      | _ =>
                                                                                                         false
                                                                                                      end))
                                                                                                 then
                                                                                                   (_s2171_
                                                                                                      _s1697_) >>= fun w__125 : option ((mword 3 * mword 6)) =>
                                                                                                   (match w__125 with
                                                                                                    | Some
                                                                                                      ((rsd, shamt)) =>
                                                                                                       returnm (projT1
                                                                                                       (build_ex
                                                                                                       true
                                                                                                        : {_bool : bool & ArithFact (_bool =
                                                                                                         true)}))
                                                                                                    | _ =>
                                                                                                       exit tt
                                                                                                        : M (bool)
                                                                                                    end)
                                                                                                    : M (bool)
                                                                                                 else
                                                                                                   (_s2183_
                                                                                                      _s1697_) >>= fun w__128 : option ((mword 3 * mword 6)) =>
                                                                                                   (if
                                                                                                      ((match w__128 with
                                                                                                        | Some
                                                                                                          ((rsd, imm)) =>
                                                                                                           true
                                                                                                        | _ =>
                                                                                                           false
                                                                                                        end))
                                                                                                    then
                                                                                                      (_s2183_
                                                                                                         _s1697_) >>= fun w__129 : option ((mword 3 * mword 6)) =>
                                                                                                      (match w__129 with
                                                                                                       | Some
                                                                                                         ((rsd, imm)) =>
                                                                                                          returnm (projT1
                                                                                                          (build_ex
                                                                                                          true
                                                                                                           : {_bool : bool & ArithFact (_bool =
                                                                                                            true)}))
                                                                                                       | _ =>
                                                                                                          exit tt
                                                                                                           : M (bool)
                                                                                                       end)
                                                                                                       : M (bool)
                                                                                                    else
                                                                                                      (_s2195_
                                                                                                         _s1697_) >>= fun w__132 : option ((mword 3 * mword 3)) =>
                                                                                                      (if
                                                                                                         ((match w__132 with
                                                                                                           | Some
                                                                                                             ((rsd, rs2)) =>
                                                                                                              true
                                                                                                           | _ =>
                                                                                                              false
                                                                                                           end))
                                                                                                       then
                                                                                                         (_s2195_
                                                                                                            _s1697_) >>= fun w__133 : option ((mword 3 * mword 3)) =>
                                                                                                         (match w__133 with
                                                                                                          | Some
                                                                                                            ((rsd, rs2)) =>
                                                                                                             returnm (projT1
                                                                                                             (build_ex
                                                                                                             true
                                                                                                              : {_bool : bool & ArithFact (_bool =
                                                                                                               true)}))
                                                                                                          | _ =>
                                                                                                             exit tt
                                                                                                              : M (bool)
                                                                                                          end)
                                                                                                          : M (bool)
                                                                                                       else
                                                                                                         (_s2207_
                                                                                                            _s1697_) >>= fun w__136 : option ((mword 3 * mword 3)) =>
                                                                                                         (if
                                                                                                            ((match w__136 with
                                                                                                              | Some
                                                                                                                ((rsd, rs2)) =>
                                                                                                                 true
                                                                                                              | _ =>
                                                                                                                 false
                                                                                                              end))
                                                                                                          then
                                                                                                            (_s2207_
                                                                                                               _s1697_) >>= fun w__137 : option ((mword 3 * mword 3)) =>
                                                                                                            (match w__137 with
                                                                                                             | Some
                                                                                                               ((rsd, rs2)) =>
                                                                                                                returnm (projT1
                                                                                                                (build_ex
                                                                                                                true
                                                                                                                 : {_bool : bool & ArithFact (_bool =
                                                                                                                  true)}))
                                                                                                             | _ =>
                                                                                                                exit tt
                                                                                                                 : M (bool)
                                                                                                             end)
                                                                                                             : M (bool)
                                                                                                          else
                                                                                                            (_s2219_
                                                                                                               _s1697_) >>= fun w__140 : option ((mword 3 * mword 3)) =>
                                                                                                            (if
                                                                                                               ((match w__140 with
                                                                                                                 | Some
                                                                                                                   ((rsd, rs2)) =>
                                                                                                                    true
                                                                                                                 | _ =>
                                                                                                                    false
                                                                                                                 end))
                                                                                                             then
                                                                                                               (_s2219_
                                                                                                                  _s1697_) >>= fun w__141 : option ((mword 3 * mword 3)) =>
                                                                                                               (match w__141 with
                                                                                                                | Some
                                                                                                                  ((rsd, rs2)) =>
                                                                                                                   returnm (projT1
                                                                                                                   (build_ex
                                                                                                                   true
                                                                                                                    : {_bool : bool & ArithFact (_bool =
                                                                                                                     true)}))
                                                                                                                | _ =>
                                                                                                                   exit tt
                                                                                                                    : M (bool)
                                                                                                                end)
                                                                                                                : M (bool)
                                                                                                             else
                                                                                                               (_s2231_
                                                                                                                  _s1697_) >>= fun w__144 : option ((mword 3 * mword 3)) =>
                                                                                                               (if
                                                                                                                  ((match w__144 with
                                                                                                                    | Some
                                                                                                                      ((rsd, rs2)) =>
                                                                                                                       true
                                                                                                                    | _ =>
                                                                                                                       false
                                                                                                                    end))
                                                                                                                then
                                                                                                                  (_s2231_
                                                                                                                     _s1697_) >>= fun w__145 : option ((mword 3 * mword 3)) =>
                                                                                                                  (match w__145 with
                                                                                                                   | Some
                                                                                                                     ((rsd, rs2)) =>
                                                                                                                      returnm (projT1
                                                                                                                      (build_ex
                                                                                                                      true
                                                                                                                       : {_bool : bool & ArithFact (_bool =
                                                                                                                        true)}))
                                                                                                                   | _ =>
                                                                                                                      exit tt
                                                                                                                       : M (bool)
                                                                                                                   end)
                                                                                                                   : M (bool)
                                                                                                                else
                                                                                                                  (_s2243_
                                                                                                                     _s1697_) >>= fun w__148 : option ((mword 3 * mword 3)) =>
                                                                                                                  (if
                                                                                                                     ((match w__148 with
                                                                                                                       | Some
                                                                                                                         ((rsd, rs2)) =>
                                                                                                                          Z.eqb
                                                                                                                            64
                                                                                                                            64
                                                                                                                       | _ =>
                                                                                                                          false
                                                                                                                       end))
                                                                                                                   then
                                                                                                                     (_s2243_
                                                                                                                        _s1697_) >>= fun w__149 : option ((mword 3 * mword 3)) =>
                                                                                                                     (match w__149 with
                                                                                                                      | Some
                                                                                                                        ((rsd, rs2)) =>
                                                                                                                         returnm (projT1
                                                                                                                         (build_ex
                                                                                                                         true
                                                                                                                          : {_bool : bool & ArithFact (_bool =
                                                                                                                           true)}))
                                                                                                                      | _ =>
                                                                                                                         exit tt
                                                                                                                          : M (bool)
                                                                                                                      end)
                                                                                                                      : M (bool)
                                                                                                                   else
                                                                                                                     (_s2255_
                                                                                                                        _s1697_) >>= fun w__152 : option ((mword 3 * mword 3)) =>
                                                                                                                     (if
                                                                                                                        ((match w__152 with
                                                                                                                          | Some
                                                                                                                            ((rsd, rs2)) =>
                                                                                                                             Z.eqb
                                                                                                                               64
                                                                                                                               64
                                                                                                                          | _ =>
                                                                                                                             false
                                                                                                                          end))
                                                                                                                      then
                                                                                                                        (_s2255_
                                                                                                                           _s1697_) >>= fun w__153 : option ((mword 3 * mword 3)) =>
                                                                                                                        (match w__153 with
                                                                                                                         | Some
                                                                                                                           ((rsd, rs2)) =>
                                                                                                                            returnm (projT1
                                                                                                                            (build_ex
                                                                                                                            true
                                                                                                                             : {_bool : bool & ArithFact (_bool =
                                                                                                                              true)}))
                                                                                                                         | _ =>
                                                                                                                            exit tt
                                                                                                                             : M (bool)
                                                                                                                         end)
                                                                                                                         : M (bool)
                                                                                                                      else
                                                                                                                        (_s2267_
                                                                                                                           _s1697_) >>= fun w__156 : option (mword 11) =>
                                                                                                                        (if
                                                                                                                           ((match w__156 with
                                                                                                                             | Some
                                                                                                                               (imm) =>
                                                                                                                                true
                                                                                                                             | _ =>
                                                                                                                                false
                                                                                                                             end))
                                                                                                                         then
                                                                                                                           (_s2267_
                                                                                                                              _s1697_) >>= fun w__157 : option (mword 11) =>
                                                                                                                           (match w__157 with
                                                                                                                            | Some
                                                                                                                              (imm) =>
                                                                                                                               returnm (projT1
                                                                                                                               (build_ex
                                                                                                                               true
                                                                                                                                : {_bool : bool & ArithFact (_bool =
                                                                                                                                 true)}))
                                                                                                                            | _ =>
                                                                                                                               exit tt
                                                                                                                                : M (bool)
                                                                                                                            end)
                                                                                                                            : M (bool)
                                                                                                                         else
                                                                                                                           (_s2275_
                                                                                                                              _s1697_) >>= fun w__160 : option ((mword 3 * mword 8)) =>
                                                                                                                           (if
                                                                                                                              ((match w__160 with
                                                                                                                                | Some
                                                                                                                                  ((rs, imm)) =>
                                                                                                                                   true
                                                                                                                                | _ =>
                                                                                                                                   false
                                                                                                                                end))
                                                                                                                            then
                                                                                                                              (_s2275_
                                                                                                                                 _s1697_) >>= fun w__161 : option ((mword 3 * mword 8)) =>
                                                                                                                              (match w__161 with
                                                                                                                               | Some
                                                                                                                                 ((rs, imm)) =>
                                                                                                                                  returnm (projT1
                                                                                                                                  (build_ex
                                                                                                                                  true
                                                                                                                                   : {_bool : bool & ArithFact (_bool =
                                                                                                                                    true)}))
                                                                                                                               | _ =>
                                                                                                                                  exit tt
                                                                                                                                   : M (bool)
                                                                                                                               end)
                                                                                                                               : M (bool)
                                                                                                                            else
                                                                                                                              (_s2287_
                                                                                                                                 _s1697_) >>= fun w__164 : option ((mword 3 * mword 8)) =>
                                                                                                                              (if
                                                                                                                                 ((match w__164 with
                                                                                                                                   | Some
                                                                                                                                     ((rs, imm)) =>
                                                                                                                                      true
                                                                                                                                   | _ =>
                                                                                                                                      false
                                                                                                                                   end))
                                                                                                                               then
                                                                                                                                 (_s2287_
                                                                                                                                    _s1697_) >>= fun w__165 : option ((mword 3 * mword 8)) =>
                                                                                                                                 (match w__165 with
                                                                                                                                  | Some
                                                                                                                                    ((rs, imm)) =>
                                                                                                                                     returnm (projT1
                                                                                                                                     (build_ex
                                                                                                                                     true
                                                                                                                                      : {_bool : bool & ArithFact (_bool =
                                                                                                                                       true)}))
                                                                                                                                  | _ =>
                                                                                                                                     exit tt
                                                                                                                                      : M (bool)
                                                                                                                                  end)
                                                                                                                                  : M (bool)
                                                                                                                               else
                                                                                                                                 (_s2299_
                                                                                                                                    _s1697_) >>= fun w__168 : option ((mword 5 * mword 6)) =>
                                                                                                                                 (if
                                                                                                                                    ((match w__168 with
                                                                                                                                      | Some
                                                                                                                                        ((rsd, shamt)) =>
                                                                                                                                         andb
                                                                                                                                           (neq_vec
                                                                                                                                              shamt
                                                                                                                                              (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                                                                : mword 6))
                                                                                                                                           ((projT1
                                                                                                                                             (neq_int
                                                                                                                                                (projT1
                                                                                                                                                 (regidx_to_regno
                                                                                                                                                    rsd))
                                                                                                                                                (projT1
                                                                                                                                                 (regidx_to_regno
                                                                                                                                                    zreg))))
                                                                                                                                            : bool)
                                                                                                                                      | _ =>
                                                                                                                                         false
                                                                                                                                      end))
                                                                                                                                  then
                                                                                                                                    (_s2299_
                                                                                                                                       _s1697_) >>= fun w__169 : option ((mword 5 * mword 6)) =>
                                                                                                                                    (match w__169 with
                                                                                                                                     | Some
                                                                                                                                       ((rsd, shamt)) =>
                                                                                                                                        returnm (projT1
                                                                                                                                        (build_ex
                                                                                                                                        true
                                                                                                                                         : {_bool : bool & ArithFact (_bool =
                                                                                                                                          true)}))
                                                                                                                                     | _ =>
                                                                                                                                        exit tt
                                                                                                                                         : M (bool)
                                                                                                                                     end)
                                                                                                                                     : M (bool)
                                                                                                                                  else
                                                                                                                                    (_s2311_
                                                                                                                                       _s1697_) >>= fun w__172 : option ((mword 5 * mword 6)) =>
                                                                                                                                    (if
                                                                                                                                       ((match w__172 with
                                                                                                                                         | Some
                                                                                                                                           ((rd, uimm)) =>
                                                                                                                                            projT1
                                                                                                                                            (neq_int
                                                                                                                                               (projT1
                                                                                                                                                (regidx_to_regno
                                                                                                                                                   rd))
                                                                                                                                               (projT1
                                                                                                                                                (regidx_to_regno
                                                                                                                                                   zreg)))
                                                                                                                                         | _ =>
                                                                                                                                            false
                                                                                                                                         end))
                                                                                                                                     then
                                                                                                                                       (_s2311_
                                                                                                                                          _s1697_) >>= fun w__173 : option ((mword 5 * mword 6)) =>
                                                                                                                                       (match w__173 with
                                                                                                                                        | Some
                                                                                                                                          ((rd, uimm)) =>
                                                                                                                                           returnm (projT1
                                                                                                                                           (build_ex
                                                                                                                                           true
                                                                                                                                            : {_bool : bool & ArithFact (_bool =
                                                                                                                                             true)}))
                                                                                                                                        | _ =>
                                                                                                                                           exit tt
                                                                                                                                            : M (bool)
                                                                                                                                        end)
                                                                                                                                        : M (bool)
                                                                                                                                     else
                                                                                                                                       (_s2323_
                                                                                                                                          _s1697_) >>= fun w__176 : option ((mword 5 * mword 6)) =>
                                                                                                                                       (if
                                                                                                                                          ((match w__176 with
                                                                                                                                            | Some
                                                                                                                                              ((rd, uimm)) =>
                                                                                                                                               andb
                                                                                                                                                 (projT1
                                                                                                                                                  (neq_int
                                                                                                                                                     (projT1
                                                                                                                                                      (regidx_to_regno
                                                                                                                                                         rd))
                                                                                                                                                     (projT1
                                                                                                                                                      (regidx_to_regno
                                                                                                                                                         zreg))))
                                                                                                                                                 (Z.eqb
                                                                                                                                                    64
                                                                                                                                                    64)
                                                                                                                                            | _ =>
                                                                                                                                               false
                                                                                                                                            end))
                                                                                                                                        then
                                                                                                                                          (_s2323_
                                                                                                                                             _s1697_) >>= fun w__177 : option ((mword 5 * mword 6)) =>
                                                                                                                                          (match w__177 with
                                                                                                                                           | Some
                                                                                                                                             ((rd, uimm)) =>
                                                                                                                                              returnm (projT1
                                                                                                                                              (build_ex
                                                                                                                                              true
                                                                                                                                               : {_bool : bool & ArithFact (_bool =
                                                                                                                                                true)}))
                                                                                                                                           | _ =>
                                                                                                                                              exit tt
                                                                                                                                               : M (bool)
                                                                                                                                           end)
                                                                                                                                           : M (bool)
                                                                                                                                        else
                                                                                                                                          (_s2335_
                                                                                                                                             _s1697_) >>= fun w__180 : option ((mword 5 * mword 6)) =>
                                                                                                                                          (if
                                                                                                                                             ((match w__180 with
                                                                                                                                               | Some
                                                                                                                                                 ((rd, uimm)) =>
                                                                                                                                                  true
                                                                                                                                               | _ =>
                                                                                                                                                  false
                                                                                                                                               end))
                                                                                                                                           then
                                                                                                                                             (_s2335_
                                                                                                                                                _s1697_) >>= fun w__181 : option ((mword 5 * mword 6)) =>
                                                                                                                                             (match w__181 with
                                                                                                                                              | Some
                                                                                                                                                ((rd, uimm)) =>
                                                                                                                                                 returnm (projT1
                                                                                                                                                 (build_ex
                                                                                                                                                 true
                                                                                                                                                  : {_bool : bool & ArithFact (_bool =
                                                                                                                                                   true)}))
                                                                                                                                              | _ =>
                                                                                                                                                 exit tt
                                                                                                                                                  : M (bool)
                                                                                                                                              end)
                                                                                                                                              : M (bool)
                                                                                                                                           else
                                                                                                                                             (_s2347_
                                                                                                                                                _s1697_) >>= fun w__184 : option ((mword 5 * mword 6)) =>
                                                                                                                                             (if
                                                                                                                                                ((match w__184 with
                                                                                                                                                  | Some
                                                                                                                                                    ((rs2, uimm)) =>
                                                                                                                                                     Z.eqb
                                                                                                                                                       64
                                                                                                                                                       64
                                                                                                                                                  | _ =>
                                                                                                                                                     false
                                                                                                                                                  end))
                                                                                                                                              then
                                                                                                                                                (_s2347_
                                                                                                                                                   _s1697_) >>= fun w__185 : option ((mword 5 * mword 6)) =>
                                                                                                                                                (match w__185 with
                                                                                                                                                 | Some
                                                                                                                                                   ((rs2, uimm)) =>
                                                                                                                                                    returnm (projT1
                                                                                                                                                    (build_ex
                                                                                                                                                    true
                                                                                                                                                     : {_bool : bool & ArithFact (_bool =
                                                                                                                                                      true)}))
                                                                                                                                                 | _ =>
                                                                                                                                                    exit tt
                                                                                                                                                     : M (bool)
                                                                                                                                                 end)
                                                                                                                                                 : M (bool)
                                                                                                                                              else
                                                                                                                                                (_s2359_
                                                                                                                                                   _s1697_) >>= fun w__188 : option (mword 5) =>
                                                                                                                                                (if
                                                                                                                                                   ((match w__188 with
                                                                                                                                                     | Some
                                                                                                                                                       (rs1) =>
                                                                                                                                                        projT1
                                                                                                                                                        (neq_int
                                                                                                                                                           (projT1
                                                                                                                                                            (regidx_to_regno
                                                                                                                                                               rs1))
                                                                                                                                                           (projT1
                                                                                                                                                            (regidx_to_regno
                                                                                                                                                               zreg)))
                                                                                                                                                     | _ =>
                                                                                                                                                        false
                                                                                                                                                     end))
                                                                                                                                                 then
                                                                                                                                                   (_s2359_
                                                                                                                                                      _s1697_) >>= fun w__189 : option (mword 5) =>
                                                                                                                                                   (match w__189 with
                                                                                                                                                    | Some
                                                                                                                                                      (rs1) =>
                                                                                                                                                       returnm (projT1
                                                                                                                                                       (build_ex
                                                                                                                                                       true
                                                                                                                                                        : {_bool : bool & ArithFact (_bool =
                                                                                                                                                         true)}))
                                                                                                                                                    | _ =>
                                                                                                                                                       exit tt
                                                                                                                                                        : M (bool)
                                                                                                                                                    end)
                                                                                                                                                    : M (bool)
                                                                                                                                                 else
                                                                                                                                                   (_s2367_
                                                                                                                                                      _s1697_) >>= fun w__192 : option (mword 5) =>
                                                                                                                                                   (if
                                                                                                                                                      ((match w__192 with
                                                                                                                                                        | Some
                                                                                                                                                          (rs1) =>
                                                                                                                                                           projT1
                                                                                                                                                           (neq_int
                                                                                                                                                              (projT1
                                                                                                                                                               (regidx_to_regno
                                                                                                                                                                  rs1))
                                                                                                                                                              (projT1
                                                                                                                                                               (regidx_to_regno
                                                                                                                                                                  zreg)))
                                                                                                                                                        | _ =>
                                                                                                                                                           false
                                                                                                                                                        end))
                                                                                                                                                    then
                                                                                                                                                      (_s2367_
                                                                                                                                                         _s1697_) >>= fun w__193 : option (mword 5) =>
                                                                                                                                                      (match w__193 with
                                                                                                                                                       | Some
                                                                                                                                                         (rs1) =>
                                                                                                                                                          returnm (projT1
                                                                                                                                                          (build_ex
                                                                                                                                                          true
                                                                                                                                                           : {_bool : bool & ArithFact (_bool =
                                                                                                                                                            true)}))
                                                                                                                                                       | _ =>
                                                                                                                                                          exit tt
                                                                                                                                                           : M (bool)
                                                                                                                                                       end)
                                                                                                                                                       : M (bool)
                                                                                                                                                    else
                                                                                                                                                      (_s2375_
                                                                                                                                                         _s1697_) >>= fun w__196 : option ((mword 5 * mword 5)) =>
                                                                                                                                                      (if
                                                                                                                                                         ((match w__196 with
                                                                                                                                                           | Some
                                                                                                                                                             ((rd, rs2)) =>
                                                                                                                                                              andb
                                                                                                                                                                (projT1
                                                                                                                                                                 (neq_int
                                                                                                                                                                    (projT1
                                                                                                                                                                     (regidx_to_regno
                                                                                                                                                                        rd))
                                                                                                                                                                    (projT1
                                                                                                                                                                     (regidx_to_regno
                                                                                                                                                                        zreg))))
                                                                                                                                                                ((projT1
                                                                                                                                                                  (neq_int
                                                                                                                                                                     (projT1
                                                                                                                                                                      (regidx_to_regno
                                                                                                                                                                         rs2))
                                                                                                                                                                     (projT1
                                                                                                                                                                      (regidx_to_regno
                                                                                                                                                                         zreg))))
                                                                                                                                                                 : bool)
                                                                                                                                                           | _ =>
                                                                                                                                                              false
                                                                                                                                                           end))
                                                                                                                                                       then
                                                                                                                                                         (_s2375_
                                                                                                                                                            _s1697_) >>= fun w__197 : option ((mword 5 * mword 5)) =>
                                                                                                                                                         (match w__197 with
                                                                                                                                                          | Some
                                                                                                                                                            ((rd, rs2)) =>
                                                                                                                                                             returnm (projT1
                                                                                                                                                             (build_ex
                                                                                                                                                             true
                                                                                                                                                              : {_bool : bool & ArithFact (_bool =
                                                                                                                                                               true)}))
                                                                                                                                                          | _ =>
                                                                                                                                                             exit tt
                                                                                                                                                              : M (bool)
                                                                                                                                                          end)
                                                                                                                                                          : M (bool)
                                                                                                                                                       else if
                                                                                                                                                         ((generic_eq
                                                                                                                                                             _s1697_
                                                                                                                                                             "c.ebreak"))
                                                                                                                                                       then
                                                                                                                                                         returnm (projT1
                                                                                                                                                         (build_ex
                                                                                                                                                         true
                                                                                                                                                          : {_bool : bool & ArithFact (_bool =
                                                                                                                                                           true)}))
                                                                                                                                                       else
                                                                                                                                                         (_s2387_
                                                                                                                                                            _s1697_) >>= fun w__200 : option ((mword 5 * mword 5)) =>
                                                                                                                                                         (if
                                                                                                                                                            ((match w__200 with
                                                                                                                                                              | Some
                                                                                                                                                                ((rsd, rs2)) =>
                                                                                                                                                                 andb
                                                                                                                                                                   (projT1
                                                                                                                                                                    (neq_int
                                                                                                                                                                       (projT1
                                                                                                                                                                        (regidx_to_regno
                                                                                                                                                                           rsd))
                                                                                                                                                                       (projT1
                                                                                                                                                                        (regidx_to_regno
                                                                                                                                                                           zreg))))
                                                                                                                                                                   ((projT1
                                                                                                                                                                     (neq_int
                                                                                                                                                                        (projT1
                                                                                                                                                                         (regidx_to_regno
                                                                                                                                                                            rs2))
                                                                                                                                                                        (projT1
                                                                                                                                                                         (regidx_to_regno
                                                                                                                                                                            zreg))))
                                                                                                                                                                    : bool)
                                                                                                                                                              | _ =>
                                                                                                                                                                 false
                                                                                                                                                              end))
                                                                                                                                                          then
                                                                                                                                                            (_s2387_
                                                                                                                                                               _s1697_) >>= fun w__201 : option ((mword 5 * mword 5)) =>
                                                                                                                                                            (match w__201 with
                                                                                                                                                             | Some
                                                                                                                                                               ((rsd, rs2)) =>
                                                                                                                                                                returnm (projT1
                                                                                                                                                                (build_ex
                                                                                                                                                                true
                                                                                                                                                                 : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                  true)}))
                                                                                                                                                             | _ =>
                                                                                                                                                                exit tt
                                                                                                                                                                 : M (bool)
                                                                                                                                                             end)
                                                                                                                                                             : M (bool)
                                                                                                                                                          else
                                                                                                                                                            (_s2399_
                                                                                                                                                               _s1697_) >>= fun w__204 : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                            (if
                                                                                                                                                               ((match w__204 with
                                                                                                                                                                 | Some
                                                                                                                                                                   ((high, signed1, signed2, rd, rs1, rs2)) =>
                                                                                                                                                                    true
                                                                                                                                                                 | _ =>
                                                                                                                                                                    false
                                                                                                                                                                 end))
                                                                                                                                                             then
                                                                                                                                                               (_s2399_
                                                                                                                                                                  _s1697_) >>= fun w__205 : option ((bool * bool * bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                               (match w__205 with
                                                                                                                                                                | Some
                                                                                                                                                                  ((high, signed1, signed2, rd, rs1, rs2)) =>
                                                                                                                                                                   returnm (projT1
                                                                                                                                                                   (build_ex
                                                                                                                                                                   true
                                                                                                                                                                    : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                     true)}))
                                                                                                                                                                | _ =>
                                                                                                                                                                   exit tt
                                                                                                                                                                    : M (bool)
                                                                                                                                                                end)
                                                                                                                                                                : M (bool)
                                                                                                                                                             else
                                                                                                                                                               (_s2416_
                                                                                                                                                                  _s1697_) >>= fun w__208 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                               (if
                                                                                                                                                                  ((match w__208 with
                                                                                                                                                                    | Some
                                                                                                                                                                      ((s, rd, rs1, rs2)) =>
                                                                                                                                                                       true
                                                                                                                                                                    | _ =>
                                                                                                                                                                       false
                                                                                                                                                                    end))
                                                                                                                                                                then
                                                                                                                                                                  (_s2416_
                                                                                                                                                                     _s1697_) >>= fun w__209 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                  (match w__209 with
                                                                                                                                                                   | Some
                                                                                                                                                                     ((s, rd, rs1, rs2)) =>
                                                                                                                                                                      returnm (projT1
                                                                                                                                                                      (build_ex
                                                                                                                                                                      true
                                                                                                                                                                       : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                        true)}))
                                                                                                                                                                   | _ =>
                                                                                                                                                                      exit tt
                                                                                                                                                                       : M (bool)
                                                                                                                                                                   end)
                                                                                                                                                                   : M (bool)
                                                                                                                                                                else
                                                                                                                                                                  (_s2434_
                                                                                                                                                                     _s1697_) >>= fun w__212 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                  (if
                                                                                                                                                                     ((match w__212 with
                                                                                                                                                                       | Some
                                                                                                                                                                         ((s, rd, rs1, rs2)) =>
                                                                                                                                                                          true
                                                                                                                                                                       | _ =>
                                                                                                                                                                          false
                                                                                                                                                                       end))
                                                                                                                                                                   then
                                                                                                                                                                     (_s2434_
                                                                                                                                                                        _s1697_) >>= fun w__213 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                     (match w__213 with
                                                                                                                                                                      | Some
                                                                                                                                                                        ((s, rd, rs1, rs2)) =>
                                                                                                                                                                         returnm (projT1
                                                                                                                                                                         (build_ex
                                                                                                                                                                         true
                                                                                                                                                                          : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                           true)}))
                                                                                                                                                                      | _ =>
                                                                                                                                                                         exit tt
                                                                                                                                                                          : M (bool)
                                                                                                                                                                      end)
                                                                                                                                                                      : M (bool)
                                                                                                                                                                   else
                                                                                                                                                                     (_s2452_
                                                                                                                                                                        _s1697_) >>= fun w__216 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                     (if
                                                                                                                                                                        ((match w__216 with
                                                                                                                                                                          | Some
                                                                                                                                                                            ((rd, rs1, rs2)) =>
                                                                                                                                                                             Z.eqb
                                                                                                                                                                               64
                                                                                                                                                                               64
                                                                                                                                                                          | _ =>
                                                                                                                                                                             false
                                                                                                                                                                          end))
                                                                                                                                                                      then
                                                                                                                                                                        (_s2452_
                                                                                                                                                                           _s1697_) >>= fun w__217 : option ((mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                        (match w__217 with
                                                                                                                                                                         | Some
                                                                                                                                                                           ((rd, rs1, rs2)) =>
                                                                                                                                                                            returnm (projT1
                                                                                                                                                                            (build_ex
                                                                                                                                                                            true
                                                                                                                                                                             : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                              true)}))
                                                                                                                                                                         | _ =>
                                                                                                                                                                            exit tt
                                                                                                                                                                             : M (bool)
                                                                                                                                                                         end)
                                                                                                                                                                         : M (bool)
                                                                                                                                                                      else
                                                                                                                                                                        (_s2468_
                                                                                                                                                                           _s1697_) >>= fun w__220 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                        (if
                                                                                                                                                                           ((match w__220 with
                                                                                                                                                                             | Some
                                                                                                                                                                               ((s, rd, rs1, rs2)) =>
                                                                                                                                                                                Z.eqb
                                                                                                                                                                                  64
                                                                                                                                                                                  64
                                                                                                                                                                             | _ =>
                                                                                                                                                                                false
                                                                                                                                                                             end))
                                                                                                                                                                         then
                                                                                                                                                                           (_s2468_
                                                                                                                                                                              _s1697_) >>= fun w__221 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                           (match w__221 with
                                                                                                                                                                            | Some
                                                                                                                                                                              ((s, rd, rs1, rs2)) =>
                                                                                                                                                                               returnm (projT1
                                                                                                                                                                               (build_ex
                                                                                                                                                                               true
                                                                                                                                                                                : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                                 true)}))
                                                                                                                                                                            | _ =>
                                                                                                                                                                               exit tt
                                                                                                                                                                                : M (bool)
                                                                                                                                                                            end)
                                                                                                                                                                            : M (bool)
                                                                                                                                                                         else
                                                                                                                                                                           (_s2487_
                                                                                                                                                                              _s1697_) >>= fun w__224 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                           (if
                                                                                                                                                                              ((match w__224 with
                                                                                                                                                                                | Some
                                                                                                                                                                                  ((s, rd, rs1, rs2)) =>
                                                                                                                                                                                   Z.eqb
                                                                                                                                                                                     64
                                                                                                                                                                                     64
                                                                                                                                                                                | _ =>
                                                                                                                                                                                   false
                                                                                                                                                                                end))
                                                                                                                                                                            then
                                                                                                                                                                              (_s2487_
                                                                                                                                                                                 _s1697_) >>= fun w__225 : option ((bool * mword 5 * mword 5 * mword 5)) =>
                                                                                                                                                                              (match w__225 with
                                                                                                                                                                               | Some
                                                                                                                                                                                 ((s, rd, rs1, rs2)) =>
                                                                                                                                                                                  returnm (projT1
                                                                                                                                                                                  (build_ex
                                                                                                                                                                                  true
                                                                                                                                                                                   : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                                    true)}))
                                                                                                                                                                               | _ =>
                                                                                                                                                                                  exit tt
                                                                                                                                                                                   : M (bool)
                                                                                                                                                                               end)
                                                                                                                                                                               : M (bool)
                                                                                                                                                                            else
                                                                                                                                                                              (_s2506_
                                                                                                                                                                                 _s1697_) >>= fun w__228 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                              (if
                                                                                                                                                                                 ((match w__228 with
                                                                                                                                                                                   | Some
                                                                                                                                                                                     ((op, rd, rs1, csr)) =>
                                                                                                                                                                                      true
                                                                                                                                                                                   | _ =>
                                                                                                                                                                                      false
                                                                                                                                                                                   end))
                                                                                                                                                                               then
                                                                                                                                                                                 (_s2506_
                                                                                                                                                                                    _s1697_) >>= fun w__229 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                                 (match w__229 with
                                                                                                                                                                                  | Some
                                                                                                                                                                                    ((op, rd, rs1, csr)) =>
                                                                                                                                                                                     returnm (projT1
                                                                                                                                                                                     (build_ex
                                                                                                                                                                                     true
                                                                                                                                                                                      : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                                       true)}))
                                                                                                                                                                                  | _ =>
                                                                                                                                                                                     exit tt
                                                                                                                                                                                      : M (bool)
                                                                                                                                                                                  end)
                                                                                                                                                                                  : M (bool)
                                                                                                                                                                               else
                                                                                                                                                                                 (_s2524_
                                                                                                                                                                                    _s1697_) >>= fun w__232 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                                 (if
                                                                                                                                                                                    ((match w__232 with
                                                                                                                                                                                      | Some
                                                                                                                                                                                        ((op, rd, rs1, csr)) =>
                                                                                                                                                                                         true
                                                                                                                                                                                      | _ =>
                                                                                                                                                                                         false
                                                                                                                                                                                      end))
                                                                                                                                                                                  then
                                                                                                                                                                                    (_s2524_
                                                                                                                                                                                       _s1697_) >>= fun w__233 : option ((csrop * mword 5 * mword 5 * mword 12)) =>
                                                                                                                                                                                    (match w__233 with
                                                                                                                                                                                     | Some
                                                                                                                                                                                       ((op, rd, rs1, csr)) =>
                                                                                                                                                                                        returnm (projT1
                                                                                                                                                                                        (build_ex
                                                                                                                                                                                        true
                                                                                                                                                                                         : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                                          true)}))
                                                                                                                                                                                     | _ =>
                                                                                                                                                                                        exit tt
                                                                                                                                                                                         : M (bool)
                                                                                                                                                                                     end)
                                                                                                                                                                                     : M (bool)
                                                                                                                                                                                  else if
                                                                                                                                                                                    ((generic_eq
                                                                                                                                                                                        _s1697_
                                                                                                                                                                                        "uret"))
                                                                                                                                                                                  then
                                                                                                                                                                                    returnm (projT1
                                                                                                                                                                                    (build_ex
                                                                                                                                                                                    true
                                                                                                                                                                                     : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                                      true)}))
                                                                                                                                                                                  else
                                                                                                                                                                                    (_s2541_
                                                                                                                                                                                       _s1697_) >>= fun w__236 : option (mword 32) =>
                                                                                                                                                                                    (if
                                                                                                                                                                                       ((match w__236 with
                                                                                                                                                                                         | Some
                                                                                                                                                                                           (s) =>
                                                                                                                                                                                            true
                                                                                                                                                                                         | _ =>
                                                                                                                                                                                            false
                                                                                                                                                                                         end))
                                                                                                                                                                                     then
                                                                                                                                                                                       (_s2541_
                                                                                                                                                                                          _s1697_) >>= fun w__237 : option (mword 32) =>
                                                                                                                                                                                       (match w__237 with
                                                                                                                                                                                        | Some
                                                                                                                                                                                          (s) =>
                                                                                                                                                                                           returnm (projT1
                                                                                                                                                                                           (build_ex
                                                                                                                                                                                           true
                                                                                                                                                                                            : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                                             true)}))
                                                                                                                                                                                        | _ =>
                                                                                                                                                                                           exit tt
                                                                                                                                                                                            : M (bool)
                                                                                                                                                                                        end)
                                                                                                                                                                                        : M (bool)
                                                                                                                                                                                     else
                                                                                                                                                                                       (_s2549_
                                                                                                                                                                                          _s1697_) >>= fun w__240 : option (mword 16) =>
                                                                                                                                                                                       (if
                                                                                                                                                                                          ((match w__240 with
                                                                                                                                                                                            | Some
                                                                                                                                                                                              (s) =>
                                                                                                                                                                                               true
                                                                                                                                                                                            | _ =>
                                                                                                                                                                                               false
                                                                                                                                                                                            end))
                                                                                                                                                                                        then
                                                                                                                                                                                          (_s2549_
                                                                                                                                                                                             _s1697_) >>= fun w__241 : option (mword 16) =>
                                                                                                                                                                                          (match w__241 with
                                                                                                                                                                                           | Some
                                                                                                                                                                                             (s) =>
                                                                                                                                                                                              returnm (projT1
                                                                                                                                                                                              (build_ex
                                                                                                                                                                                              true
                                                                                                                                                                                               : {_bool : bool & ArithFact (_bool =
                                                                                                                                                                                                true)}))
                                                                                                                                                                                           | _ =>
                                                                                                                                                                                              exit tt
                                                                                                                                                                                               : M (bool)
                                                                                                                                                                                           end)
                                                                                                                                                                                           : M (bool)
                                                                                                                                                                                        else
                                                                                                                                                                                          returnm (projT1
                                                                                                                                                                                          (build_ex
                                                                                                                                                                                          false
                                                                                                                                                                                           : {_bool : bool & ArithFact (not (_bool =
                                                                                                                                                                                            true))})))
                                                                                                                                                                                        : M (bool))
                                                                                                                                                                                     : M (bool))
                                                                                                                                                                                  : M (bool))
                                                                                                                                                                               : M (bool))
                                                                                                                                                                            : M (bool))
                                                                                                                                                                         : M (bool))
                                                                                                                                                                      : M (bool))
                                                                                                                                                                   : M (bool))
                                                                                                                                                                : M (bool))
                                                                                                                                                             : M (bool))
                                                                                                                                                          : M (bool))
                                                                                                                                                       : M (bool))
                                                                                                                                                    : M (bool))
                                                                                                                                                 : M (bool))
                                                                                                                                              : M (bool))
                                                                                                                                           : M (bool))
                                                                                                                                        : M (bool))
                                                                                                                                     : M (bool))
                                                                                                                                  : M (bool))
                                                                                                                               : M (bool))
                                                                                                                            : M (bool))
                                                                                                                         : M (bool))
                                                                                                                      : M (bool))
                                                                                                                   : M (bool))
                                                                                                                : M (bool))
                                                                                                             : M (bool))
                                                                                                          : M (bool))
                                                                                                       : M (bool))
                                                                                                    : M (bool))
                                                                                                 : M (bool))
                                                                                              : M (bool))
                                                                                           : M (bool))
                                                                                        : M (bool))
                                                                                     : M (bool))
                                                                                  : M (bool))
                                                                               : M (bool))
                                                                            : M (bool))
                                                                         : M (bool))
                                                                      : M (bool))
                                                                   : M (bool))
                                                                : M (bool))
                                                             : M (bool))
                                                          : M (bool))
                                                       : M (bool))
                                                    : M (bool))
                                                 : M (bool))
                                              : M (bool))
                                           : M (bool))
                                        : M (bool))
                                     : M (bool))
                                  : M (bool))
                               : M (bool))
                            : M (bool))
                         : M (bool))
                      : M (bool))
                   : M (bool))
                : M (bool))
             : M (bool))
          : M (bool))
       : M (bool))
    : M (bool).

Definition _s3457_ (_s3458_ : string) 
: M (option ((mword 16 * string))) :=
   
   let _s3459_ := _s3458_ in
   (if ((string_startswith _s3459_ "c.illegal")) then
      (match (string_drop _s3459_ (projT1 (string_length "c.illegal"))) with
       | _s3460_ =>
          (spc_matches_prefix _s3460_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s3461_ _)) =>
                       match (string_drop _s3460_ _s3461_) with
                       | _s3462_ =>
                          match (hex_bits_16_matches_prefix _s3462_) with
                          | Some ((s, existT _ _s3463_ _)) =>
                             match (string_drop _s3462_ _s3463_) with | s_ => Some ((s, s_)) end
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option ((mword 16 * string)))
       end)
       : M (option ((mword 16 * string)))
    else returnm (None  : option ((mword 16 * string))))
    : M (option ((mword 16 * string))).

Definition _s3449_ (_s3450_ : string) 
: M (option ((mword 32 * string))) :=
   
   let _s3451_ := _s3450_ in
   (if ((string_startswith _s3451_ "illegal")) then
      (match (string_drop _s3451_ (projT1 (string_length "illegal"))) with
       | _s3452_ =>
          (spc_matches_prefix _s3452_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s3453_ _)) =>
                       match (string_drop _s3452_ _s3453_) with
                       | _s3454_ =>
                          match (hex_bits_32_matches_prefix _s3454_) with
                          | Some ((s, existT _ _s3455_ _)) =>
                             match (string_drop _s3454_ _s3455_) with | s_ => Some ((s, s_)) end
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option ((mword 32 * string)))
       end)
       : M (option ((mword 32 * string)))
    else returnm (None  : option ((mword 32 * string))))
    : M (option ((mword 32 * string))).

Definition _s3445_ (_s3446_ : string) 
: option string :=
   
   let _s3447_ := _s3446_ in
   if ((string_startswith _s3447_ "uret")) then
     match (string_drop _s3447_ (projT1 (string_length "uret"))) with | s_ => Some (s_) end
   else None.

Definition _s3428_ (_s3429_ : string) 
: M (option ((csrop * mword 5 * mword 5 * mword 12 * string))) :=
   
   (match _s3429_ with
    | _s3430_ =>
       (csr_mnemonic_matches_prefix _s3430_) >>= fun w__0 : option ((csrop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s3431_ _)) =>
           (match (string_drop _s3430_ _s3431_) with
            | _s3432_ =>
               (spc_matches_prefix _s3432_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s3433_ _)) =>
                   (match (string_drop _s3432_ _s3433_) with
                    | _s3434_ =>
                       (reg_name_matches_prefix _s3434_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s3435_ _)) =>
                           (match (string_drop _s3434_ _s3435_) with
                            | _s3436_ =>
                               (sep_matches_prefix _s3436_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s3437_ _)) =>
                                   (match (string_drop _s3436_ _s3437_) with
                                    | _s3438_ =>
                                       (reg_name_matches_prefix _s3438_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s3439_ _)) =>
                                           (match (string_drop _s3438_ _s3439_) with
                                            | _s3440_ =>
                                               (sep_matches_prefix _s3440_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s3441_ _)) =>
                                                   (match (string_drop _s3440_ _s3441_) with
                                                    | _s3442_ =>
                                                       (csr_name_map_matches_prefix _s3442_) >>= fun w__6 : option ((mword 12 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((csr, existT _ _s3443_ _)) =>
                                                                    match (string_drop _s3442_
                                                                             _s3443_) with
                                                                    | s_ =>
                                                                       Some ((op, rd, rs1, csr, s_))
                                                                    end
                                                                 | _ => None
                                                                 end)
                                                        : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                                    end)
                                                    : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                                end)
                                                : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                            end)
                                            : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                        end)
                                        : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                    end)
                                    : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                end)
                                : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                            end)
                            : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                        | _ =>
                           returnm (None
                            : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                        end)
                        : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                    end)
                    : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                end)
                : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
            end)
            : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
        end)
        : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
    end)
    : M (option ((csrop * mword 5 * mword 5 * mword 12 * string))).

Definition _s3410_ (_s3411_ : string) 
: M (option ((csrop * mword 5 * mword 5 * mword 12 * string))) :=
   
   (match _s3411_ with
    | _s3412_ =>
       (csr_mnemonic_matches_prefix _s3412_) >>= fun w__0 : option ((csrop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s3413_ _)) =>
           let _s3414_ := string_drop _s3412_ _s3413_ in
           (if ((string_startswith _s3414_ "i")) then
              (match (string_drop _s3414_ (projT1 (string_length "i"))) with
               | _s3415_ =>
                  (spc_matches_prefix _s3415_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s3416_ _)) =>
                      (match (string_drop _s3415_ _s3416_) with
                       | _s3417_ =>
                          (reg_name_matches_prefix _s3417_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s3418_ _)) =>
                              (match (string_drop _s3417_ _s3418_) with
                               | _s3419_ =>
                                  (sep_matches_prefix _s3419_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s3420_ _)) =>
                                      (match (string_drop _s3419_ _s3420_) with
                                       | _s3421_ =>
                                          (match (hex_bits_5_matches_prefix _s3421_) with
                                           | Some ((rs1, existT _ _s3422_ _)) =>
                                              (match (string_drop _s3421_ _s3422_) with
                                               | _s3423_ =>
                                                  (sep_matches_prefix _s3423_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__4 with
                                                   | Some ((tt, existT _ _s3424_ _)) =>
                                                      (match (string_drop _s3423_ _s3424_) with
                                                       | _s3425_ =>
                                                          (csr_name_map_matches_prefix _s3425_) >>= fun w__5 : option ((mword 12 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__5 with
                                                                    | Some
                                                                      ((csr, existT _ _s3426_ _)) =>
                                                                       match (string_drop _s3425_
                                                                                _s3426_) with
                                                                       | s_ =>
                                                                          Some
                                                                            ((op, rd, rs1, csr, s_))
                                                                       end
                                                                    | _ => None
                                                                    end)
                                                           : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                                       end)
                                                       : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                                   end)
                                                   : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                               end)
                                               : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                           end)
                                           : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                       end)
                                       : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                                   end)
                                   : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                               end)
                               : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                           | _ =>
                              returnm (None
                               : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                           end)
                           : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                       end)
                       : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                   | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
                   end)
                   : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
               end)
               : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
            else returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12 * string))))
            : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
        | _ => returnm (None  : option ((csrop * mword 5 * mword 5 * mword 12 * string)))
        end)
        : M (option ((csrop * mword 5 * mword 5 * mword 12 * string)))
    end)
    : M (option ((csrop * mword 5 * mword 5 * mword 12 * string))).

Definition _s3391_ (_s3392_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s3393_ := _s3392_ in
   (if ((string_startswith _s3393_ "rem")) then
      (match (string_drop _s3393_ (projT1 (string_length "rem"))) with
       | _s3394_ =>
          (maybe_not_u_matches_prefix _s3394_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s3395_ _)) =>
              let _s3396_ := string_drop _s3394_ _s3395_ in
              (if ((string_startswith _s3396_ "w")) then
                 (match (string_drop _s3396_ (projT1 (string_length "w"))) with
                  | _s3397_ =>
                     (spc_matches_prefix _s3397_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some ((tt, existT _ _s3398_ _)) =>
                         (match (string_drop _s3397_ _s3398_) with
                          | _s3399_ =>
                             (reg_name_matches_prefix _s3399_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some ((rd, existT _ _s3400_ _)) =>
                                 (match (string_drop _s3399_ _s3400_) with
                                  | _s3401_ =>
                                     (sep_matches_prefix _s3401_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some ((tt, existT _ _s3402_ _)) =>
                                         (match (string_drop _s3401_ _s3402_) with
                                          | _s3403_ =>
                                             (reg_name_matches_prefix _s3403_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some ((rs1, existT _ _s3404_ _)) =>
                                                 (match (string_drop _s3403_ _s3404_) with
                                                  | _s3405_ =>
                                                     (sep_matches_prefix _s3405_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     (match w__5 with
                                                      | Some ((tt, existT _ _s3406_ _)) =>
                                                         (match (string_drop _s3405_ _s3406_) with
                                                          | _s3407_ =>
                                                             (reg_name_matches_prefix _s3407_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                               0)})) =>
                                                             returnm ((match w__6 with
                                                                       | Some
                                                                         ((rs2, existT _ _s3408_ _)) =>
                                                                          match (string_drop _s3407_
                                                                                   _s3408_) with
                                                                          | s_ =>
                                                                             Some
                                                                               ((s, rd, rs1, rs2, s_))
                                                                          end
                                                                       | _ => None
                                                                       end)
                                                              : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                          end)
                                                          : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                      | _ =>
                                                         returnm (None
                                                          : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                      end)
                                                      : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                  end)
                                                  : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                              end)
                                              : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                          end)
                                          : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                      | _ =>
                                         returnm (None
                                          : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                      end)
                                      : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                  end)
                                  : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                              | _ =>
                                 returnm (None
                                  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                              end)
                              : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                          end)
                          : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                      | _ =>
                         returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                      end)
                      : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                  end)
                  : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
               else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string))))
               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string))))
    : M (option ((bool * mword 5 * mword 5 * mword 5 * string))).

Definition _s3372_ (_s3373_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s3374_ := _s3373_ in
   (if ((string_startswith _s3374_ "div")) then
      (match (string_drop _s3374_ (projT1 (string_length "div"))) with
       | _s3375_ =>
          (maybe_not_u_matches_prefix _s3375_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s3376_ _)) =>
              let _s3377_ := string_drop _s3375_ _s3376_ in
              (if ((string_startswith _s3377_ "w")) then
                 (match (string_drop _s3377_ (projT1 (string_length "w"))) with
                  | _s3378_ =>
                     (spc_matches_prefix _s3378_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                       0)})) =>
                     (match w__1 with
                      | Some ((tt, existT _ _s3379_ _)) =>
                         (match (string_drop _s3378_ _s3379_) with
                          | _s3380_ =>
                             (reg_name_matches_prefix _s3380_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                               0)})) =>
                             (match w__2 with
                              | Some ((rd, existT _ _s3381_ _)) =>
                                 (match (string_drop _s3380_ _s3381_) with
                                  | _s3382_ =>
                                     (sep_matches_prefix _s3382_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                       0)})) =>
                                     (match w__3 with
                                      | Some ((tt, existT _ _s3383_ _)) =>
                                         (match (string_drop _s3382_ _s3383_) with
                                          | _s3384_ =>
                                             (reg_name_matches_prefix _s3384_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                               0)})) =>
                                             (match w__4 with
                                              | Some ((rs1, existT _ _s3385_ _)) =>
                                                 (match (string_drop _s3384_ _s3385_) with
                                                  | _s3386_ =>
                                                     (sep_matches_prefix _s3386_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                       0)})) =>
                                                     (match w__5 with
                                                      | Some ((tt, existT _ _s3387_ _)) =>
                                                         (match (string_drop _s3386_ _s3387_) with
                                                          | _s3388_ =>
                                                             (reg_name_matches_prefix _s3388_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                               0)})) =>
                                                             returnm ((match w__6 with
                                                                       | Some
                                                                         ((rs2, existT _ _s3389_ _)) =>
                                                                          match (string_drop _s3388_
                                                                                   _s3389_) with
                                                                          | s_ =>
                                                                             Some
                                                                               ((s, rd, rs1, rs2, s_))
                                                                          end
                                                                       | _ => None
                                                                       end)
                                                              : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                          end)
                                                          : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                      | _ =>
                                                         returnm (None
                                                          : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                      end)
                                                      : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                  end)
                                                  : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                              | _ =>
                                                 returnm (None
                                                  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                              end)
                                              : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                          end)
                                          : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                      | _ =>
                                         returnm (None
                                          : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                      end)
                                      : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                  end)
                                  : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                              | _ =>
                                 returnm (None
                                  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                              end)
                              : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                          end)
                          : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                      | _ =>
                         returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                      end)
                      : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                  end)
                  : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
               else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string))))
               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string))))
    : M (option ((bool * mword 5 * mword 5 * mword 5 * string))).

Definition _s3356_ (_s3357_ : string) 
: M (option ((mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s3358_ := _s3357_ in
   (if ((string_startswith _s3358_ "mulw")) then
      (match (string_drop _s3358_ (projT1 (string_length "mulw"))) with
       | _s3359_ =>
          (spc_matches_prefix _s3359_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3360_ _)) =>
              (match (string_drop _s3359_ _s3360_) with
               | _s3361_ =>
                  (reg_name_matches_prefix _s3361_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s3362_ _)) =>
                      (match (string_drop _s3361_ _s3362_) with
                       | _s3363_ =>
                          (sep_matches_prefix _s3363_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3364_ _)) =>
                              (match (string_drop _s3363_ _s3364_) with
                               | _s3365_ =>
                                  (reg_name_matches_prefix _s3365_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s3366_ _)) =>
                                      (match (string_drop _s3365_ _s3366_) with
                                       | _s3367_ =>
                                          (sep_matches_prefix _s3367_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s3368_ _)) =>
                                              (match (string_drop _s3367_ _s3368_) with
                                               | _s3369_ =>
                                                  (reg_name_matches_prefix _s3369_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  returnm ((match w__5 with
                                                            | Some ((rs2, existT _ _s3370_ _)) =>
                                                               match (string_drop _s3369_ _s3370_) with
                                                               | s_ => Some ((rd, rs1, rs2, s_))
                                                               end
                                                            | _ => None
                                                            end)
                                                   : option ((mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * mword 5 * string))).

Definition _s3338_ (_s3339_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s3340_ := _s3339_ in
   (if ((string_startswith _s3340_ "rem")) then
      (match (string_drop _s3340_ (projT1 (string_length "rem"))) with
       | _s3341_ =>
          (maybe_not_u_matches_prefix _s3341_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s3342_ _)) =>
              (match (string_drop _s3341_ _s3342_) with
               | _s3343_ =>
                  (spc_matches_prefix _s3343_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s3344_ _)) =>
                      (match (string_drop _s3343_ _s3344_) with
                       | _s3345_ =>
                          (reg_name_matches_prefix _s3345_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s3346_ _)) =>
                              (match (string_drop _s3345_ _s3346_) with
                               | _s3347_ =>
                                  (sep_matches_prefix _s3347_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s3348_ _)) =>
                                      (match (string_drop _s3347_ _s3348_) with
                                       | _s3349_ =>
                                          (reg_name_matches_prefix _s3349_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs1, existT _ _s3350_ _)) =>
                                              (match (string_drop _s3349_ _s3350_) with
                                               | _s3351_ =>
                                                  (sep_matches_prefix _s3351_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s3352_ _)) =>
                                                      (match (string_drop _s3351_ _s3352_) with
                                                       | _s3353_ =>
                                                          (reg_name_matches_prefix _s3353_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs2, existT _ _s3354_ _)) =>
                                                                       match (string_drop _s3353_
                                                                                _s3354_) with
                                                                       | s_ =>
                                                                          Some
                                                                            ((s, rd, rs1, rs2, s_))
                                                                       end
                                                                    | _ => None
                                                                    end)
                                                           : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                       end)
                                                       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                   end)
                                                   : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                           | _ =>
                              returnm (None
                               : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string))))
    : M (option ((bool * mword 5 * mword 5 * mword 5 * string))).

Definition _s3320_ (_s3321_ : string) 
: M (option ((bool * mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s3322_ := _s3321_ in
   (if ((string_startswith _s3322_ "div")) then
      (match (string_drop _s3322_ (projT1 (string_length "div"))) with
       | _s3323_ =>
          (maybe_not_u_matches_prefix _s3323_) >>= fun w__0 : option ((bool * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((s, existT _ _s3324_ _)) =>
              (match (string_drop _s3323_ _s3324_) with
               | _s3325_ =>
                  (spc_matches_prefix _s3325_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((tt, existT _ _s3326_ _)) =>
                      (match (string_drop _s3325_ _s3326_) with
                       | _s3327_ =>
                          (reg_name_matches_prefix _s3327_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rd, existT _ _s3328_ _)) =>
                              (match (string_drop _s3327_ _s3328_) with
                               | _s3329_ =>
                                  (sep_matches_prefix _s3329_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s3330_ _)) =>
                                      (match (string_drop _s3329_ _s3330_) with
                                       | _s3331_ =>
                                          (reg_name_matches_prefix _s3331_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs1, existT _ _s3332_ _)) =>
                                              (match (string_drop _s3331_ _s3332_) with
                                               | _s3333_ =>
                                                  (sep_matches_prefix _s3333_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s3334_ _)) =>
                                                      (match (string_drop _s3333_ _s3334_) with
                                                       | _s3335_ =>
                                                          (reg_name_matches_prefix _s3335_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs2, existT _ _s3336_ _)) =>
                                                                       match (string_drop _s3335_
                                                                                _s3336_) with
                                                                       | s_ =>
                                                                          Some
                                                                            ((s, rd, rs1, rs2, s_))
                                                                       end
                                                                    | _ => None
                                                                    end)
                                                           : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                       end)
                                                       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                                   end)
                                                   : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                           | _ =>
                              returnm (None
                               : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((bool * mword 5 * mword 5 * mword 5 * string)))
    else returnm (None  : option ((bool * mword 5 * mword 5 * mword 5 * string))))
    : M (option ((bool * mword 5 * mword 5 * mword 5 * string))).

Definition _s3303_ (_s3304_ : string) 
: M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s3304_ with
    | _s3305_ =>
       (mul_mnemonic_matches_prefix _s3305_) >>= fun w__0 : option (((bool * bool * bool) * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some (((high, signed1, signed2), existT _ _s3306_ _)) =>
           (match (string_drop _s3305_ _s3306_) with
            | _s3307_ =>
               (spc_matches_prefix _s3307_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s3308_ _)) =>
                   (match (string_drop _s3307_ _s3308_) with
                    | _s3309_ =>
                       (reg_name_matches_prefix _s3309_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s3310_ _)) =>
                           (match (string_drop _s3309_ _s3310_) with
                            | _s3311_ =>
                               (sep_matches_prefix _s3311_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s3312_ _)) =>
                                   (match (string_drop _s3311_ _s3312_) with
                                    | _s3313_ =>
                                       (reg_name_matches_prefix _s3313_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s3314_ _)) =>
                                           (match (string_drop _s3313_ _s3314_) with
                                            | _s3315_ =>
                                               (sep_matches_prefix _s3315_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s3316_ _)) =>
                                                   (match (string_drop _s3315_ _s3316_) with
                                                    | _s3317_ =>
                                                       (reg_name_matches_prefix _s3317_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s3318_ _)) =>
                                                                    match (string_drop _s3317_
                                                                             _s3318_) with
                                                                    | s_ =>
                                                                       Some
                                                                         ((high, signed1, signed2, rd, rs1, rs2, s_))
                                                                    end
                                                                 | _ => None
                                                                 end)
                                                        : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                    end)
                                                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                end)
                                                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None
                            : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                | _ =>
                   returnm (None
                    : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
        | _ =>
           returnm (None  : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string))).

Definition _s3291_ (_s3292_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s3293_ := _s3292_ in
   (if ((string_startswith _s3293_ "c.add")) then
      (match (string_drop _s3293_ (projT1 (string_length "c.add"))) with
       | _s3294_ =>
          (spc_matches_prefix _s3294_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3295_ _)) =>
              (match (string_drop _s3294_ _s3295_) with
               | _s3296_ =>
                  (reg_name_matches_prefix _s3296_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3297_ _)) =>
                      (match (string_drop _s3296_ _s3297_) with
                       | _s3298_ =>
                          (sep_matches_prefix _s3298_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3299_ _)) =>
                              (match (string_drop _s3298_ _s3299_) with
                               | _s3300_ =>
                                  (reg_name_matches_prefix _s3300_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3301_ _)) =>
                                               match (string_drop _s3300_ _s3301_) with
                                               | s_ => Some ((rsd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s3287_ (_s3288_ : string) 
: option string :=
   
   let _s3289_ := _s3288_ in
   if ((string_startswith _s3289_ "c.ebreak")) then
     match (string_drop _s3289_ (projT1 (string_length "c.ebreak"))) with | s_ => Some (s_) end
   else None.

Definition _s3275_ (_s3276_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s3277_ := _s3276_ in
   (if ((string_startswith _s3277_ "c.mv")) then
      (match (string_drop _s3277_ (projT1 (string_length "c.mv"))) with
       | _s3278_ =>
          (spc_matches_prefix _s3278_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3279_ _)) =>
              (match (string_drop _s3278_ _s3279_) with
               | _s3280_ =>
                  (reg_name_matches_prefix _s3280_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s3281_ _)) =>
                      (match (string_drop _s3280_ _s3281_) with
                       | _s3282_ =>
                          (sep_matches_prefix _s3282_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3283_ _)) =>
                              (match (string_drop _s3282_ _s3283_) with
                               | _s3284_ =>
                                  (reg_name_matches_prefix _s3284_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3285_ _)) =>
                                               match (string_drop _s3284_ _s3285_) with
                                               | s_ => Some ((rd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s3267_ (_s3268_ : string) 
: M (option ((mword 5 * string))) :=
   
   let _s3269_ := _s3268_ in
   (if ((string_startswith _s3269_ "c.jalr")) then
      (match (string_drop _s3269_ (projT1 (string_length "c.jalr"))) with
       | _s3270_ =>
          (spc_matches_prefix _s3270_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3271_ _)) =>
              (match (string_drop _s3270_ _s3271_) with
               | _s3272_ =>
                  (reg_name_matches_prefix _s3272_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((rs1, existT _ _s3273_ _)) =>
                               match (string_drop _s3272_ _s3273_) with | s_ => Some ((rs1, s_)) end
                            | _ => None
                            end)
                   : option ((mword 5 * string)))
               end)
               : M (option ((mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * string)))
           end)
           : M (option ((mword 5 * string)))
       end)
       : M (option ((mword 5 * string)))
    else returnm (None  : option ((mword 5 * string))))
    : M (option ((mword 5 * string))).

Definition _s3259_ (_s3260_ : string) 
: M (option ((mword 5 * string))) :=
   
   let _s3261_ := _s3260_ in
   (if ((string_startswith _s3261_ "c.jr")) then
      (match (string_drop _s3261_ (projT1 (string_length "c.jr"))) with
       | _s3262_ =>
          (spc_matches_prefix _s3262_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3263_ _)) =>
              (match (string_drop _s3262_ _s3263_) with
               | _s3264_ =>
                  (reg_name_matches_prefix _s3264_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  returnm ((match w__1 with
                            | Some ((rs1, existT _ _s3265_ _)) =>
                               match (string_drop _s3264_ _s3265_) with | s_ => Some ((rs1, s_)) end
                            | _ => None
                            end)
                   : option ((mword 5 * string)))
               end)
               : M (option ((mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * string)))
           end)
           : M (option ((mword 5 * string)))
       end)
       : M (option ((mword 5 * string)))
    else returnm (None  : option ((mword 5 * string))))
    : M (option ((mword 5 * string))).

Definition _s3247_ (_s3248_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3249_ := _s3248_ in
   (if ((string_startswith _s3249_ "c.sdsp")) then
      (match (string_drop _s3249_ (projT1 (string_length "c.sdsp"))) with
       | _s3250_ =>
          (spc_matches_prefix _s3250_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3251_ _)) =>
              (match (string_drop _s3250_ _s3251_) with
               | _s3252_ =>
                  (reg_name_matches_prefix _s3252_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs2, existT _ _s3253_ _)) =>
                      (match (string_drop _s3252_ _s3253_) with
                       | _s3254_ =>
                          (sep_matches_prefix _s3254_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3255_ _)) =>
                                       match (string_drop _s3254_ _s3255_) with
                                       | _s3256_ =>
                                          match (hex_bits_6_matches_prefix _s3256_) with
                                          | Some ((uimm, existT _ _s3257_ _)) =>
                                             match (string_drop _s3256_ _s3257_) with
                                             | s_ => Some ((rs2, uimm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3235_ (_s3236_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3237_ := _s3236_ in
   (if ((string_startswith _s3237_ "c.swsp")) then
      (match (string_drop _s3237_ (projT1 (string_length "c.swsp"))) with
       | _s3238_ =>
          (spc_matches_prefix _s3238_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3239_ _)) =>
              (match (string_drop _s3238_ _s3239_) with
               | _s3240_ =>
                  (reg_name_matches_prefix _s3240_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s3241_ _)) =>
                      (match (string_drop _s3240_ _s3241_) with
                       | _s3242_ =>
                          (sep_matches_prefix _s3242_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3243_ _)) =>
                                       match (string_drop _s3242_ _s3243_) with
                                       | _s3244_ =>
                                          match (hex_bits_6_matches_prefix _s3244_) with
                                          | Some ((uimm, existT _ _s3245_ _)) =>
                                             match (string_drop _s3244_ _s3245_) with
                                             | s_ => Some ((rd, uimm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3223_ (_s3224_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3225_ := _s3224_ in
   (if ((string_startswith _s3225_ "c.ldsp")) then
      (match (string_drop _s3225_ (projT1 (string_length "c.ldsp"))) with
       | _s3226_ =>
          (spc_matches_prefix _s3226_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3227_ _)) =>
              (match (string_drop _s3226_ _s3227_) with
               | _s3228_ =>
                  (reg_name_matches_prefix _s3228_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s3229_ _)) =>
                      (match (string_drop _s3228_ _s3229_) with
                       | _s3230_ =>
                          (sep_matches_prefix _s3230_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3231_ _)) =>
                                       match (string_drop _s3230_ _s3231_) with
                                       | _s3232_ =>
                                          match (hex_bits_6_matches_prefix _s3232_) with
                                          | Some ((uimm, existT _ _s3233_ _)) =>
                                             match (string_drop _s3232_ _s3233_) with
                                             | s_ => Some ((rd, uimm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3211_ (_s3212_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3213_ := _s3212_ in
   (if ((string_startswith _s3213_ "c.lwsp")) then
      (match (string_drop _s3213_ (projT1 (string_length "c.lwsp"))) with
       | _s3214_ =>
          (spc_matches_prefix _s3214_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3215_ _)) =>
              (match (string_drop _s3214_ _s3215_) with
               | _s3216_ =>
                  (reg_name_matches_prefix _s3216_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s3217_ _)) =>
                      (match (string_drop _s3216_ _s3217_) with
                       | _s3218_ =>
                          (sep_matches_prefix _s3218_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3219_ _)) =>
                                       match (string_drop _s3218_ _s3219_) with
                                       | _s3220_ =>
                                          match (hex_bits_6_matches_prefix _s3220_) with
                                          | Some ((uimm, existT _ _s3221_ _)) =>
                                             match (string_drop _s3220_ _s3221_) with
                                             | s_ => Some ((rd, uimm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3199_ (_s3200_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3201_ := _s3200_ in
   (if ((string_startswith _s3201_ "c.slli")) then
      (match (string_drop _s3201_ (projT1 (string_length "c.slli"))) with
       | _s3202_ =>
          (spc_matches_prefix _s3202_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3203_ _)) =>
              (match (string_drop _s3202_ _s3203_) with
               | _s3204_ =>
                  (reg_name_matches_prefix _s3204_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3205_ _)) =>
                      (match (string_drop _s3204_ _s3205_) with
                       | _s3206_ =>
                          (sep_matches_prefix _s3206_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3207_ _)) =>
                                       match (string_drop _s3206_ _s3207_) with
                                       | _s3208_ =>
                                          match (hex_bits_6_matches_prefix _s3208_) with
                                          | Some ((shamt, existT _ _s3209_ _)) =>
                                             match (string_drop _s3208_ _s3209_) with
                                             | s_ => Some ((rsd, shamt, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3187_ (_s3188_ : string) 
: M (option ((mword 3 * mword 8 * string))) :=
   
   let _s3189_ := _s3188_ in
   (if ((string_startswith _s3189_ "c.bnez")) then
      (match (string_drop _s3189_ (projT1 (string_length "c.bnez"))) with
       | _s3190_ =>
          (spc_matches_prefix _s3190_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3191_ _)) =>
              (match (string_drop _s3190_ _s3191_) with
               | _s3192_ =>
                  (creg_name_matches_prefix _s3192_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs, existT _ _s3193_ _)) =>
                      (match (string_drop _s3192_ _s3193_) with
                       | _s3194_ =>
                          (sep_matches_prefix _s3194_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3195_ _)) =>
                                       match (string_drop _s3194_ _s3195_) with
                                       | _s3196_ =>
                                          match (hex_bits_8_matches_prefix _s3196_) with
                                          | Some ((imm, existT _ _s3197_ _)) =>
                                             match (string_drop _s3196_ _s3197_) with
                                             | s_ => Some ((rs, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8 * string)))
                       end)
                       : M (option ((mword 3 * mword 8 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 8 * string)))
                   end)
                   : M (option ((mword 3 * mword 8 * string)))
               end)
               : M (option ((mword 3 * mword 8 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 8 * string)))
           end)
           : M (option ((mword 3 * mword 8 * string)))
       end)
       : M (option ((mword 3 * mword 8 * string)))
    else returnm (None  : option ((mword 3 * mword 8 * string))))
    : M (option ((mword 3 * mword 8 * string))).

Definition _s3175_ (_s3176_ : string) 
: M (option ((mword 3 * mword 8 * string))) :=
   
   let _s3177_ := _s3176_ in
   (if ((string_startswith _s3177_ "c.beqz")) then
      (match (string_drop _s3177_ (projT1 (string_length "c.beqz"))) with
       | _s3178_ =>
          (spc_matches_prefix _s3178_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3179_ _)) =>
              (match (string_drop _s3178_ _s3179_) with
               | _s3180_ =>
                  (creg_name_matches_prefix _s3180_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs, existT _ _s3181_ _)) =>
                      (match (string_drop _s3180_ _s3181_) with
                       | _s3182_ =>
                          (sep_matches_prefix _s3182_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3183_ _)) =>
                                       match (string_drop _s3182_ _s3183_) with
                                       | _s3184_ =>
                                          match (hex_bits_8_matches_prefix _s3184_) with
                                          | Some ((imm, existT _ _s3185_ _)) =>
                                             match (string_drop _s3184_ _s3185_) with
                                             | s_ => Some ((rs, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8 * string)))
                       end)
                       : M (option ((mword 3 * mword 8 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 8 * string)))
                   end)
                   : M (option ((mword 3 * mword 8 * string)))
               end)
               : M (option ((mword 3 * mword 8 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 8 * string)))
           end)
           : M (option ((mword 3 * mword 8 * string)))
       end)
       : M (option ((mword 3 * mword 8 * string)))
    else returnm (None  : option ((mword 3 * mword 8 * string))))
    : M (option ((mword 3 * mword 8 * string))).

Definition _s3167_ (_s3168_ : string) 
: M (option ((mword 11 * string))) :=
   
   let _s3169_ := _s3168_ in
   (if ((string_startswith _s3169_ "c.j")) then
      (match (string_drop _s3169_ (projT1 (string_length "c.j"))) with
       | _s3170_ =>
          (spc_matches_prefix _s3170_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s3171_ _)) =>
                       match (string_drop _s3170_ _s3171_) with
                       | _s3172_ =>
                          match (hex_bits_11_matches_prefix _s3172_) with
                          | Some ((imm, existT _ _s3173_ _)) =>
                             match (string_drop _s3172_ _s3173_) with | s_ => Some ((imm, s_)) end
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option ((mword 11 * string)))
       end)
       : M (option ((mword 11 * string)))
    else returnm (None  : option ((mword 11 * string))))
    : M (option ((mword 11 * string))).

Definition _s3155_ (_s3156_ : string) 
: M (option ((mword 3 * mword 3 * string))) :=
   
   let _s3157_ := _s3156_ in
   (if ((string_startswith _s3157_ "c.addw")) then
      (match (string_drop _s3157_ (projT1 (string_length "c.addw"))) with
       | _s3158_ =>
          (spc_matches_prefix _s3158_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3159_ _)) =>
              (match (string_drop _s3158_ _s3159_) with
               | _s3160_ =>
                  (creg_name_matches_prefix _s3160_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3161_ _)) =>
                      (match (string_drop _s3160_ _s3161_) with
                       | _s3162_ =>
                          (sep_matches_prefix _s3162_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3163_ _)) =>
                              (match (string_drop _s3162_ _s3163_) with
                               | _s3164_ =>
                                  (creg_name_matches_prefix _s3164_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3165_ _)) =>
                                               match (string_drop _s3164_ _s3165_) with
                                               | s_ => Some ((rsd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * string)))
               end)
               : M (option ((mword 3 * mword 3 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
           end)
           : M (option ((mword 3 * mword 3 * string)))
       end)
       : M (option ((mword 3 * mword 3 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * string))))
    : M (option ((mword 3 * mword 3 * string))).

Definition _s3143_ (_s3144_ : string) 
: M (option ((mword 3 * mword 3 * string))) :=
   
   let _s3145_ := _s3144_ in
   (if ((string_startswith _s3145_ "c.subw")) then
      (match (string_drop _s3145_ (projT1 (string_length "c.subw"))) with
       | _s3146_ =>
          (spc_matches_prefix _s3146_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3147_ _)) =>
              (match (string_drop _s3146_ _s3147_) with
               | _s3148_ =>
                  (creg_name_matches_prefix _s3148_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3149_ _)) =>
                      (match (string_drop _s3148_ _s3149_) with
                       | _s3150_ =>
                          (sep_matches_prefix _s3150_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3151_ _)) =>
                              (match (string_drop _s3150_ _s3151_) with
                               | _s3152_ =>
                                  (creg_name_matches_prefix _s3152_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3153_ _)) =>
                                               match (string_drop _s3152_ _s3153_) with
                                               | s_ => Some ((rsd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * string)))
               end)
               : M (option ((mword 3 * mword 3 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
           end)
           : M (option ((mword 3 * mword 3 * string)))
       end)
       : M (option ((mword 3 * mword 3 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * string))))
    : M (option ((mword 3 * mword 3 * string))).

Definition _s3131_ (_s3132_ : string) 
: M (option ((mword 3 * mword 3 * string))) :=
   
   let _s3133_ := _s3132_ in
   (if ((string_startswith _s3133_ "c.and")) then
      (match (string_drop _s3133_ (projT1 (string_length "c.and"))) with
       | _s3134_ =>
          (spc_matches_prefix _s3134_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3135_ _)) =>
              (match (string_drop _s3134_ _s3135_) with
               | _s3136_ =>
                  (creg_name_matches_prefix _s3136_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3137_ _)) =>
                      (match (string_drop _s3136_ _s3137_) with
                       | _s3138_ =>
                          (sep_matches_prefix _s3138_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3139_ _)) =>
                              (match (string_drop _s3138_ _s3139_) with
                               | _s3140_ =>
                                  (creg_name_matches_prefix _s3140_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3141_ _)) =>
                                               match (string_drop _s3140_ _s3141_) with
                                               | s_ => Some ((rsd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * string)))
               end)
               : M (option ((mword 3 * mword 3 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
           end)
           : M (option ((mword 3 * mword 3 * string)))
       end)
       : M (option ((mword 3 * mword 3 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * string))))
    : M (option ((mword 3 * mword 3 * string))).

Definition _s3119_ (_s3120_ : string) 
: M (option ((mword 3 * mword 3 * string))) :=
   
   let _s3121_ := _s3120_ in
   (if ((string_startswith _s3121_ "c.or")) then
      (match (string_drop _s3121_ (projT1 (string_length "c.or"))) with
       | _s3122_ =>
          (spc_matches_prefix _s3122_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3123_ _)) =>
              (match (string_drop _s3122_ _s3123_) with
               | _s3124_ =>
                  (creg_name_matches_prefix _s3124_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3125_ _)) =>
                      (match (string_drop _s3124_ _s3125_) with
                       | _s3126_ =>
                          (sep_matches_prefix _s3126_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3127_ _)) =>
                              (match (string_drop _s3126_ _s3127_) with
                               | _s3128_ =>
                                  (creg_name_matches_prefix _s3128_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3129_ _)) =>
                                               match (string_drop _s3128_ _s3129_) with
                                               | s_ => Some ((rsd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * string)))
               end)
               : M (option ((mword 3 * mword 3 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
           end)
           : M (option ((mword 3 * mword 3 * string)))
       end)
       : M (option ((mword 3 * mword 3 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * string))))
    : M (option ((mword 3 * mword 3 * string))).

Definition _s3107_ (_s3108_ : string) 
: M (option ((mword 3 * mword 3 * string))) :=
   
   let _s3109_ := _s3108_ in
   (if ((string_startswith _s3109_ "c.xor")) then
      (match (string_drop _s3109_ (projT1 (string_length "c.xor"))) with
       | _s3110_ =>
          (spc_matches_prefix _s3110_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3111_ _)) =>
              (match (string_drop _s3110_ _s3111_) with
               | _s3112_ =>
                  (creg_name_matches_prefix _s3112_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3113_ _)) =>
                      (match (string_drop _s3112_ _s3113_) with
                       | _s3114_ =>
                          (sep_matches_prefix _s3114_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3115_ _)) =>
                              (match (string_drop _s3114_ _s3115_) with
                               | _s3116_ =>
                                  (creg_name_matches_prefix _s3116_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3117_ _)) =>
                                               match (string_drop _s3116_ _s3117_) with
                                               | s_ => Some ((rsd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * string)))
               end)
               : M (option ((mword 3 * mword 3 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
           end)
           : M (option ((mword 3 * mword 3 * string)))
       end)
       : M (option ((mword 3 * mword 3 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * string))))
    : M (option ((mword 3 * mword 3 * string))).

Definition _s3095_ (_s3096_ : string) 
: M (option ((mword 3 * mword 3 * string))) :=
   
   let _s3097_ := _s3096_ in
   (if ((string_startswith _s3097_ "c.sub")) then
      (match (string_drop _s3097_ (projT1 (string_length "c.sub"))) with
       | _s3098_ =>
          (spc_matches_prefix _s3098_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3099_ _)) =>
              (match (string_drop _s3098_ _s3099_) with
               | _s3100_ =>
                  (creg_name_matches_prefix _s3100_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3101_ _)) =>
                      (match (string_drop _s3100_ _s3101_) with
                       | _s3102_ =>
                          (sep_matches_prefix _s3102_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s3103_ _)) =>
                              (match (string_drop _s3102_ _s3103_) with
                               | _s3104_ =>
                                  (creg_name_matches_prefix _s3104_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s3105_ _)) =>
                                               match (string_drop _s3104_ _s3105_) with
                                               | s_ => Some ((rsd, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 3 * mword 3 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * string)))
               end)
               : M (option ((mword 3 * mword 3 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * string)))
           end)
           : M (option ((mword 3 * mword 3 * string)))
       end)
       : M (option ((mword 3 * mword 3 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * string))))
    : M (option ((mword 3 * mword 3 * string))).

Definition _s3083_ (_s3084_ : string) 
: M (option ((mword 3 * mword 6 * string))) :=
   
   let _s3085_ := _s3084_ in
   (if ((string_startswith _s3085_ "c.andi")) then
      (match (string_drop _s3085_ (projT1 (string_length "c.andi"))) with
       | _s3086_ =>
          (spc_matches_prefix _s3086_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3087_ _)) =>
              (match (string_drop _s3086_ _s3087_) with
               | _s3088_ =>
                  (creg_name_matches_prefix _s3088_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3089_ _)) =>
                      (match (string_drop _s3088_ _s3089_) with
                       | _s3090_ =>
                          (sep_matches_prefix _s3090_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3091_ _)) =>
                                       match (string_drop _s3090_ _s3091_) with
                                       | _s3092_ =>
                                          match (hex_bits_6_matches_prefix _s3092_) with
                                          | Some ((imm, existT _ _s3093_ _)) =>
                                             match (string_drop _s3092_ _s3093_) with
                                             | s_ => Some ((rsd, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6 * string)))
                       end)
                       : M (option ((mword 3 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 6 * string)))
                   end)
                   : M (option ((mword 3 * mword 6 * string)))
               end)
               : M (option ((mword 3 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 6 * string)))
           end)
           : M (option ((mword 3 * mword 6 * string)))
       end)
       : M (option ((mword 3 * mword 6 * string)))
    else returnm (None  : option ((mword 3 * mword 6 * string))))
    : M (option ((mword 3 * mword 6 * string))).

Definition _s3071_ (_s3072_ : string) 
: M (option ((mword 3 * mword 6 * string))) :=
   
   let _s3073_ := _s3072_ in
   (if ((string_startswith _s3073_ "c.srai")) then
      (match (string_drop _s3073_ (projT1 (string_length "c.srai"))) with
       | _s3074_ =>
          (spc_matches_prefix _s3074_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3075_ _)) =>
              (match (string_drop _s3074_ _s3075_) with
               | _s3076_ =>
                  (creg_name_matches_prefix _s3076_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3077_ _)) =>
                      (match (string_drop _s3076_ _s3077_) with
                       | _s3078_ =>
                          (sep_matches_prefix _s3078_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3079_ _)) =>
                                       match (string_drop _s3078_ _s3079_) with
                                       | _s3080_ =>
                                          match (hex_bits_6_matches_prefix _s3080_) with
                                          | Some ((shamt, existT _ _s3081_ _)) =>
                                             match (string_drop _s3080_ _s3081_) with
                                             | s_ => Some ((rsd, shamt, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6 * string)))
                       end)
                       : M (option ((mword 3 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 6 * string)))
                   end)
                   : M (option ((mword 3 * mword 6 * string)))
               end)
               : M (option ((mword 3 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 6 * string)))
           end)
           : M (option ((mword 3 * mword 6 * string)))
       end)
       : M (option ((mword 3 * mword 6 * string)))
    else returnm (None  : option ((mword 3 * mword 6 * string))))
    : M (option ((mword 3 * mword 6 * string))).

Definition _s3059_ (_s3060_ : string) 
: M (option ((mword 3 * mword 6 * string))) :=
   
   let _s3061_ := _s3060_ in
   (if ((string_startswith _s3061_ "c.srli")) then
      (match (string_drop _s3061_ (projT1 (string_length "c.srli"))) with
       | _s3062_ =>
          (spc_matches_prefix _s3062_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3063_ _)) =>
              (match (string_drop _s3062_ _s3063_) with
               | _s3064_ =>
                  (creg_name_matches_prefix _s3064_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3065_ _)) =>
                      (match (string_drop _s3064_ _s3065_) with
                       | _s3066_ =>
                          (sep_matches_prefix _s3066_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3067_ _)) =>
                                       match (string_drop _s3066_ _s3067_) with
                                       | _s3068_ =>
                                          match (hex_bits_6_matches_prefix _s3068_) with
                                          | Some ((shamt, existT _ _s3069_ _)) =>
                                             match (string_drop _s3068_ _s3069_) with
                                             | s_ => Some ((rsd, shamt, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 6 * string)))
                       end)
                       : M (option ((mword 3 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 6 * string)))
                   end)
                   : M (option ((mword 3 * mword 6 * string)))
               end)
               : M (option ((mword 3 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 6 * string)))
           end)
           : M (option ((mword 3 * mword 6 * string)))
       end)
       : M (option ((mword 3 * mword 6 * string)))
    else returnm (None  : option ((mword 3 * mword 6 * string))))
    : M (option ((mword 3 * mword 6 * string))).

Definition _s3047_ (_s3048_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3049_ := _s3048_ in
   (if ((string_startswith _s3049_ "c.lui")) then
      (match (string_drop _s3049_ (projT1 (string_length "c.lui"))) with
       | _s3050_ =>
          (spc_matches_prefix _s3050_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3051_ _)) =>
              (match (string_drop _s3050_ _s3051_) with
               | _s3052_ =>
                  (reg_name_matches_prefix _s3052_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s3053_ _)) =>
                      (match (string_drop _s3052_ _s3053_) with
                       | _s3054_ =>
                          (sep_matches_prefix _s3054_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3055_ _)) =>
                                       match (string_drop _s3054_ _s3055_) with
                                       | _s3056_ =>
                                          match (hex_bits_6_matches_prefix _s3056_) with
                                          | Some ((imm, existT _ _s3057_ _)) =>
                                             match (string_drop _s3056_ _s3057_) with
                                             | s_ => Some ((rd, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3039_ (_s3040_ : string) 
: M (option ((mword 6 * string))) :=
   
   let _s3041_ := _s3040_ in
   (if ((string_startswith _s3041_ "c.addi16sp")) then
      (match (string_drop _s3041_ (projT1 (string_length "c.addi16sp"))) with
       | _s3042_ =>
          (spc_matches_prefix _s3042_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s3043_ _)) =>
                       match (string_drop _s3042_ _s3043_) with
                       | _s3044_ =>
                          match (hex_bits_6_matches_prefix _s3044_) with
                          | Some ((imm, existT _ _s3045_ _)) =>
                             match (string_drop _s3044_ _s3045_) with | s_ => Some ((imm, s_)) end
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option ((mword 6 * string)))
       end)
       : M (option ((mword 6 * string)))
    else returnm (None  : option ((mword 6 * string))))
    : M (option ((mword 6 * string))).

Definition _s3027_ (_s3028_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3029_ := _s3028_ in
   (if ((string_startswith _s3029_ "c.li")) then
      (match (string_drop _s3029_ (projT1 (string_length "c.li"))) with
       | _s3030_ =>
          (spc_matches_prefix _s3030_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3031_ _)) =>
              (match (string_drop _s3030_ _s3031_) with
               | _s3032_ =>
                  (reg_name_matches_prefix _s3032_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s3033_ _)) =>
                      (match (string_drop _s3032_ _s3033_) with
                       | _s3034_ =>
                          (sep_matches_prefix _s3034_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3035_ _)) =>
                                       match (string_drop _s3034_ _s3035_) with
                                       | _s3036_ =>
                                          match (hex_bits_6_matches_prefix _s3036_) with
                                          | Some ((imm, existT _ _s3037_ _)) =>
                                             match (string_drop _s3036_ _s3037_) with
                                             | s_ => Some ((rd, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3015_ (_s3016_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s3017_ := _s3016_ in
   (if ((string_startswith _s3017_ "c.addiw")) then
      (match (string_drop _s3017_ (projT1 (string_length "c.addiw"))) with
       | _s3018_ =>
          (spc_matches_prefix _s3018_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s3019_ _)) =>
              (match (string_drop _s3018_ _s3019_) with
               | _s3020_ =>
                  (reg_name_matches_prefix _s3020_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3021_ _)) =>
                      (match (string_drop _s3020_ _s3021_) with
                       | _s3022_ =>
                          (sep_matches_prefix _s3022_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3023_ _)) =>
                                       match (string_drop _s3022_ _s3023_) with
                                       | _s3024_ =>
                                          match (hex_bits_6_matches_prefix _s3024_) with
                                          | Some ((imm, existT _ _s3025_ _)) =>
                                             match (string_drop _s3024_ _s3025_) with
                                             | s_ => Some ((rsd, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s3007_ (_s3008_ : string) 
: M (option ((mword 11 * string))) :=
   
   let _s3009_ := _s3008_ in
   (if ((string_startswith _s3009_ "c.jal")) then
      (match (string_drop _s3009_ (projT1 (string_length "c.jal"))) with
       | _s3010_ =>
          (spc_matches_prefix _s3010_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          returnm ((match w__0 with
                    | Some ((tt, existT _ _s3011_ _)) =>
                       match (string_drop _s3010_ _s3011_) with
                       | _s3012_ =>
                          match (hex_bits_12_matches_prefix _s3012_) with
                          | Some ((v__826, existT _ _s3013_ _)) =>
                             if ((eq_vec (subrange_vec_dec v__826 0 0)
                                    (vec_of_bits [B0]  : mword (0 - 0 + 1)))) then
                               let imm : mword 11 := subrange_vec_dec v__826 11 1 in
                               let imm : mword 11 := subrange_vec_dec v__826 11 1 in
                               match (string_drop _s3012_ _s3013_) with | s_ => Some ((imm, s_)) end
                             else None
                          | _ => None
                          end
                       end
                    | _ => None
                    end)
           : option ((mword 11 * string)))
       end)
       : M (option ((mword 11 * string)))
    else returnm (None  : option ((mword 11 * string))))
    : M (option ((mword 11 * string))).

Definition _s2995_ (_s2996_ : string) 
: M (option ((mword 5 * mword 6 * string))) :=
   
   let _s2997_ := _s2996_ in
   (if ((string_startswith _s2997_ "c.addi")) then
      (match (string_drop _s2997_ (projT1 (string_length "c.addi"))) with
       | _s2998_ =>
          (spc_matches_prefix _s2998_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2999_ _)) =>
              (match (string_drop _s2998_ _s2999_) with
               | _s3000_ =>
                  (reg_name_matches_prefix _s3000_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsd, existT _ _s3001_ _)) =>
                      (match (string_drop _s3000_ _s3001_) with
                       | _s3002_ =>
                          (sep_matches_prefix _s3002_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s3003_ _)) =>
                                       match (string_drop _s3002_ _s3003_) with
                                       | _s3004_ =>
                                          match (hex_bits_6_matches_prefix _s3004_) with
                                          | Some ((nzi, existT _ _s3005_ _)) =>
                                             match (string_drop _s3004_ _s3005_) with
                                             | s_ => Some ((rsd, nzi, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 6 * string)))
                       end)
                       : M (option ((mword 5 * mword 6 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
                   end)
                   : M (option ((mword 5 * mword 6 * string)))
               end)
               : M (option ((mword 5 * mword 6 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 6 * string)))
           end)
           : M (option ((mword 5 * mword 6 * string)))
       end)
       : M (option ((mword 5 * mword 6 * string)))
    else returnm (None  : option ((mword 5 * mword 6 * string))))
    : M (option ((mword 5 * mword 6 * string))).

Definition _s2979_ (_s2980_ : string) 
: M (option ((mword 3 * mword 3 * mword 5 * string))) :=
   
   let _s2981_ := _s2980_ in
   (if ((string_startswith _s2981_ "c.sd")) then
      (match (string_drop _s2981_ (projT1 (string_length "c.sd"))) with
       | _s2982_ =>
          (spc_matches_prefix _s2982_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2983_ _)) =>
              (match (string_drop _s2982_ _s2983_) with
               | _s2984_ =>
                  (creg_name_matches_prefix _s2984_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsc1, existT _ _s2985_ _)) =>
                      (match (string_drop _s2984_ _s2985_) with
                       | _s2986_ =>
                          (sep_matches_prefix _s2986_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2987_ _)) =>
                              (match (string_drop _s2986_ _s2987_) with
                               | _s2988_ =>
                                  (creg_name_matches_prefix _s2988_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc2, existT _ _s2989_ _)) =>
                                      (match (string_drop _s2988_ _s2989_) with
                                       | _s2990_ =>
                                          (sep_matches_prefix _s2990_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2991_ _)) =>
                                                       match (string_drop _s2990_ _s2991_) with
                                                       | _s2992_ =>
                                                          match (hex_bits_8_matches_prefix _s2992_) with
                                                          | Some ((v__828, existT _ _s2993_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__828 2 0)
                                                                    (vec_of_bits [B0;B0;B0]
                                                                      : mword (2 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__828 7 3 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__828 7 3 in
                                                               match (string_drop _s2992_ _s2993_) with
                                                               | s_ => Some ((rsc1, rsc2, uimm, s_))
                                                               end
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 3 * mword 3 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5 * string)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5 * string))))
    : M (option ((mword 3 * mword 3 * mword 5 * string))).

Definition _s2963_ (_s2964_ : string) 
: M (option ((mword 3 * mword 3 * mword 5 * string))) :=
   
   let _s2965_ := _s2964_ in
   (if ((string_startswith _s2965_ "c.sw")) then
      (match (string_drop _s2965_ (projT1 (string_length "c.sw"))) with
       | _s2966_ =>
          (spc_matches_prefix _s2966_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2967_ _)) =>
              (match (string_drop _s2966_ _s2967_) with
               | _s2968_ =>
                  (creg_name_matches_prefix _s2968_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rsc1, existT _ _s2969_ _)) =>
                      (match (string_drop _s2968_ _s2969_) with
                       | _s2970_ =>
                          (sep_matches_prefix _s2970_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2971_ _)) =>
                              (match (string_drop _s2970_ _s2971_) with
                               | _s2972_ =>
                                  (creg_name_matches_prefix _s2972_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc2, existT _ _s2973_ _)) =>
                                      (match (string_drop _s2972_ _s2973_) with
                                       | _s2974_ =>
                                          (sep_matches_prefix _s2974_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2975_ _)) =>
                                                       match (string_drop _s2974_ _s2975_) with
                                                       | _s2976_ =>
                                                          match (hex_bits_7_matches_prefix _s2976_) with
                                                          | Some ((v__830, existT _ _s2977_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__830 1 0)
                                                                    (vec_of_bits [B0;B0]
                                                                      : mword (1 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__830 6 2 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__830 6 2 in
                                                               match (string_drop _s2976_ _s2977_) with
                                                               | s_ => Some ((rsc1, rsc2, uimm, s_))
                                                               end
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 3 * mword 3 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5 * string)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5 * string))))
    : M (option ((mword 3 * mword 3 * mword 5 * string))).

Definition _s2947_ (_s2948_ : string) 
: M (option ((mword 3 * mword 3 * mword 5 * string))) :=
   
   let _s2949_ := _s2948_ in
   (if ((string_startswith _s2949_ "c.ld")) then
      (match (string_drop _s2949_ (projT1 (string_length "c.ld"))) with
       | _s2950_ =>
          (spc_matches_prefix _s2950_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2951_ _)) =>
              (match (string_drop _s2950_ _s2951_) with
               | _s2952_ =>
                  (creg_name_matches_prefix _s2952_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s2953_ _)) =>
                      (match (string_drop _s2952_ _s2953_) with
                       | _s2954_ =>
                          (sep_matches_prefix _s2954_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2955_ _)) =>
                              (match (string_drop _s2954_ _s2955_) with
                               | _s2956_ =>
                                  (creg_name_matches_prefix _s2956_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc, existT _ _s2957_ _)) =>
                                      (match (string_drop _s2956_ _s2957_) with
                                       | _s2958_ =>
                                          (sep_matches_prefix _s2958_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2959_ _)) =>
                                                       match (string_drop _s2958_ _s2959_) with
                                                       | _s2960_ =>
                                                          match (hex_bits_8_matches_prefix _s2960_) with
                                                          | Some ((v__832, existT _ _s2961_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__832 2 0)
                                                                    (vec_of_bits [B0;B0;B0]
                                                                      : mword (2 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__832 7 3 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__832 7 3 in
                                                               match (string_drop _s2960_ _s2961_) with
                                                               | s_ => Some ((rdc, rsc, uimm, s_))
                                                               end
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 3 * mword 3 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5 * string)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5 * string))))
    : M (option ((mword 3 * mword 3 * mword 5 * string))).

Definition _s2931_ (_s2932_ : string) 
: M (option ((mword 3 * mword 3 * mword 5 * string))) :=
   
   let _s2933_ := _s2932_ in
   (if ((string_startswith _s2933_ "c.lw")) then
      (match (string_drop _s2933_ (projT1 (string_length "c.lw"))) with
       | _s2934_ =>
          (spc_matches_prefix _s2934_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2935_ _)) =>
              (match (string_drop _s2934_ _s2935_) with
               | _s2936_ =>
                  (creg_name_matches_prefix _s2936_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s2937_ _)) =>
                      (match (string_drop _s2936_ _s2937_) with
                       | _s2938_ =>
                          (sep_matches_prefix _s2938_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2939_ _)) =>
                              (match (string_drop _s2938_ _s2939_) with
                               | _s2940_ =>
                                  (creg_name_matches_prefix _s2940_) >>= fun w__3 : option ((mword 3 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rsc, existT _ _s2941_ _)) =>
                                      (match (string_drop _s2940_ _s2941_) with
                                       | _s2942_ =>
                                          (sep_matches_prefix _s2942_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2943_ _)) =>
                                                       match (string_drop _s2942_ _s2943_) with
                                                       | _s2944_ =>
                                                          match (hex_bits_7_matches_prefix _s2944_) with
                                                          | Some ((v__834, existT _ _s2945_ _)) =>
                                                             if ((eq_vec
                                                                    (subrange_vec_dec v__834 1 0)
                                                                    (vec_of_bits [B0;B0]
                                                                      : mword (1 - 0 + 1)))) then
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__834 6 2 in
                                                               let uimm : mword 5 :=
                                                                 subrange_vec_dec v__834 6 2 in
                                                               match (string_drop _s2944_ _s2945_) with
                                                               | s_ => Some ((rdc, rsc, uimm, s_))
                                                               end
                                                             else None
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 3 * mword 3 * mword 5 * string)))
                                       end)
                                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 3 * mword 3 * mword 5 * string)))
                                   end)
                                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
                               end)
                               : M (option ((mword 3 * mword 3 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                           end)
                           : M (option ((mword 3 * mword 3 * mword 5 * string)))
                       end)
                       : M (option ((mword 3 * mword 3 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
                   end)
                   : M (option ((mword 3 * mword 3 * mword 5 * string)))
               end)
               : M (option ((mword 3 * mword 3 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 3 * mword 5 * string)))
           end)
           : M (option ((mword 3 * mword 3 * mword 5 * string)))
       end)
       : M (option ((mword 3 * mword 3 * mword 5 * string)))
    else returnm (None  : option ((mword 3 * mword 3 * mword 5 * string))))
    : M (option ((mword 3 * mword 3 * mword 5 * string))).

Definition _s2919_ (_s2920_ : string) 
: M (option ((mword 3 * mword 8 * string))) :=
   
   let _s2921_ := _s2920_ in
   (if ((string_startswith _s2921_ "c.addi4spn")) then
      (match (string_drop _s2921_ (projT1 (string_length "c.addi4spn"))) with
       | _s2922_ =>
          (spc_matches_prefix _s2922_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2923_ _)) =>
              (match (string_drop _s2922_ _s2923_) with
               | _s2924_ =>
                  (creg_name_matches_prefix _s2924_) >>= fun w__1 : option ((mword 3 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rdc, existT _ _s2925_ _)) =>
                      (match (string_drop _s2924_ _s2925_) with
                       | _s2926_ =>
                          (sep_matches_prefix _s2926_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2927_ _)) =>
                                       match (string_drop _s2926_ _s2927_) with
                                       | _s2928_ =>
                                          match (hex_bits_10_matches_prefix _s2928_) with
                                          | Some ((v__836, existT _ _s2929_ _)) =>
                                             if ((eq_vec (subrange_vec_dec v__836 1 0)
                                                    (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))
                                             then
                                               let nzimm : mword 8 := subrange_vec_dec v__836 9 2 in
                                               let nzimm : mword 8 := subrange_vec_dec v__836 9 2 in
                                               match (string_drop _s2928_ _s2929_) with
                                               | s_ => Some ((rdc, nzimm, s_))
                                               end
                                             else None
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 3 * mword 8 * string)))
                       end)
                       : M (option ((mword 3 * mword 8 * string)))
                   | _ => returnm (None  : option ((mword 3 * mword 8 * string)))
                   end)
                   : M (option ((mword 3 * mword 8 * string)))
               end)
               : M (option ((mword 3 * mword 8 * string)))
           | _ => returnm (None  : option ((mword 3 * mword 8 * string)))
           end)
           : M (option ((mword 3 * mword 8 * string)))
       end)
       : M (option ((mword 3 * mword 8 * string)))
    else returnm (None  : option ((mword 3 * mword 8 * string))))
    : M (option ((mword 3 * mword 8 * string))).

Definition _s2915_ (_s2916_ : string) 
: option string :=
   
   let _s2917_ := _s2916_ in
   if ((string_startswith _s2917_ "c.nop")) then
     match (string_drop _s2917_ (projT1 (string_length "c.nop"))) with | s_ => Some (s_) end
   else None.

Definition _s2891_ (_s2892_ : string) 
: M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s2892_ with
    | _s2893_ =>
       (amo_mnemonic_matches_prefix _s2893_) >>= fun w__0 : option ((amoop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2894_ _)) =>
           let _s2895_ := string_drop _s2893_ _s2894_ in
           (if ((string_startswith _s2895_ ".")) then
              (match (string_drop _s2895_ (projT1 (string_length "."))) with
               | _s2896_ =>
                  (size_mnemonic_matches_prefix _s2896_) >>= fun w__1 : option ((word_width * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((width, existT _ _s2897_ _)) =>
                      (match (string_drop _s2896_ _s2897_) with
                       | _s2898_ =>
                          (maybe_aq_matches_prefix _s2898_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((aq, existT _ _s2899_ _)) =>
                              (match (string_drop _s2898_ _s2899_) with
                               | _s2900_ =>
                                  (maybe_rl_matches_prefix _s2900_) >>= fun w__3 : option ((bool * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rl, existT _ _s2901_ _)) =>
                                      (match (string_drop _s2900_ _s2901_) with
                                       | _s2902_ =>
                                          (spc_matches_prefix _s2902_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s2903_ _)) =>
                                              (match (string_drop _s2902_ _s2903_) with
                                               | _s2904_ =>
                                                  (reg_name_matches_prefix _s2904_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((rd, existT _ _s2905_ _)) =>
                                                      (match (string_drop _s2904_ _s2905_) with
                                                       | _s2906_ =>
                                                          (sep_matches_prefix _s2906_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((tt, existT _ _s2907_ _)) =>
                                                              (match (string_drop _s2906_ _s2907_) with
                                                               | _s2908_ =>
                                                                  (reg_name_matches_prefix _s2908_) >>= fun w__7 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__7 with
                                                                   | Some
                                                                     ((rs1, existT _ _s2909_ _)) =>
                                                                      (match (string_drop _s2908_
                                                                                _s2909_) with
                                                                       | _s2910_ =>
                                                                          (sep_matches_prefix
                                                                             _s2910_) >>= fun w__8 : option ((unit * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          (match w__8 with
                                                                           | Some
                                                                             ((tt, existT _ _s2911_ _)) =>
                                                                              (match (string_drop
                                                                                        _s2910_
                                                                                        _s2911_) with
                                                                               | _s2912_ =>
                                                                                  (reg_name_matches_prefix
                                                                                     _s2912_) >>= fun w__9 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                    0)})) =>
                                                                                  returnm ((match w__9 with
                                                                                            | Some
                                                                                              ((rs2, existT _ _s2913_ _)) =>
                                                                                               match (string_drop
                                                                                                        _s2912_
                                                                                                        _s2913_) with
                                                                                               | s_ =>
                                                                                                  Some
                                                                                                    ((op, width, aq, rl, rd, rs1, rs2, s_))
                                                                                               end
                                                                                            | _ =>
                                                                                               None
                                                                                            end)
                                                                                   : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                               end)
                                                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                           | _ =>
                                                                              returnm (None
                                                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                           end)
                                                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                       end)
                                                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                   end)
                                                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                               end)
                                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                           end)
                                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                       end)
                                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                   end)
                                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                           | _ =>
                              returnm (None
                               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                   | _ =>
                      returnm (None
                       : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
            else
              returnm (None
               : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string))))
            : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
        | _ =>
           returnm (None
            : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string))).

Definition _s2869_ (_s2870_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string))) :=
   
   let _s2871_ := _s2870_ in
   (if ((string_startswith _s2871_ "sc.")) then
      (match (string_drop _s2871_ (projT1 (string_length "sc."))) with
       | _s2872_ =>
          (size_mnemonic_matches_prefix _s2872_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s2873_ _)) =>
              (match (string_drop _s2872_ _s2873_) with
               | _s2874_ =>
                  (maybe_aq_matches_prefix _s2874_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s2875_ _)) =>
                      (match (string_drop _s2874_ _s2875_) with
                       | _s2876_ =>
                          (maybe_rl_matches_prefix _s2876_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s2877_ _)) =>
                              (match (string_drop _s2876_ _s2877_) with
                               | _s2878_ =>
                                  (spc_matches_prefix _s2878_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s2879_ _)) =>
                                      (match (string_drop _s2878_ _s2879_) with
                                       | _s2880_ =>
                                          (reg_name_matches_prefix _s2880_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rd, existT _ _s2881_ _)) =>
                                              (match (string_drop _s2880_ _s2881_) with
                                               | _s2882_ =>
                                                  (sep_matches_prefix _s2882_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s2883_ _)) =>
                                                      (match (string_drop _s2882_ _s2883_) with
                                                       | _s2884_ =>
                                                          (reg_name_matches_prefix _s2884_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((rs1, existT _ _s2885_ _)) =>
                                                              (match (string_drop _s2884_ _s2885_) with
                                                               | _s2886_ =>
                                                                  (sep_matches_prefix _s2886_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__7 with
                                                                   | Some ((tt, existT _ _s2887_ _)) =>
                                                                      (match (string_drop _s2886_
                                                                                _s2887_) with
                                                                       | _s2888_ =>
                                                                          (reg_name_matches_prefix
                                                                             _s2888_) >>= fun w__8 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          returnm ((match w__8 with
                                                                                    | Some
                                                                                      ((rs2, existT _ _s2889_ _)) =>
                                                                                       match (string_drop
                                                                                                _s2888_
                                                                                                _s2889_) with
                                                                                       | s_ =>
                                                                                          Some
                                                                                            ((size, aq, rl, rd, rs1, rs2, s_))
                                                                                       end
                                                                                    | _ => None
                                                                                    end)
                                                                           : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                       end)
                                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
           | _ =>
              returnm (None
               : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)))
    else
      returnm (None
       : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string))))
    : M (option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string))).

Definition _s2851_ (_s2852_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 5 * string))) :=
   
   let _s2853_ := _s2852_ in
   (if ((string_startswith _s2853_ "lr.")) then
      (match (string_drop _s2853_ (projT1 (string_length "lr."))) with
       | _s2854_ =>
          (size_mnemonic_matches_prefix _s2854_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s2855_ _)) =>
              (match (string_drop _s2854_ _s2855_) with
               | _s2856_ =>
                  (maybe_aq_matches_prefix _s2856_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s2857_ _)) =>
                      (match (string_drop _s2856_ _s2857_) with
                       | _s2858_ =>
                          (maybe_rl_matches_prefix _s2858_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s2859_ _)) =>
                              (match (string_drop _s2858_ _s2859_) with
                               | _s2860_ =>
                                  (spc_matches_prefix _s2860_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s2861_ _)) =>
                                      (match (string_drop _s2860_ _s2861_) with
                                       | _s2862_ =>
                                          (reg_name_matches_prefix _s2862_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rd, existT _ _s2863_ _)) =>
                                              (match (string_drop _s2862_ _s2863_) with
                                               | _s2864_ =>
                                                  (sep_matches_prefix _s2864_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s2865_ _)) =>
                                                      (match (string_drop _s2864_ _s2865_) with
                                                       | _s2866_ =>
                                                          (reg_name_matches_prefix _s2866_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          returnm ((match w__6 with
                                                                    | Some
                                                                      ((rs1, existT _ _s2867_ _)) =>
                                                                       match (string_drop _s2866_
                                                                                _s2867_) with
                                                                       | s_ =>
                                                                          Some
                                                                            ((size, aq, rl, rd, rs1, s_))
                                                                       end
                                                                    | _ => None
                                                                    end)
                                                           : option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * mword 5 * mword 5 * string)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5 * string)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 5 * string)))
    else returnm (None  : option ((word_width * bool * bool * mword 5 * mword 5 * string))))
    : M (option ((word_width * bool * bool * mword 5 * mword 5 * string))).

Definition _s2839_ (_s2840_ : string) 
: M (option ((mword 5 * mword 5 * string))) :=
   
   let _s2841_ := _s2840_ in
   (if ((string_startswith _s2841_ "sfence.vma")) then
      (match (string_drop _s2841_ (projT1 (string_length "sfence.vma"))) with
       | _s2842_ =>
          (spc_matches_prefix _s2842_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2843_ _)) =>
              (match (string_drop _s2842_ _s2843_) with
               | _s2844_ =>
                  (reg_name_matches_prefix _s2844_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rs1, existT _ _s2845_ _)) =>
                      (match (string_drop _s2844_ _s2845_) with
                       | _s2846_ =>
                          (sep_matches_prefix _s2846_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2847_ _)) =>
                              (match (string_drop _s2846_ _s2847_) with
                               | _s2848_ =>
                                  (reg_name_matches_prefix _s2848_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((rs2, existT _ _s2849_ _)) =>
                                               match (string_drop _s2848_ _s2849_) with
                                               | s_ => Some ((rs1, rs2, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 5 * mword 5 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * string)))
               end)
               : M (option ((mword 5 * mword 5 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * string)))
           end)
           : M (option ((mword 5 * mword 5 * string)))
       end)
       : M (option ((mword 5 * mword 5 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * string))))
    : M (option ((mword 5 * mword 5 * string))).

Definition _s2835_ (_s2836_ : string) 
: option string :=
   
   let _s2837_ := _s2836_ in
   if ((string_startswith _s2837_ "wfi")) then
     match (string_drop _s2837_ (projT1 (string_length "wfi"))) with | s_ => Some (s_) end
   else None.

Definition _s2831_ (_s2832_ : string) 
: option string :=
   
   let _s2833_ := _s2832_ in
   if ((string_startswith _s2833_ "ebreak")) then
     match (string_drop _s2833_ (projT1 (string_length "ebreak"))) with | s_ => Some (s_) end
   else None.

Definition _s2827_ (_s2828_ : string) 
: option string :=
   
   let _s2829_ := _s2828_ in
   if ((string_startswith _s2829_ "sret")) then
     match (string_drop _s2829_ (projT1 (string_length "sret"))) with | s_ => Some (s_) end
   else None.

Definition _s2823_ (_s2824_ : string) 
: option string :=
   
   let _s2825_ := _s2824_ in
   if ((string_startswith _s2825_ "mret")) then
     match (string_drop _s2825_ (projT1 (string_length "mret"))) with | s_ => Some (s_) end
   else None.

Definition _s2819_ (_s2820_ : string) 
: option string :=
   
   let _s2821_ := _s2820_ in
   if ((string_startswith _s2821_ "ecall")) then
     match (string_drop _s2821_ (projT1 (string_length "ecall"))) with | s_ => Some (s_) end
   else None.

Definition _s2815_ (_s2816_ : string) 
: option string :=
   
   let _s2817_ := _s2816_ in
   if ((string_startswith _s2817_ "fence.i")) then
     match (string_drop _s2817_ (projT1 (string_length "fence.i"))) with | s_ => Some (s_) end
   else None.

Definition _s2803_ (_s2804_ : string) 
: M (option ((mword 4 * mword 4 * string))) :=
   
   let _s2805_ := _s2804_ in
   (if ((string_startswith _s2805_ "fence.tso")) then
      (match (string_drop _s2805_ (projT1 (string_length "fence.tso"))) with
       | _s2806_ =>
          (spc_matches_prefix _s2806_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2807_ _)) =>
              (match (string_drop _s2806_ _s2807_) with
               | _s2808_ =>
                  (fence_bits_matches_prefix _s2808_) >>= fun w__1 : option ((mword 4 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((pred, existT _ _s2809_ _)) =>
                      (match (string_drop _s2808_ _s2809_) with
                       | _s2810_ =>
                          (sep_matches_prefix _s2810_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2811_ _)) =>
                              (match (string_drop _s2810_ _s2811_) with
                               | _s2812_ =>
                                  (fence_bits_matches_prefix _s2812_) >>= fun w__3 : option ((mword 4 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((succ, existT _ _s2813_ _)) =>
                                               match (string_drop _s2812_ _s2813_) with
                                               | s_ => Some ((pred, succ, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 4 * mword 4 * string)))
                               end)
                               : M (option ((mword 4 * mword 4 * string)))
                           | _ => returnm (None  : option ((mword 4 * mword 4 * string)))
                           end)
                           : M (option ((mword 4 * mword 4 * string)))
                       end)
                       : M (option ((mword 4 * mword 4 * string)))
                   | _ => returnm (None  : option ((mword 4 * mword 4 * string)))
                   end)
                   : M (option ((mword 4 * mword 4 * string)))
               end)
               : M (option ((mword 4 * mword 4 * string)))
           | _ => returnm (None  : option ((mword 4 * mword 4 * string)))
           end)
           : M (option ((mword 4 * mword 4 * string)))
       end)
       : M (option ((mword 4 * mword 4 * string)))
    else returnm (None  : option ((mword 4 * mword 4 * string))))
    : M (option ((mword 4 * mword 4 * string))).

Definition _s2791_ (_s2792_ : string) 
: M (option ((mword 4 * mword 4 * string))) :=
   
   let _s2793_ := _s2792_ in
   (if ((string_startswith _s2793_ "fence")) then
      (match (string_drop _s2793_ (projT1 (string_length "fence"))) with
       | _s2794_ =>
          (spc_matches_prefix _s2794_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2795_ _)) =>
              (match (string_drop _s2794_ _s2795_) with
               | _s2796_ =>
                  (fence_bits_matches_prefix _s2796_) >>= fun w__1 : option ((mword 4 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((pred, existT _ _s2797_ _)) =>
                      (match (string_drop _s2796_ _s2797_) with
                       | _s2798_ =>
                          (sep_matches_prefix _s2798_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2799_ _)) =>
                              (match (string_drop _s2798_ _s2799_) with
                               | _s2800_ =>
                                  (fence_bits_matches_prefix _s2800_) >>= fun w__3 : option ((mword 4 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  returnm ((match w__3 with
                                            | Some ((succ, existT _ _s2801_ _)) =>
                                               match (string_drop _s2800_ _s2801_) with
                                               | s_ => Some ((pred, succ, s_))
                                               end
                                            | _ => None
                                            end)
                                   : option ((mword 4 * mword 4 * string)))
                               end)
                               : M (option ((mword 4 * mword 4 * string)))
                           | _ => returnm (None  : option ((mword 4 * mword 4 * string)))
                           end)
                           : M (option ((mword 4 * mword 4 * string)))
                       end)
                       : M (option ((mword 4 * mword 4 * string)))
                   | _ => returnm (None  : option ((mword 4 * mword 4 * string)))
                   end)
                   : M (option ((mword 4 * mword 4 * string)))
               end)
               : M (option ((mword 4 * mword 4 * string)))
           | _ => returnm (None  : option ((mword 4 * mword 4 * string)))
           end)
           : M (option ((mword 4 * mword 4 * string)))
       end)
       : M (option ((mword 4 * mword 4 * string)))
    else returnm (None  : option ((mword 4 * mword 4 * string))))
    : M (option ((mword 4 * mword 4 * string))).

Definition _s2774_ (_s2775_ : string) 
: M (option ((sopw * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s2775_ with
    | _s2776_ =>
       (shiftiwop_mnemonic_matches_prefix _s2776_) >>= fun w__0 : option ((sopw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2777_ _)) =>
           (match (string_drop _s2776_ _s2777_) with
            | _s2778_ =>
               (spc_matches_prefix _s2778_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2779_ _)) =>
                   (match (string_drop _s2778_ _s2779_) with
                    | _s2780_ =>
                       (reg_name_matches_prefix _s2780_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2781_ _)) =>
                           (match (string_drop _s2780_ _s2781_) with
                            | _s2782_ =>
                               (sep_matches_prefix _s2782_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2783_ _)) =>
                                   (match (string_drop _s2782_ _s2783_) with
                                    | _s2784_ =>
                                       (reg_name_matches_prefix _s2784_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2785_ _)) =>
                                           (match (string_drop _s2784_ _s2785_) with
                                            | _s2786_ =>
                                               (sep_matches_prefix _s2786_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s2787_ _)) =>
                                                            match (string_drop _s2786_ _s2787_) with
                                                            | _s2788_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s2788_) with
                                                               | Some ((shamt, existT _ _s2789_ _)) =>
                                                                  match (string_drop _s2788_ _s2789_) with
                                                                  | s_ =>
                                                                     Some ((op, rd, rs1, shamt, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((sopw * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((sopw * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((sopw * mword 5 * mword 5 * mword 5 * string))).

Definition _s2757_ (_s2758_ : string) 
: M (option ((ropw * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s2758_ with
    | _s2759_ =>
       (rtypew_mnemonic_matches_prefix _s2759_) >>= fun w__0 : option ((ropw * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2760_ _)) =>
           (match (string_drop _s2759_ _s2760_) with
            | _s2761_ =>
               (spc_matches_prefix _s2761_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2762_ _)) =>
                   (match (string_drop _s2761_ _s2762_) with
                    | _s2763_ =>
                       (reg_name_matches_prefix _s2763_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2764_ _)) =>
                           (match (string_drop _s2763_ _s2764_) with
                            | _s2765_ =>
                               (sep_matches_prefix _s2765_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2766_ _)) =>
                                   (match (string_drop _s2765_ _s2766_) with
                                    | _s2767_ =>
                                       (reg_name_matches_prefix _s2767_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2768_ _)) =>
                                           (match (string_drop _s2767_ _s2768_) with
                                            | _s2769_ =>
                                               (sep_matches_prefix _s2769_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s2770_ _)) =>
                                                   (match (string_drop _s2769_ _s2770_) with
                                                    | _s2771_ =>
                                                       (reg_name_matches_prefix _s2771_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s2772_ _)) =>
                                                                    match (string_drop _s2771_
                                                                             _s2772_) with
                                                                    | s_ =>
                                                                       Some ((op, rd, rs1, rs2, s_))
                                                                    end
                                                                 | _ => None
                                                                 end)
                                                        : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                                    end)
                                                    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                                end)
                                                : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((ropw * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((ropw * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((ropw * mword 5 * mword 5 * mword 5 * string))).

Definition _s2740_ (_s2741_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s2741_ with
    | _s2742_ =>
       (shiftw_mnemonic_matches_prefix _s2742_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2743_ _)) =>
           (match (string_drop _s2742_ _s2743_) with
            | _s2744_ =>
               (spc_matches_prefix _s2744_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2745_ _)) =>
                   (match (string_drop _s2744_ _s2745_) with
                    | _s2746_ =>
                       (reg_name_matches_prefix _s2746_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2747_ _)) =>
                           (match (string_drop _s2746_ _s2747_) with
                            | _s2748_ =>
                               (sep_matches_prefix _s2748_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2749_ _)) =>
                                   (match (string_drop _s2748_ _s2749_) with
                                    | _s2750_ =>
                                       (reg_name_matches_prefix _s2750_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2751_ _)) =>
                                           (match (string_drop _s2750_ _s2751_) with
                                            | _s2752_ =>
                                               (sep_matches_prefix _s2752_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s2753_ _)) =>
                                                            match (string_drop _s2752_ _s2753_) with
                                                            | _s2754_ =>
                                                               match (hex_bits_5_matches_prefix
                                                                        _s2754_) with
                                                               | Some ((shamt, existT _ _s2755_ _)) =>
                                                                  match (string_drop _s2754_ _s2755_) with
                                                                  | s_ =>
                                                                     Some ((op, rd, rs1, shamt, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 5 * string))).

Definition _s2724_ (_s2725_ : string) 
: M (option ((mword 5 * mword 5 * mword 12 * string))) :=
   
   let _s2726_ := _s2725_ in
   (if ((string_startswith _s2726_ "addiw")) then
      (match (string_drop _s2726_ (projT1 (string_length "addiw"))) with
       | _s2727_ =>
          (spc_matches_prefix _s2727_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2728_ _)) =>
              (match (string_drop _s2727_ _s2728_) with
               | _s2729_ =>
                  (reg_name_matches_prefix _s2729_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2730_ _)) =>
                      (match (string_drop _s2729_ _s2730_) with
                       | _s2731_ =>
                          (sep_matches_prefix _s2731_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2732_ _)) =>
                              (match (string_drop _s2731_ _s2732_) with
                               | _s2733_ =>
                                  (reg_name_matches_prefix _s2733_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s2734_ _)) =>
                                      (match (string_drop _s2733_ _s2734_) with
                                       | _s2735_ =>
                                          (sep_matches_prefix _s2735_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2736_ _)) =>
                                                       match (string_drop _s2735_ _s2736_) with
                                                       | _s2737_ =>
                                                          match (hex_bits_12_matches_prefix _s2737_) with
                                                          | Some ((imm, existT _ _s2738_ _)) =>
                                                             match (string_drop _s2737_ _s2738_) with
                                                             | s_ => Some ((rd, rs1, imm, s_))
                                                             end
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 12 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12 * string))))
    : M (option ((mword 5 * mword 5 * mword 12 * string))).

Definition _s2696_ (_s2697_ : string) 
: M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string))) :=
   
   let _s2698_ := _s2697_ in
   (if ((string_startswith _s2698_ "s")) then
      (match (string_drop _s2698_ (projT1 (string_length "s"))) with
       | _s2699_ =>
          (size_mnemonic_matches_prefix _s2699_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s2700_ _)) =>
              (match (string_drop _s2699_ _s2700_) with
               | _s2701_ =>
                  (maybe_aq_matches_prefix _s2701_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((aq, existT _ _s2702_ _)) =>
                      (match (string_drop _s2701_ _s2702_) with
                       | _s2703_ =>
                          (maybe_rl_matches_prefix _s2703_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((rl, existT _ _s2704_ _)) =>
                              (match (string_drop _s2703_ _s2704_) with
                               | _s2705_ =>
                                  (spc_matches_prefix _s2705_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((tt, existT _ _s2706_ _)) =>
                                      (match (string_drop _s2705_ _s2706_) with
                                       | _s2707_ =>
                                          (reg_name_matches_prefix _s2707_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((rs2, existT _ _s2708_ _)) =>
                                              (match (string_drop _s2707_ _s2708_) with
                                               | _s2709_ =>
                                                  (sep_matches_prefix _s2709_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((tt, existT _ _s2710_ _)) =>
                                                      (match (string_drop _s2709_ _s2710_) with
                                                       | _s2711_ =>
                                                          (match (hex_bits_12_matches_prefix _s2711_) with
                                                           | Some ((imm, existT _ _s2712_ _)) =>
                                                              (match (string_drop _s2711_ _s2712_) with
                                                               | _s2713_ =>
                                                                  (opt_spc_matches_prefix _s2713_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                                    0)})) =>
                                                                  (match w__6 with
                                                                   | Some ((tt, existT _ _s2714_ _)) =>
                                                                      let _s2715_ :=
                                                                        string_drop _s2713_ _s2714_ in
                                                                      (if ((string_startswith
                                                                              _s2715_ "(")) then
                                                                         (match (string_drop _s2715_
                                                                                   (projT1
                                                                                    (string_length
                                                                                       "("))) with
                                                                          | _s2716_ =>
                                                                             (opt_spc_matches_prefix
                                                                                _s2716_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                               0)})) =>
                                                                             (match w__7 with
                                                                              | Some
                                                                                ((tt, existT _ _s2717_ _)) =>
                                                                                 (match (string_drop
                                                                                           _s2716_
                                                                                           _s2717_) with
                                                                                  | _s2718_ =>
                                                                                     (reg_name_matches_prefix
                                                                                        _s2718_) >>= fun w__8 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                       0)})) =>
                                                                                     (match w__8 with
                                                                                      | Some
                                                                                        ((rs1, existT _ _s2719_ _)) =>
                                                                                         (match (string_drop
                                                                                                   _s2718_
                                                                                                   _s2719_) with
                                                                                          | _s2720_ =>
                                                                                             (opt_spc_matches_prefix
                                                                                                _s2720_) >>= fun w__9 : option ((unit * {n : Z & ArithFact (n >=
                                                                                               0)})) =>
                                                                                             returnm ((match w__9 with
                                                                                                       | Some
                                                                                                         ((tt, existT _ _s2721_ _)) =>
                                                                                                          let _s2722_ :=
                                                                                                            string_drop
                                                                                                              _s2720_
                                                                                                              _s2721_ in
                                                                                                          if
                                                                                                            ((string_startswith
                                                                                                                _s2722_
                                                                                                                ")"))
                                                                                                          then
                                                                                                            match (string_drop
                                                                                                                     _s2722_
                                                                                                                     (projT1
                                                                                                                      (string_length
                                                                                                                         ")"))) with
                                                                                                            | s_ =>
                                                                                                               Some
                                                                                                                 ((size, aq, rl, rs2, imm, rs1, s_))
                                                                                                            end
                                                                                                          else
                                                                                                            None
                                                                                                       | _ =>
                                                                                                          None
                                                                                                       end)
                                                                                              : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                          end)
                                                                                          : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                      | _ =>
                                                                                         returnm (None
                                                                                          : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                      end)
                                                                                      : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                  end)
                                                                                  : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                              | _ =>
                                                                                 returnm (None
                                                                                  : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                              end)
                                                                              : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                          end)
                                                                          : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                       else
                                                                         returnm (None
                                                                          : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string))))
                                                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                               end)
                                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                           end)
                                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                       end)
                                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                   end)
                                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                               end)
                               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                           end)
                           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                       end)
                       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                   end)
                   : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
               end)
               : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
           | _ =>
              returnm (None
               : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
           end)
           : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
       end)
       : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)))
    else
      returnm (None
       : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string))))
    : M (option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string))).

Definition _s2666_ (_s2667_ : string) 
: M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string))) :=
   
   let _s2668_ := _s2667_ in
   (if ((string_startswith _s2668_ "l")) then
      (match (string_drop _s2668_ (projT1 (string_length "l"))) with
       | _s2669_ =>
          (size_mnemonic_matches_prefix _s2669_) >>= fun w__0 : option ((word_width * {n : Z & ArithFact (n >=
            0)})) =>
          (match w__0 with
           | Some ((size, existT _ _s2670_ _)) =>
              (match (string_drop _s2669_ _s2670_) with
               | _s2671_ =>
                  (maybe_u_matches_prefix _s2671_) >>= fun w__1 : option ((bool * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((is_unsigned, existT _ _s2672_ _)) =>
                      (match (string_drop _s2671_ _s2672_) with
                       | _s2673_ =>
                          (maybe_aq_matches_prefix _s2673_) >>= fun w__2 : option ((bool * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((aq, existT _ _s2674_ _)) =>
                              (match (string_drop _s2673_ _s2674_) with
                               | _s2675_ =>
                                  (maybe_rl_matches_prefix _s2675_) >>= fun w__3 : option ((bool * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rl, existT _ _s2676_ _)) =>
                                      (match (string_drop _s2675_ _s2676_) with
                                       | _s2677_ =>
                                          (spc_matches_prefix _s2677_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          (match w__4 with
                                           | Some ((tt, existT _ _s2678_ _)) =>
                                              (match (string_drop _s2677_ _s2678_) with
                                               | _s2679_ =>
                                                  (reg_name_matches_prefix _s2679_) >>= fun w__5 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                    0)})) =>
                                                  (match w__5 with
                                                   | Some ((rd, existT _ _s2680_ _)) =>
                                                      (match (string_drop _s2679_ _s2680_) with
                                                       | _s2681_ =>
                                                          (sep_matches_prefix _s2681_) >>= fun w__6 : option ((unit * {n : Z & ArithFact (n >=
                                                            0)})) =>
                                                          (match w__6 with
                                                           | Some ((tt, existT _ _s2682_ _)) =>
                                                              (match (string_drop _s2681_ _s2682_) with
                                                               | _s2683_ =>
                                                                  (match (hex_bits_12_matches_prefix
                                                                            _s2683_) with
                                                                   | Some
                                                                     ((imm, existT _ _s2684_ _)) =>
                                                                      (match (string_drop _s2683_
                                                                                _s2684_) with
                                                                       | _s2685_ =>
                                                                          (opt_spc_matches_prefix
                                                                             _s2685_) >>= fun w__7 : option ((unit * {n : Z & ArithFact (n >=
                                                                            0)})) =>
                                                                          (match w__7 with
                                                                           | Some
                                                                             ((tt, existT _ _s2686_ _)) =>
                                                                              let _s2687_ :=
                                                                                string_drop _s2685_
                                                                                  _s2686_ in
                                                                              (if ((string_startswith
                                                                                      _s2687_ "("))
                                                                               then
                                                                                 (match (string_drop
                                                                                           _s2687_
                                                                                           (projT1
                                                                                            (string_length
                                                                                               "("))) with
                                                                                  | _s2688_ =>
                                                                                     (opt_spc_matches_prefix
                                                                                        _s2688_) >>= fun w__8 : option ((unit * {n : Z & ArithFact (n >=
                                                                                       0)})) =>
                                                                                     (match w__8 with
                                                                                      | Some
                                                                                        ((tt, existT _ _s2689_ _)) =>
                                                                                         (match (string_drop
                                                                                                   _s2688_
                                                                                                   _s2689_) with
                                                                                          | _s2690_ =>
                                                                                             (reg_name_matches_prefix
                                                                                                _s2690_) >>= fun w__9 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                                                               0)})) =>
                                                                                             (match w__9 with
                                                                                              | Some
                                                                                                ((rs1, existT _ _s2691_ _)) =>
                                                                                                 (match (string_drop
                                                                                                           _s2690_
                                                                                                           _s2691_) with
                                                                                                  | _s2692_ =>
                                                                                                     (opt_spc_matches_prefix
                                                                                                        _s2692_) >>= fun w__10 : option ((unit * {n : Z & ArithFact (n >=
                                                                                                       0)})) =>
                                                                                                     returnm ((match w__10 with
                                                                                                               | Some
                                                                                                                 ((tt, existT _ _s2693_ _)) =>
                                                                                                                  let _s2694_ :=
                                                                                                                    string_drop
                                                                                                                      _s2692_
                                                                                                                      _s2693_ in
                                                                                                                  if
                                                                                                                    ((string_startswith
                                                                                                                        _s2694_
                                                                                                                        ")"))
                                                                                                                  then
                                                                                                                    match (string_drop
                                                                                                                             _s2694_
                                                                                                                             (projT1
                                                                                                                              (string_length
                                                                                                                                 ")"))) with
                                                                                                                    | s_ =>
                                                                                                                       Some
                                                                                                                         ((size, is_unsigned, aq, rl, rd, imm, rs1, s_))
                                                                                                                    end
                                                                                                                  else
                                                                                                                    None
                                                                                                               | _ =>
                                                                                                                  None
                                                                                                               end)
                                                                                                      : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                                  end)
                                                                                                  : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                              | _ =>
                                                                                                 returnm (None
                                                                                                  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                              end)
                                                                                              : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                          end)
                                                                                          : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                      | _ =>
                                                                                         returnm (None
                                                                                          : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                      end)
                                                                                      : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                                  end)
                                                                                  : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                               else
                                                                                 returnm (None
                                                                                  : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string))))
                                                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                           | _ =>
                                                                              returnm (None
                                                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                           end)
                                                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                       end)
                                                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                   | _ =>
                                                                      returnm (None
                                                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                                   end)
                                                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                               end)
                                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                           | _ =>
                                                              returnm (None
                                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                           end)
                                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                       end)
                                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                   | _ =>
                                                      returnm (None
                                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                                   end)
                                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                               end)
                                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                           | _ =>
                                              returnm (None
                                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                           end)
                                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                       end)
                                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                                   end)
                                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                               end)
                               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                           | _ =>
                              returnm (None
                               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                           end)
                           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                       end)
                       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                   | _ =>
                      returnm (None
                       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
                   end)
                   : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
               end)
               : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
           | _ =>
              returnm (None
               : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
           end)
           : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
       end)
       : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)))
    else
      returnm (None
       : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string))))
    : M (option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string))).

Definition _s2649_ (_s2650_ : string) 
: M (option ((rop * mword 5 * mword 5 * mword 5 * string))) :=
   
   (match _s2650_ with
    | _s2651_ =>
       (rtype_mnemonic_matches_prefix _s2651_) >>= fun w__0 : option ((rop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2652_ _)) =>
           (match (string_drop _s2651_ _s2652_) with
            | _s2653_ =>
               (spc_matches_prefix _s2653_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2654_ _)) =>
                   (match (string_drop _s2653_ _s2654_) with
                    | _s2655_ =>
                       (reg_name_matches_prefix _s2655_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2656_ _)) =>
                           (match (string_drop _s2655_ _s2656_) with
                            | _s2657_ =>
                               (sep_matches_prefix _s2657_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2658_ _)) =>
                                   (match (string_drop _s2657_ _s2658_) with
                                    | _s2659_ =>
                                       (reg_name_matches_prefix _s2659_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2660_ _)) =>
                                           (match (string_drop _s2659_ _s2660_) with
                                            | _s2661_ =>
                                               (sep_matches_prefix _s2661_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               (match w__5 with
                                                | Some ((tt, existT _ _s2662_ _)) =>
                                                   (match (string_drop _s2661_ _s2662_) with
                                                    | _s2663_ =>
                                                       (reg_name_matches_prefix _s2663_) >>= fun w__6 : option ((mword 5 * {n : Z & ArithFact (n >=
                                                         0)})) =>
                                                       returnm ((match w__6 with
                                                                 | Some ((rs2, existT _ _s2664_ _)) =>
                                                                    match (string_drop _s2663_
                                                                             _s2664_) with
                                                                    | s_ =>
                                                                       Some ((op, rd, rs1, rs2, s_))
                                                                    end
                                                                 | _ => None
                                                                 end)
                                                        : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                                    end)
                                                    : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                                | _ =>
                                                   returnm (None
                                                    : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                                end)
                                                : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                            end)
                                            : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                        end)
                                        : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                    end)
                                    : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                                end)
                                : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                            end)
                            : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                        | _ =>
                           returnm (None  : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                        end)
                        : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                    end)
                    : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
                | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5 * string)))
                end)
                : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
            end)
            : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
        | _ => returnm (None  : option ((rop * mword 5 * mword 5 * mword 5 * string)))
        end)
        : M (option ((rop * mword 5 * mword 5 * mword 5 * string)))
    end)
    : M (option ((rop * mword 5 * mword 5 * mword 5 * string))).

Definition _s2632_ (_s2633_ : string) 
: M (option ((sop * mword 5 * mword 5 * mword 6 * string))) :=
   
   (match _s2633_ with
    | _s2634_ =>
       (shiftiop_mnemonic_matches_prefix _s2634_) >>= fun w__0 : option ((sop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2635_ _)) =>
           (match (string_drop _s2634_ _s2635_) with
            | _s2636_ =>
               (spc_matches_prefix _s2636_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2637_ _)) =>
                   (match (string_drop _s2636_ _s2637_) with
                    | _s2638_ =>
                       (reg_name_matches_prefix _s2638_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2639_ _)) =>
                           (match (string_drop _s2638_ _s2639_) with
                            | _s2640_ =>
                               (sep_matches_prefix _s2640_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2641_ _)) =>
                                   (match (string_drop _s2640_ _s2641_) with
                                    | _s2642_ =>
                                       (reg_name_matches_prefix _s2642_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2643_ _)) =>
                                           (match (string_drop _s2642_ _s2643_) with
                                            | _s2644_ =>
                                               (sep_matches_prefix _s2644_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s2645_ _)) =>
                                                            match (string_drop _s2644_ _s2645_) with
                                                            | _s2646_ =>
                                                               match (hex_bits_6_matches_prefix
                                                                        _s2646_) with
                                                               | Some ((shamt, existT _ _s2647_ _)) =>
                                                                  match (string_drop _s2646_ _s2647_) with
                                                                  | s_ =>
                                                                     Some ((op, rd, rs1, shamt, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                            end)
                                            : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                        end)
                                        : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                    end)
                                    : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                                end)
                                : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                            end)
                            : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                        | _ =>
                           returnm (None  : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                        end)
                        : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                    end)
                    : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
                | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6 * string)))
                end)
                : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
            end)
            : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
        | _ => returnm (None  : option ((sop * mword 5 * mword 5 * mword 6 * string)))
        end)
        : M (option ((sop * mword 5 * mword 5 * mword 6 * string)))
    end)
    : M (option ((sop * mword 5 * mword 5 * mword 6 * string))).

Definition _s2615_ (_s2616_ : string) 
: M (option ((iop * mword 5 * mword 5 * mword 12 * string))) :=
   
   (match _s2616_ with
    | _s2617_ =>
       (itype_mnemonic_matches_prefix _s2617_) >>= fun w__0 : option ((iop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2618_ _)) =>
           (match (string_drop _s2617_ _s2618_) with
            | _s2619_ =>
               (spc_matches_prefix _s2619_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2620_ _)) =>
                   (match (string_drop _s2619_ _s2620_) with
                    | _s2621_ =>
                       (reg_name_matches_prefix _s2621_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2622_ _)) =>
                           (match (string_drop _s2621_ _s2622_) with
                            | _s2623_ =>
                               (sep_matches_prefix _s2623_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2624_ _)) =>
                                   (match (string_drop _s2623_ _s2624_) with
                                    | _s2625_ =>
                                       (reg_name_matches_prefix _s2625_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs1, existT _ _s2626_ _)) =>
                                           (match (string_drop _s2625_ _s2626_) with
                                            | _s2627_ =>
                                               (sep_matches_prefix _s2627_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s2628_ _)) =>
                                                            match (string_drop _s2627_ _s2628_) with
                                                            | _s2629_ =>
                                                               match (hex_bits_12_matches_prefix
                                                                        _s2629_) with
                                                               | Some ((imm, existT _ _s2630_ _)) =>
                                                                  match (string_drop _s2629_ _s2630_) with
                                                                  | s_ =>
                                                                     Some ((op, rd, rs1, imm, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                            end)
                                            : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                        end)
                                        : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                    end)
                                    : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                                end)
                                : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                            end)
                            : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                        | _ =>
                           returnm (None  : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                        end)
                        : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                    end)
                    : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
                | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12 * string)))
                end)
                : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
            end)
            : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
        | _ => returnm (None  : option ((iop * mword 5 * mword 5 * mword 12 * string)))
        end)
        : M (option ((iop * mword 5 * mword 5 * mword 12 * string)))
    end)
    : M (option ((iop * mword 5 * mword 5 * mword 12 * string))).

Definition _s2598_ (_s2599_ : string) 
: M (option ((bop * mword 5 * mword 5 * mword 13 * string))) :=
   
   (match _s2599_ with
    | _s2600_ =>
       (btype_mnemonic_matches_prefix _s2600_) >>= fun w__0 : option ((bop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2601_ _)) =>
           (match (string_drop _s2600_ _s2601_) with
            | _s2602_ =>
               (spc_matches_prefix _s2602_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2603_ _)) =>
                   (match (string_drop _s2602_ _s2603_) with
                    | _s2604_ =>
                       (reg_name_matches_prefix _s2604_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rs1, existT _ _s2605_ _)) =>
                           (match (string_drop _s2604_ _s2605_) with
                            | _s2606_ =>
                               (sep_matches_prefix _s2606_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               (match w__3 with
                                | Some ((tt, existT _ _s2607_ _)) =>
                                   (match (string_drop _s2606_ _s2607_) with
                                    | _s2608_ =>
                                       (reg_name_matches_prefix _s2608_) >>= fun w__4 : option ((mword 5 * {n : Z & ArithFact (n >=
                                         0)})) =>
                                       (match w__4 with
                                        | Some ((rs2, existT _ _s2609_ _)) =>
                                           (match (string_drop _s2608_ _s2609_) with
                                            | _s2610_ =>
                                               (sep_matches_prefix _s2610_) >>= fun w__5 : option ((unit * {n : Z & ArithFact (n >=
                                                 0)})) =>
                                               returnm ((match w__5 with
                                                         | Some ((tt, existT _ _s2611_ _)) =>
                                                            match (string_drop _s2610_ _s2611_) with
                                                            | _s2612_ =>
                                                               match (hex_bits_13_matches_prefix
                                                                        _s2612_) with
                                                               | Some ((imm, existT _ _s2613_ _)) =>
                                                                  match (string_drop _s2612_ _s2613_) with
                                                                  | s_ =>
                                                                     Some ((op, rs1, rs2, imm, s_))
                                                                  end
                                                               | _ => None
                                                               end
                                                            end
                                                         | _ => None
                                                         end)
                                                : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                            end)
                                            : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                        | _ =>
                                           returnm (None
                                            : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                        end)
                                        : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                    end)
                                    : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                | _ =>
                                   returnm (None
                                    : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                                end)
                                : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                            end)
                            : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                        | _ =>
                           returnm (None  : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                        end)
                        : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                    end)
                    : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
                | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13 * string)))
                end)
                : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
            end)
            : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
        | _ => returnm (None  : option ((bop * mword 5 * mword 5 * mword 13 * string)))
        end)
        : M (option ((bop * mword 5 * mword 5 * mword 13 * string)))
    end)
    : M (option ((bop * mword 5 * mword 5 * mword 13 * string))).

Definition _s2582_ (_s2583_ : string) 
: M (option ((mword 5 * mword 5 * mword 12 * string))) :=
   
   let _s2584_ := _s2583_ in
   (if ((string_startswith _s2584_ "jalr")) then
      (match (string_drop _s2584_ (projT1 (string_length "jalr"))) with
       | _s2585_ =>
          (spc_matches_prefix _s2585_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2586_ _)) =>
              (match (string_drop _s2585_ _s2586_) with
               | _s2587_ =>
                  (reg_name_matches_prefix _s2587_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2588_ _)) =>
                      (match (string_drop _s2587_ _s2588_) with
                       | _s2589_ =>
                          (sep_matches_prefix _s2589_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          (match w__2 with
                           | Some ((tt, existT _ _s2590_ _)) =>
                              (match (string_drop _s2589_ _s2590_) with
                               | _s2591_ =>
                                  (reg_name_matches_prefix _s2591_) >>= fun w__3 : option ((mword 5 * {n : Z & ArithFact (n >=
                                    0)})) =>
                                  (match w__3 with
                                   | Some ((rs1, existT _ _s2592_ _)) =>
                                      (match (string_drop _s2591_ _s2592_) with
                                       | _s2593_ =>
                                          (sep_matches_prefix _s2593_) >>= fun w__4 : option ((unit * {n : Z & ArithFact (n >=
                                            0)})) =>
                                          returnm ((match w__4 with
                                                    | Some ((tt, existT _ _s2594_ _)) =>
                                                       match (string_drop _s2593_ _s2594_) with
                                                       | _s2595_ =>
                                                          match (hex_bits_12_matches_prefix _s2595_) with
                                                          | Some ((imm, existT _ _s2596_ _)) =>
                                                             match (string_drop _s2595_ _s2596_) with
                                                             | s_ => Some ((rd, rs1, imm, s_))
                                                             end
                                                          | _ => None
                                                          end
                                                       end
                                                    | _ => None
                                                    end)
                                           : option ((mword 5 * mword 5 * mword 12 * string)))
                                       end)
                                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                                   | _ =>
                                      returnm (None
                                       : option ((mword 5 * mword 5 * mword 12 * string)))
                                   end)
                                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
                               end)
                               : M (option ((mword 5 * mword 5 * mword 12 * string)))
                           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                           end)
                           : M (option ((mword 5 * mword 5 * mword 12 * string)))
                       end)
                       : M (option ((mword 5 * mword 5 * mword 12 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
                   end)
                   : M (option ((mword 5 * mword 5 * mword 12 * string)))
               end)
               : M (option ((mword 5 * mword 5 * mword 12 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 5 * mword 12 * string)))
           end)
           : M (option ((mword 5 * mword 5 * mword 12 * string)))
       end)
       : M (option ((mword 5 * mword 5 * mword 12 * string)))
    else returnm (None  : option ((mword 5 * mword 5 * mword 12 * string))))
    : M (option ((mword 5 * mword 5 * mword 12 * string))).

Definition _s2570_ (_s2571_ : string) 
: M (option ((mword 5 * mword 21 * string))) :=
   
   let _s2572_ := _s2571_ in
   (if ((string_startswith _s2572_ "jal")) then
      (match (string_drop _s2572_ (projT1 (string_length "jal"))) with
       | _s2573_ =>
          (spc_matches_prefix _s2573_) >>= fun w__0 : option ((unit * {n : Z & ArithFact (n >= 0)})) =>
          (match w__0 with
           | Some ((tt, existT _ _s2574_ _)) =>
              (match (string_drop _s2573_ _s2574_) with
               | _s2575_ =>
                  (reg_name_matches_prefix _s2575_) >>= fun w__1 : option ((mword 5 * {n : Z & ArithFact (n >=
                    0)})) =>
                  (match w__1 with
                   | Some ((rd, existT _ _s2576_ _)) =>
                      (match (string_drop _s2575_ _s2576_) with
                       | _s2577_ =>
                          (sep_matches_prefix _s2577_) >>= fun w__2 : option ((unit * {n : Z & ArithFact (n >=
                            0)})) =>
                          returnm ((match w__2 with
                                    | Some ((tt, existT _ _s2578_ _)) =>
                                       match (string_drop _s2577_ _s2578_) with
                                       | _s2579_ =>
                                          match (hex_bits_21_matches_prefix _s2579_) with
                                          | Some ((imm, existT _ _s2580_ _)) =>
                                             match (string_drop _s2579_ _s2580_) with
                                             | s_ => Some ((rd, imm, s_))
                                             end
                                          | _ => None
                                          end
                                       end
                                    | _ => None
                                    end)
                           : option ((mword 5 * mword 21 * string)))
                       end)
                       : M (option ((mword 5 * mword 21 * string)))
                   | _ => returnm (None  : option ((mword 5 * mword 21 * string)))
                   end)
                   : M (option ((mword 5 * mword 21 * string)))
               end)
               : M (option ((mword 5 * mword 21 * string)))
           | _ => returnm (None  : option ((mword 5 * mword 21 * string)))
           end)
           : M (option ((mword 5 * mword 21 * string)))
       end)
       : M (option ((mword 5 * mword 21 * string)))
    else returnm (None  : option ((mword 5 * mword 21 * string))))
    : M (option ((mword 5 * mword 21 * string))).

Definition _s2557_ (_s2558_ : string) 
: M (option ((uop * mword 5 * mword 20 * string))) :=
   
   (match _s2558_ with
    | _s2559_ =>
       (utype_mnemonic_matches_prefix _s2559_) >>= fun w__0 : option ((uop * {n : Z & ArithFact (n >=
         0)})) =>
       (match w__0 with
        | Some ((op, existT _ _s2560_ _)) =>
           (match (string_drop _s2559_ _s2560_) with
            | _s2561_ =>
               (spc_matches_prefix _s2561_) >>= fun w__1 : option ((unit * {n : Z & ArithFact (n >=
                 0)})) =>
               (match w__1 with
                | Some ((tt, existT _ _s2562_ _)) =>
                   (match (string_drop _s2561_ _s2562_) with
                    | _s2563_ =>
                       (reg_name_matches_prefix _s2563_) >>= fun w__2 : option ((mword 5 * {n : Z & ArithFact (n >=
                         0)})) =>
                       (match w__2 with
                        | Some ((rd, existT _ _s2564_ _)) =>
                           (match (string_drop _s2563_ _s2564_) with
                            | _s2565_ =>
                               (sep_matches_prefix _s2565_) >>= fun w__3 : option ((unit * {n : Z & ArithFact (n >=
                                 0)})) =>
                               returnm ((match w__3 with
                                         | Some ((tt, existT _ _s2566_ _)) =>
                                            match (string_drop _s2565_ _s2566_) with
                                            | _s2567_ =>
                                               match (hex_bits_20_matches_prefix _s2567_) with
                                               | Some ((imm, existT _ _s2568_ _)) =>
                                                  match (string_drop _s2567_ _s2568_) with
                                                  | s_ => Some ((op, rd, imm, s_))
                                                  end
                                               | _ => None
                                               end
                                            end
                                         | _ => None
                                         end)
                                : option ((uop * mword 5 * mword 20 * string)))
                            end)
                            : M (option ((uop * mword 5 * mword 20 * string)))
                        | _ => returnm (None  : option ((uop * mword 5 * mword 20 * string)))
                        end)
                        : M (option ((uop * mword 5 * mword 20 * string)))
                    end)
                    : M (option ((uop * mword 5 * mword 20 * string)))
                | _ => returnm (None  : option ((uop * mword 5 * mword 20 * string)))
                end)
                : M (option ((uop * mword 5 * mword 20 * string)))
            end)
            : M (option ((uop * mword 5 * mword 20 * string)))
        | _ => returnm (None  : option ((uop * mword 5 * mword 20 * string)))
        end)
        : M (option ((uop * mword 5 * mword 20 * string)))
    end)
    : M (option ((uop * mword 5 * mword 20 * string))).

Definition assembly_matches_prefix (arg_ : string) 
: M (option ((ast * {n : Z & ArithFact (n >= 0)}))) :=
   
   let _s2569_ := arg_ in
   (_s2557_ _s2569_) >>= fun w__0 : option ((uop * mword 5 * mword 20 * string)) =>
   (if ((match w__0 with | Some ((op, rd, imm, s_)) => true | _ => false end)) then
      (_s2557_ _s2569_) >>= fun w__1 : option ((uop * mword 5 * mword 20 * string)) =>
      (match w__1 with
       | Some ((op, rd, imm, s_)) =>
          returnm ((Some
                      ((UTYPE
                          ((imm, rd, op)), build_ex
                      (projT1
                       (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
           : option ((ast * {n : Z & ArithFact (n >= 0)})))
       | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
       end)
       : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
    else
      (_s2570_ _s2569_) >>= fun w__4 : option ((mword 5 * mword 21 * string)) =>
      (if ((match w__4 with | Some ((rd, imm, s_)) => true | _ => false end)) then
         (_s2570_ _s2569_) >>= fun w__5 : option ((mword 5 * mword 21 * string)) =>
         (match w__5 with
          | Some ((rd, imm, s_)) =>
             returnm ((Some
                         ((RISCV_JAL
                             ((imm, rd)), build_ex
                         (projT1
                          (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
              : option ((ast * {n : Z & ArithFact (n >= 0)})))
          | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
          end)
          : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
       else
         (_s2582_ _s2569_) >>= fun w__8 : option ((mword 5 * mword 5 * mword 12 * string)) =>
         (if ((match w__8 with | Some ((rd, rs1, imm, s_)) => true | _ => false end)) then
            (_s2582_ _s2569_) >>= fun w__9 : option ((mword 5 * mword 5 * mword 12 * string)) =>
            (match w__9 with
             | Some ((rd, rs1, imm, s_)) =>
                returnm ((Some
                            ((RISCV_JALR
                                ((imm, rs1, rd)), build_ex
                            (projT1
                             (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
                 : option ((ast * {n : Z & ArithFact (n >= 0)})))
             | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
             end)
             : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
          else
            (_s2598_ _s2569_) >>= fun w__12 : option ((bop * mword 5 * mword 5 * mword 13 * string)) =>
            (if ((match w__12 with | Some ((op, rs1, rs2, imm, s_)) => true | _ => false end)) then
               (_s2598_ _s2569_) >>= fun w__13 : option ((bop * mword 5 * mword 5 * mword 13 * string)) =>
               (match w__13 with
                | Some ((op, rs1, rs2, imm, s_)) =>
                   returnm ((Some
                               ((BTYPE
                                   ((imm, rs2, rs1, op)), build_ex
                               (projT1
                                (sub_nat (projT1 (string_length arg_)) (projT1 (string_length s_)))))))
                    : option ((ast * {n : Z & ArithFact (n >= 0)})))
                | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                end)
                : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
             else
               (_s2615_ _s2569_) >>= fun w__16 : option ((iop * mword 5 * mword 5 * mword 12 * string)) =>
               (if ((match w__16 with | Some ((op, rd, rs1, imm, s_)) => true | _ => false end))
                then
                  (_s2615_ _s2569_) >>= fun w__17 : option ((iop * mword 5 * mword 5 * mword 12 * string)) =>
                  (match w__17 with
                   | Some ((op, rd, rs1, imm, s_)) =>
                      returnm ((Some
                                  ((ITYPE
                                      ((imm, rs1, rd, op)), build_ex
                                  (projT1
                                   (sub_nat (projT1 (string_length arg_))
                                      (projT1
                                       (string_length s_)))))))
                       : option ((ast * {n : Z & ArithFact (n >= 0)})))
                   | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                   end)
                   : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                else
                  (_s2632_ _s2569_) >>= fun w__20 : option ((sop * mword 5 * mword 5 * mword 6 * string)) =>
                  (if ((match w__20 with | Some ((op, rd, rs1, shamt, s_)) => true | _ => false end))
                   then
                     (_s2632_ _s2569_) >>= fun w__21 : option ((sop * mword 5 * mword 5 * mword 6 * string)) =>
                     (match w__21 with
                      | Some ((op, rd, rs1, shamt, s_)) =>
                         returnm ((Some
                                     ((SHIFTIOP
                                         ((shamt, rs1, rd, op)), build_ex
                                     (projT1
                                      (sub_nat (projT1 (string_length arg_))
                                         (projT1
                                          (string_length s_)))))))
                          : option ((ast * {n : Z & ArithFact (n >= 0)})))
                      | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                      end)
                      : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                   else
                     (_s2649_ _s2569_) >>= fun w__24 : option ((rop * mword 5 * mword 5 * mword 5 * string)) =>
                     (if ((match w__24 with | Some ((op, rd, rs1, rs2, s_)) => true | _ => false end))
                      then
                        (_s2649_ _s2569_) >>= fun w__25 : option ((rop * mword 5 * mword 5 * mword 5 * string)) =>
                        (match w__25 with
                         | Some ((op, rd, rs1, rs2, s_)) =>
                            returnm ((Some
                                        ((RTYPE
                                            ((rs2, rs1, rd, op)), build_ex
                                        (projT1
                                         (sub_nat (projT1 (string_length arg_))
                                            (projT1
                                             (string_length s_)))))))
                             : option ((ast * {n : Z & ArithFact (n >= 0)})))
                         | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                         end)
                         : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                      else
                        (_s2666_ _s2569_) >>= fun w__28 : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)) =>
                        (if ((match w__28 with
                              | Some ((size, is_unsigned, aq, rl, rd, imm, rs1, s_)) => true
                              | _ => false
                              end)) then
                           (_s2666_ _s2569_) >>= fun w__29 : option ((word_width * bool * bool * bool * mword 5 * mword 12 * mword 5 * string)) =>
                           (match w__29 with
                            | Some ((size, is_unsigned, aq, rl, rd, imm, rs1, s_)) =>
                               returnm ((Some
                                           ((LOAD
                                               ((imm, rs1, rd, is_unsigned, size, aq, rl)), build_ex
                                           (projT1
                                            (sub_nat (projT1 (string_length arg_))
                                               (projT1
                                                (string_length s_)))))))
                                : option ((ast * {n : Z & ArithFact (n >= 0)})))
                            | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                            end)
                            : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                         else
                           (_s2696_ _s2569_) >>= fun w__32 : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)) =>
                           (if ((match w__32 with
                                 | Some ((size, aq, rl, rs2, imm, rs1, s_)) => true
                                 | _ => false
                                 end)) then
                              (_s2696_ _s2569_) >>= fun w__33 : option ((word_width * bool * bool * mword 5 * mword 12 * mword 5 * string)) =>
                              (match w__33 with
                               | Some ((size, aq, rl, rs2, imm, rs1, s_)) =>
                                  returnm ((Some
                                              ((STORE
                                                  ((imm, rs2, rs1, size, aq, rl)), build_ex
                                              (projT1
                                               (sub_nat (projT1 (string_length arg_))
                                                  (projT1
                                                   (string_length s_)))))))
                                   : option ((ast * {n : Z & ArithFact (n >= 0)})))
                               | _ => exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                               end)
                               : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                            else
                              (_s2724_ _s2569_) >>= fun w__36 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                              (if ((match w__36 with
                                    | Some ((rd, rs1, imm, s_)) => Z.eqb 64 64
                                    | _ => false
                                    end)) then
                                 (_s2724_ _s2569_) >>= fun w__37 : option ((mword 5 * mword 5 * mword 12 * string)) =>
                                 (match w__37 with
                                  | Some ((rd, rs1, imm, s_)) =>
                                     returnm ((Some
                                                 ((ADDIW
                                                     ((imm, rs1, rd)), build_ex
                                                 (projT1
                                                  (sub_nat (projT1 (string_length arg_))
                                                     (projT1
                                                      (string_length s_)))))))
                                      : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                  | _ =>
                                     exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                  end)
                                  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                               else
                                 (_s2740_ _s2569_) >>= fun w__40 : option ((sop * mword 5 * mword 5 * mword 5 * string)) =>
                                 (if ((match w__40 with
                                       | Some ((op, rd, rs1, shamt, s_)) => Z.eqb 64 64
                                       | _ => false
                                       end)) then
                                    (_s2740_ _s2569_) >>= fun w__41 : option ((sop * mword 5 * mword 5 * mword 5 * string)) =>
                                    (match w__41 with
                                     | Some ((op, rd, rs1, shamt, s_)) =>
                                        returnm ((Some
                                                    ((SHIFTW
                                                        ((shamt, rs1, rd, op)), build_ex
                                                    (projT1
                                                     (sub_nat (projT1 (string_length arg_))
                                                        (projT1
                                                         (string_length s_)))))))
                                         : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                     | _ =>
                                        exit tt  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                     end)
                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                  else
                                    (_s2757_ _s2569_) >>= fun w__44 : option ((ropw * mword 5 * mword 5 * mword 5 * string)) =>
                                    (if ((match w__44 with
                                          | Some ((op, rd, rs1, rs2, s_)) => Z.eqb 64 64
                                          | _ => false
                                          end)) then
                                       (_s2757_ _s2569_) >>= fun w__45 : option ((ropw * mword 5 * mword 5 * mword 5 * string)) =>
                                       (match w__45 with
                                        | Some ((op, rd, rs1, rs2, s_)) =>
                                           returnm ((Some
                                                       ((RTYPEW
                                                           ((rs2, rs1, rd, op)), build_ex
                                                       (projT1
                                                        (sub_nat (projT1 (string_length arg_))
                                                           (projT1
                                                            (string_length s_)))))))
                                            : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                        | _ =>
                                           exit tt
                                            : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                        end)
                                        : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                     else
                                       (_s2774_ _s2569_) >>= fun w__48 : option ((sopw * mword 5 * mword 5 * mword 5 * string)) =>
                                       (if ((match w__48 with
                                             | Some ((op, rd, rs1, shamt, s_)) => Z.eqb 64 64
                                             | _ => false
                                             end)) then
                                          (_s2774_ _s2569_) >>= fun w__49 : option ((sopw * mword 5 * mword 5 * mword 5 * string)) =>
                                          (match w__49 with
                                           | Some ((op, rd, rs1, shamt, s_)) =>
                                              returnm ((Some
                                                          ((SHIFTIWOP
                                                              ((shamt, rs1, rd, op)), build_ex
                                                          (projT1
                                                           (sub_nat (projT1 (string_length arg_))
                                                              (projT1
                                                               (string_length s_)))))))
                                               : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                           | _ =>
                                              exit tt
                                               : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                           end)
                                           : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                        else
                                          (_s2791_ _s2569_) >>= fun w__52 : option ((mword 4 * mword 4 * string)) =>
                                          (if ((match w__52 with
                                                | Some ((pred, succ, s_)) => true
                                                | _ => false
                                                end)) then
                                             (_s2791_ _s2569_) >>= fun w__53 : option ((mword 4 * mword 4 * string)) =>
                                             (match w__53 with
                                              | Some ((pred, succ, s_)) =>
                                                 returnm ((Some
                                                             ((FENCE
                                                                 ((pred, succ)), build_ex
                                                             (projT1
                                                              (sub_nat (projT1 (string_length arg_))
                                                                 (projT1
                                                                  (string_length s_)))))))
                                                  : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              | _ =>
                                                 exit tt
                                                  : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              end)
                                              : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                           else
                                             (_s2803_ _s2569_) >>= fun w__56 : option ((mword 4 * mword 4 * string)) =>
                                             (if ((match w__56 with
                                                   | Some ((pred, succ, s_)) => true
                                                   | _ => false
                                                   end)) then
                                                (_s2803_ _s2569_) >>= fun w__57 : option ((mword 4 * mword 4 * string)) =>
                                                (match w__57 with
                                                 | Some ((pred, succ, s_)) =>
                                                    returnm ((Some
                                                                ((FENCE_TSO
                                                                    ((pred, succ)), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else if ((match (_s2815_ _s2569_) with
                                                        | Some (s_) => true
                                                        | _ => false
                                                        end)) then
                                                (match (_s2815_ _s2569_) with
                                                 | Some (s_) =>
                                                    returnm ((Some
                                                                ((FENCEI
                                                                    (tt), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else if ((match (_s2819_ _s2569_) with
                                                        | Some (s_) => true
                                                        | _ => false
                                                        end)) then
                                                (match (_s2819_ _s2569_) with
                                                 | Some (s_) =>
                                                    returnm ((Some
                                                                ((ECALL
                                                                    (tt), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else if ((match (_s2823_ _s2569_) with
                                                        | Some (s_) => true
                                                        | _ => false
                                                        end)) then
                                                (match (_s2823_ _s2569_) with
                                                 | Some (s_) =>
                                                    returnm ((Some
                                                                ((MRET
                                                                    (tt), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else if ((match (_s2827_ _s2569_) with
                                                        | Some (s_) => true
                                                        | _ => false
                                                        end)) then
                                                (match (_s2827_ _s2569_) with
                                                 | Some (s_) =>
                                                    returnm ((Some
                                                                ((SRET
                                                                    (tt), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else if ((match (_s2831_ _s2569_) with
                                                        | Some (s_) => true
                                                        | _ => false
                                                        end)) then
                                                (match (_s2831_ _s2569_) with
                                                 | Some (s_) =>
                                                    returnm ((Some
                                                                ((EBREAK
                                                                    (tt), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else if ((match (_s2835_ _s2569_) with
                                                        | Some (s_) => true
                                                        | _ => false
                                                        end)) then
                                                (match (_s2835_ _s2569_) with
                                                 | Some (s_) =>
                                                    returnm ((Some
                                                                ((WFI
                                                                    (tt), build_ex
                                                                (projT1
                                                                 (sub_nat
                                                                    (projT1
                                                                     (string_length arg_))
                                                                    (projT1
                                                                     (string_length s_)))))))
                                                     : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 | _ =>
                                                    exit tt
                                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 end)
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                              else
                                                (_s2839_ _s2569_) >>= fun w__72 : option ((mword 5 * mword 5 * string)) =>
                                                (if ((match w__72 with
                                                      | Some ((rs1, rs2, s_)) => true
                                                      | _ => false
                                                      end)) then
                                                   (_s2839_ _s2569_) >>= fun w__73 : option ((mword 5 * mword 5 * string)) =>
                                                   (match w__73 with
                                                    | Some ((rs1, rs2, s_)) =>
                                                       returnm ((Some
                                                                   ((SFENCE_VMA
                                                                       ((rs1, rs2)), build_ex
                                                                   (projT1
                                                                    (sub_nat
                                                                       (projT1
                                                                        (string_length arg_))
                                                                       (projT1
                                                                        (string_length s_)))))))
                                                        : option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                    | _ =>
                                                       exit tt
                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                         0)})))
                                                    end)
                                                    : M (option ((ast * {n : Z & ArithFact (n >= 0)})))
                                                 else
                                                   (_s2851_ _s2569_) >>= fun w__76 : option ((word_width * bool * bool * mword 5 * mword 5 * string)) =>
                                                   (if ((match w__76 with
                                                         | Some ((size, aq, rl, rd, rs1, s_)) =>
                                                            true
                                                         | _ => false
                                                         end)) then
                                                      (_s2851_ _s2569_) >>= fun w__77 : option ((word_width * bool * bool * mword 5 * mword 5 * string)) =>
                                                      (match w__77 with
                                                       | Some ((size, aq, rl, rd, rs1, s_)) =>
                                                          returnm ((Some
                                                                      ((LOADRES
                                                                          ((aq, rl, rs1, size, rd)), build_ex
                                                                      (projT1
                                                                       (sub_nat
                                                                          (projT1
                                                                           (string_length arg_))
                                                                          (projT1
                                                                           (string_length s_)))))))
                                                           : option ((ast * {n : Z & ArithFact (n >=
                                                            0)})))
                                                       | _ =>
                                                          exit tt
                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                            0)})))
                                                       end)
                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                        0)})))
                                                    else
                                                      (_s2869_ _s2569_) >>= fun w__80 : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                      (if ((match w__80 with
                                                            | Some
                                                              ((size, aq, rl, rd, rs1, rs2, s_)) =>
                                                               true
                                                            | _ => false
                                                            end)) then
                                                         (_s2869_ _s2569_) >>= fun w__81 : option ((word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                         (match w__81 with
                                                          | Some ((size, aq, rl, rd, rs1, rs2, s_)) =>
                                                             returnm ((Some
                                                                         ((STORECON
                                                                             ((aq, rl, rs2, rs1, size, rd)), build_ex
                                                                         (projT1
                                                                          (sub_nat
                                                                             (projT1
                                                                              (string_length arg_))
                                                                             (projT1
                                                                              (string_length s_)))))))
                                                              : option ((ast * {n : Z & ArithFact (n >=
                                                               0)})))
                                                          | _ =>
                                                             exit tt
                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                               0)})))
                                                          end)
                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                           0)})))
                                                       else
                                                         (_s2891_ _s2569_) >>= fun w__84 : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                         (if ((match w__84 with
                                                               | Some
                                                                 ((op, width, aq, rl, rd, rs1, rs2, s_)) =>
                                                                  true
                                                               | _ => false
                                                               end)) then
                                                            (_s2891_ _s2569_) >>= fun w__85 : option ((amoop * word_width * bool * bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                            (match w__85 with
                                                             | Some
                                                               ((op, width, aq, rl, rd, rs1, rs2, s_)) =>
                                                                returnm ((Some
                                                                            ((AMO
                                                                                ((op, aq, rl, rs2, rs1, width, rd)), build_ex
                                                                            (projT1
                                                                             (sub_nat
                                                                                (projT1
                                                                                 (string_length arg_))
                                                                                (projT1
                                                                                 (string_length s_)))))))
                                                                 : option ((ast * {n : Z & ArithFact (n >=
                                                                  0)})))
                                                             | _ =>
                                                                exit tt
                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                  0)})))
                                                             end)
                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                              0)})))
                                                          else if ((match (_s2915_ _s2569_) with
                                                                    | Some (s_) => true
                                                                    | _ => false
                                                                    end)) then
                                                            (match (_s2915_ _s2569_) with
                                                             | Some (s_) =>
                                                                returnm ((Some
                                                                            ((C_NOP
                                                                                (tt), build_ex
                                                                            (projT1
                                                                             (sub_nat
                                                                                (projT1
                                                                                 (string_length arg_))
                                                                                (projT1
                                                                                 (string_length s_)))))))
                                                                 : option ((ast * {n : Z & ArithFact (n >=
                                                                  0)})))
                                                             | _ =>
                                                                exit tt
                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                  0)})))
                                                             end)
                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                              0)})))
                                                          else
                                                            (_s2919_ _s2569_) >>= fun w__90 : option ((mword 3 * mword 8 * string)) =>
                                                            (if ((match w__90 with
                                                                  | Some ((rdc, nzimm, s_)) =>
                                                                     neq_vec nzimm
                                                                       (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]
                                                                         : mword 8)
                                                                  | _ => false
                                                                  end)) then
                                                               (_s2919_ _s2569_) >>= fun w__91 : option ((mword 3 * mword 8 * string)) =>
                                                               (match w__91 with
                                                                | Some ((rdc, nzimm, s_)) =>
                                                                   returnm ((Some
                                                                               ((C_ADDI4SPN
                                                                                   ((rdc, nzimm)), build_ex
                                                                               (projT1
                                                                                (sub_nat
                                                                                   (projT1
                                                                                    (string_length
                                                                                       arg_))
                                                                                   (projT1
                                                                                    (string_length
                                                                                       s_)))))))
                                                                    : option ((ast * {n : Z & ArithFact (n >=
                                                                     0)})))
                                                                | _ =>
                                                                   exit tt
                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                     0)})))
                                                                end)
                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                 0)})))
                                                             else
                                                               (_s2931_ _s2569_) >>= fun w__94 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                               (if ((match w__94 with
                                                                     | Some ((rdc, rsc, uimm, s_)) =>
                                                                        true
                                                                     | _ => false
                                                                     end)) then
                                                                  (_s2931_ _s2569_) >>= fun w__95 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                                  (match w__95 with
                                                                   | Some ((rdc, rsc, uimm, s_)) =>
                                                                      returnm ((Some
                                                                                  ((C_LW
                                                                                      ((uimm, rsc, rdc)), build_ex
                                                                                  (projT1
                                                                                   (sub_nat
                                                                                      (projT1
                                                                                       (string_length
                                                                                          arg_))
                                                                                      (projT1
                                                                                       (string_length
                                                                                          s_)))))))
                                                                       : option ((ast * {n : Z & ArithFact (n >=
                                                                        0)})))
                                                                   | _ =>
                                                                      exit tt
                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                        0)})))
                                                                   end)
                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                    0)})))
                                                                else
                                                                  (_s2947_ _s2569_) >>= fun w__98 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                                  (if ((match w__98 with
                                                                        | Some
                                                                          ((rdc, rsc, uimm, s_)) =>
                                                                           Z.eqb 64 64
                                                                        | _ => false
                                                                        end)) then
                                                                     (_s2947_ _s2569_) >>= fun w__99 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                                     (match w__99 with
                                                                      | Some ((rdc, rsc, uimm, s_)) =>
                                                                         returnm ((Some
                                                                                     ((C_LD
                                                                                         ((uimm, rsc, rdc)), build_ex
                                                                                     (projT1
                                                                                      (sub_nat
                                                                                         (projT1
                                                                                          (string_length
                                                                                             arg_))
                                                                                         (projT1
                                                                                          (string_length
                                                                                             s_)))))))
                                                                          : option ((ast * {n : Z & ArithFact (n >=
                                                                           0)})))
                                                                      | _ =>
                                                                         exit tt
                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                           0)})))
                                                                      end)
                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                       0)})))
                                                                   else
                                                                     (_s2963_ _s2569_) >>= fun w__102 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                                     (if ((match w__102 with
                                                                           | Some
                                                                             ((rsc1, rsc2, uimm, s_)) =>
                                                                              true
                                                                           | _ => false
                                                                           end)) then
                                                                        (_s2963_ _s2569_) >>= fun w__103 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                                        (match w__103 with
                                                                         | Some
                                                                           ((rsc1, rsc2, uimm, s_)) =>
                                                                            returnm ((Some
                                                                                        ((C_SW
                                                                                            ((uimm, rsc1, rsc2)), build_ex
                                                                                        (projT1
                                                                                         (sub_nat
                                                                                            (projT1
                                                                                             (string_length
                                                                                                arg_))
                                                                                            (projT1
                                                                                             (string_length
                                                                                                s_)))))))
                                                                             : option ((ast * {n : Z & ArithFact (n >=
                                                                              0)})))
                                                                         | _ =>
                                                                            exit tt
                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                              0)})))
                                                                         end)
                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                          0)})))
                                                                      else
                                                                        (_s2979_ _s2569_) >>= fun w__106 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                                        (if ((match w__106 with
                                                                              | Some
                                                                                ((rsc1, rsc2, uimm, s_)) =>
                                                                                 Z.eqb 64 64
                                                                              | _ => false
                                                                              end)) then
                                                                           (_s2979_ _s2569_) >>= fun w__107 : option ((mword 3 * mword 3 * mword 5 * string)) =>
                                                                           (match w__107 with
                                                                            | Some
                                                                              ((rsc1, rsc2, uimm, s_)) =>
                                                                               returnm ((Some
                                                                                           ((C_SD
                                                                                               ((uimm, rsc1, rsc2)), build_ex
                                                                                           (projT1
                                                                                            (sub_nat
                                                                                               (projT1
                                                                                                (string_length
                                                                                                   arg_))
                                                                                               (projT1
                                                                                                (string_length
                                                                                                   s_)))))))
                                                                                : option ((ast * {n : Z & ArithFact (n >=
                                                                                 0)})))
                                                                            | _ =>
                                                                               exit tt
                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                 0)})))
                                                                            end)
                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                             0)})))
                                                                         else
                                                                           (_s2995_ _s2569_) >>= fun w__110 : option ((mword 5 * mword 6 * string)) =>
                                                                           (if ((match w__110 with
                                                                                 | Some
                                                                                   ((rsd, nzi, s_)) =>
                                                                                    andb
                                                                                      (neq_vec nzi
                                                                                         (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                           : mword 6))
                                                                                      ((projT1
                                                                                        (neq_int
                                                                                           (projT1
                                                                                            (regidx_to_regno
                                                                                               rsd))
                                                                                           (projT1
                                                                                            (regidx_to_regno
                                                                                               zreg))))
                                                                                       : bool)
                                                                                 | _ => false
                                                                                 end)) then
                                                                              (_s2995_ _s2569_) >>= fun w__111 : option ((mword 5 * mword 6 * string)) =>
                                                                              (match w__111 with
                                                                               | Some
                                                                                 ((rsd, nzi, s_)) =>
                                                                                  returnm ((Some
                                                                                              ((C_ADDI
                                                                                                  ((nzi, rsd)), build_ex
                                                                                              (projT1
                                                                                               (sub_nat
                                                                                                  (projT1
                                                                                                   (string_length
                                                                                                      arg_))
                                                                                                  (projT1
                                                                                                   (string_length
                                                                                                      s_)))))))
                                                                                   : option ((ast * {n : Z & ArithFact (n >=
                                                                                    0)})))
                                                                               | _ =>
                                                                                  exit tt
                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                    0)})))
                                                                               end)
                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                0)})))
                                                                            else
                                                                              (_s3007_ _s2569_) >>= fun w__114 : option ((mword 11 * string)) =>
                                                                              (if ((match w__114 with
                                                                                    | Some
                                                                                      ((imm, s_)) =>
                                                                                       Z.eqb 64 32
                                                                                    | _ => false
                                                                                    end)) then
                                                                                 (_s3007_ _s2569_) >>= fun w__115 : option ((mword 11 * string)) =>
                                                                                 (match w__115 with
                                                                                  | Some ((imm, s_)) =>
                                                                                     returnm ((Some
                                                                                                 ((C_JAL
                                                                                                     (imm), build_ex
                                                                                                 (projT1
                                                                                                  (sub_nat
                                                                                                     (projT1
                                                                                                      (string_length
                                                                                                         arg_))
                                                                                                     (projT1
                                                                                                      (string_length
                                                                                                         s_)))))))
                                                                                      : option ((ast * {n : Z & ArithFact (n >=
                                                                                       0)})))
                                                                                  | _ =>
                                                                                     exit tt
                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                       0)})))
                                                                                  end)
                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                   0)})))
                                                                               else
                                                                                 (_s3015_ _s2569_) >>= fun w__118 : option ((mword 5 * mword 6 * string)) =>
                                                                                 (if ((match w__118 with
                                                                                       | Some
                                                                                         ((rsd, imm, s_)) =>
                                                                                          Z.eqb 64
                                                                                            64
                                                                                       | _ => false
                                                                                       end)) then
                                                                                    (_s3015_ _s2569_) >>= fun w__119 : option ((mword 5 * mword 6 * string)) =>
                                                                                    (match w__119 with
                                                                                     | Some
                                                                                       ((rsd, imm, s_)) =>
                                                                                        returnm ((Some
                                                                                                    ((C_ADDIW
                                                                                                        ((imm, rsd)), build_ex
                                                                                                    (projT1
                                                                                                     (sub_nat
                                                                                                        (projT1
                                                                                                         (string_length
                                                                                                            arg_))
                                                                                                        (projT1
                                                                                                         (string_length
                                                                                                            s_)))))))
                                                                                         : option ((ast * {n : Z & ArithFact (n >=
                                                                                          0)})))
                                                                                     | _ =>
                                                                                        exit tt
                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                          0)})))
                                                                                     end)
                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                      0)})))
                                                                                  else
                                                                                    (_s3027_ _s2569_) >>= fun w__122 : option ((mword 5 * mword 6 * string)) =>
                                                                                    (if ((match w__122 with
                                                                                          | Some
                                                                                            ((rd, imm, s_)) =>
                                                                                             projT1
                                                                                             (neq_int
                                                                                                (projT1
                                                                                                 (regidx_to_regno
                                                                                                    rd))
                                                                                                (projT1
                                                                                                 (regidx_to_regno
                                                                                                    zreg)))
                                                                                          | _ =>
                                                                                             false
                                                                                          end)) then
                                                                                       (_s3027_
                                                                                          _s2569_) >>= fun w__123 : option ((mword 5 * mword 6 * string)) =>
                                                                                       (match w__123 with
                                                                                        | Some
                                                                                          ((rd, imm, s_)) =>
                                                                                           returnm ((Some
                                                                                                       ((C_LI
                                                                                                           ((imm, rd)), build_ex
                                                                                                       (projT1
                                                                                                        (sub_nat
                                                                                                           (projT1
                                                                                                            (string_length
                                                                                                               arg_))
                                                                                                           (projT1
                                                                                                            (string_length
                                                                                                               s_)))))))
                                                                                            : option ((ast * {n : Z & ArithFact (n >=
                                                                                             0)})))
                                                                                        | _ =>
                                                                                           exit tt
                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                             0)})))
                                                                                        end)
                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                         0)})))
                                                                                     else
                                                                                       (_s3039_
                                                                                          _s2569_) >>= fun w__126 : option ((mword 6 * string)) =>
                                                                                       (if ((match w__126 with
                                                                                             | Some
                                                                                               ((imm, s_)) =>
                                                                                                neq_vec
                                                                                                  imm
                                                                                                  (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                    : mword 6)
                                                                                             | _ =>
                                                                                                false
                                                                                             end))
                                                                                        then
                                                                                          (_s3039_
                                                                                             _s2569_) >>= fun w__127 : option ((mword 6 * string)) =>
                                                                                          (match w__127 with
                                                                                           | Some
                                                                                             ((imm, s_)) =>
                                                                                              returnm ((Some
                                                                                                          ((C_ADDI16SP
                                                                                                              (imm), build_ex
                                                                                                          (projT1
                                                                                                           (sub_nat
                                                                                                              (projT1
                                                                                                               (string_length
                                                                                                                  arg_))
                                                                                                              (projT1
                                                                                                               (string_length
                                                                                                                  s_)))))))
                                                                                               : option ((ast * {n : Z & ArithFact (n >=
                                                                                                0)})))
                                                                                           | _ =>
                                                                                              exit tt
                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                0)})))
                                                                                           end)
                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                            0)})))
                                                                                        else
                                                                                          (_s3047_
                                                                                             _s2569_) >>= fun w__130 : option ((mword 5 * mword 6 * string)) =>
                                                                                          (if ((match w__130 with
                                                                                                | Some
                                                                                                  ((rd, imm, s_)) =>
                                                                                                   andb
                                                                                                     (projT1
                                                                                                      (neq_int
                                                                                                         (projT1
                                                                                                          (regidx_to_regno
                                                                                                             rd))
                                                                                                         (projT1
                                                                                                          (regidx_to_regno
                                                                                                             zreg))))
                                                                                                     ((andb
                                                                                                         (projT1
                                                                                                          (neq_int
                                                                                                             (projT1
                                                                                                              (regidx_to_regno
                                                                                                                 rd))
                                                                                                             (projT1
                                                                                                              (regidx_to_regno
                                                                                                                 sp))))
                                                                                                         (neq_vec
                                                                                                            imm
                                                                                                            (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                              : mword 6)))
                                                                                                      : bool)
                                                                                                | _ =>
                                                                                                   false
                                                                                                end))
                                                                                           then
                                                                                             (_s3047_
                                                                                                _s2569_) >>= fun w__131 : option ((mword 5 * mword 6 * string)) =>
                                                                                             (match w__131 with
                                                                                              | Some
                                                                                                ((rd, imm, s_)) =>
                                                                                                 returnm ((Some
                                                                                                             ((C_LUI
                                                                                                                 ((imm, rd)), build_ex
                                                                                                             (projT1
                                                                                                              (sub_nat
                                                                                                                 (projT1
                                                                                                                  (string_length
                                                                                                                     arg_))
                                                                                                                 (projT1
                                                                                                                  (string_length
                                                                                                                     s_)))))))
                                                                                                  : option ((ast * {n : Z & ArithFact (n >=
                                                                                                   0)})))
                                                                                              | _ =>
                                                                                                 exit tt
                                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                   0)})))
                                                                                              end)
                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                               0)})))
                                                                                           else
                                                                                             (_s3059_
                                                                                                _s2569_) >>= fun w__134 : option ((mword 3 * mword 6 * string)) =>
                                                                                             (if ((match w__134 with
                                                                                                   | Some
                                                                                                     ((rsd, shamt, s_)) =>
                                                                                                      neq_vec
                                                                                                        shamt
                                                                                                        (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                          : mword 6)
                                                                                                   | _ =>
                                                                                                      false
                                                                                                   end))
                                                                                              then
                                                                                                (_s3059_
                                                                                                   _s2569_) >>= fun w__135 : option ((mword 3 * mword 6 * string)) =>
                                                                                                (match w__135 with
                                                                                                 | Some
                                                                                                   ((rsd, shamt, s_)) =>
                                                                                                    returnm ((Some
                                                                                                                ((C_SRLI
                                                                                                                    ((shamt, rsd)), build_ex
                                                                                                                (projT1
                                                                                                                 (sub_nat
                                                                                                                    (projT1
                                                                                                                     (string_length
                                                                                                                        arg_))
                                                                                                                    (projT1
                                                                                                                     (string_length
                                                                                                                        s_)))))))
                                                                                                     : option ((ast * {n : Z & ArithFact (n >=
                                                                                                      0)})))
                                                                                                 | _ =>
                                                                                                    exit tt
                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                      0)})))
                                                                                                 end)
                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                  0)})))
                                                                                              else
                                                                                                (_s3071_
                                                                                                   _s2569_) >>= fun w__138 : option ((mword 3 * mword 6 * string)) =>
                                                                                                (if ((match w__138 with
                                                                                                      | Some
                                                                                                        ((rsd, shamt, s_)) =>
                                                                                                         neq_vec
                                                                                                           shamt
                                                                                                           (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                             : mword 6)
                                                                                                      | _ =>
                                                                                                         false
                                                                                                      end))
                                                                                                 then
                                                                                                   (_s3071_
                                                                                                      _s2569_) >>= fun w__139 : option ((mword 3 * mword 6 * string)) =>
                                                                                                   (match w__139 with
                                                                                                    | Some
                                                                                                      ((rsd, shamt, s_)) =>
                                                                                                       returnm ((Some
                                                                                                                   ((C_SRAI
                                                                                                                       ((shamt, rsd)), build_ex
                                                                                                                   (projT1
                                                                                                                    (sub_nat
                                                                                                                       (projT1
                                                                                                                        (string_length
                                                                                                                           arg_))
                                                                                                                       (projT1
                                                                                                                        (string_length
                                                                                                                           s_)))))))
                                                                                                        : option ((ast * {n : Z & ArithFact (n >=
                                                                                                         0)})))
                                                                                                    | _ =>
                                                                                                       exit tt
                                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                         0)})))
                                                                                                    end)
                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                     0)})))
                                                                                                 else
                                                                                                   (_s3083_
                                                                                                      _s2569_) >>= fun w__142 : option ((mword 3 * mword 6 * string)) =>
                                                                                                   (if
                                                                                                      ((match w__142 with
                                                                                                        | Some
                                                                                                          ((rsd, imm, s_)) =>
                                                                                                           true
                                                                                                        | _ =>
                                                                                                           false
                                                                                                        end))
                                                                                                    then
                                                                                                      (_s3083_
                                                                                                         _s2569_) >>= fun w__143 : option ((mword 3 * mword 6 * string)) =>
                                                                                                      (match w__143 with
                                                                                                       | Some
                                                                                                         ((rsd, imm, s_)) =>
                                                                                                          returnm ((Some
                                                                                                                      ((C_ANDI
                                                                                                                          ((imm, rsd)), build_ex
                                                                                                                      (projT1
                                                                                                                       (sub_nat
                                                                                                                          (projT1
                                                                                                                           (string_length
                                                                                                                              arg_))
                                                                                                                          (projT1
                                                                                                                           (string_length
                                                                                                                              s_)))))))
                                                                                                           : option ((ast * {n : Z & ArithFact (n >=
                                                                                                            0)})))
                                                                                                       | _ =>
                                                                                                          exit tt
                                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                            0)})))
                                                                                                       end)
                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                        0)})))
                                                                                                    else
                                                                                                      (_s3095_
                                                                                                         _s2569_) >>= fun w__146 : option ((mword 3 * mword 3 * string)) =>
                                                                                                      (if
                                                                                                         ((match w__146 with
                                                                                                           | Some
                                                                                                             ((rsd, rs2, s_)) =>
                                                                                                              true
                                                                                                           | _ =>
                                                                                                              false
                                                                                                           end))
                                                                                                       then
                                                                                                         (_s3095_
                                                                                                            _s2569_) >>= fun w__147 : option ((mword 3 * mword 3 * string)) =>
                                                                                                         (match w__147 with
                                                                                                          | Some
                                                                                                            ((rsd, rs2, s_)) =>
                                                                                                             returnm ((Some
                                                                                                                         ((C_SUB
                                                                                                                             ((rsd, rs2)), build_ex
                                                                                                                         (projT1
                                                                                                                          (sub_nat
                                                                                                                             (projT1
                                                                                                                              (string_length
                                                                                                                                 arg_))
                                                                                                                             (projT1
                                                                                                                              (string_length
                                                                                                                                 s_)))))))
                                                                                                              : option ((ast * {n : Z & ArithFact (n >=
                                                                                                               0)})))
                                                                                                          | _ =>
                                                                                                             exit tt
                                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                               0)})))
                                                                                                          end)
                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                           0)})))
                                                                                                       else
                                                                                                         (_s3107_
                                                                                                            _s2569_) >>= fun w__150 : option ((mword 3 * mword 3 * string)) =>
                                                                                                         (if
                                                                                                            ((match w__150 with
                                                                                                              | Some
                                                                                                                ((rsd, rs2, s_)) =>
                                                                                                                 true
                                                                                                              | _ =>
                                                                                                                 false
                                                                                                              end))
                                                                                                          then
                                                                                                            (_s3107_
                                                                                                               _s2569_) >>= fun w__151 : option ((mword 3 * mword 3 * string)) =>
                                                                                                            (match w__151 with
                                                                                                             | Some
                                                                                                               ((rsd, rs2, s_)) =>
                                                                                                                returnm ((Some
                                                                                                                            ((C_XOR
                                                                                                                                ((rsd, rs2)), build_ex
                                                                                                                            (projT1
                                                                                                                             (sub_nat
                                                                                                                                (projT1
                                                                                                                                 (string_length
                                                                                                                                    arg_))
                                                                                                                                (projT1
                                                                                                                                 (string_length
                                                                                                                                    s_)))))))
                                                                                                                 : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                  0)})))
                                                                                                             | _ =>
                                                                                                                exit tt
                                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                  0)})))
                                                                                                             end)
                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                              0)})))
                                                                                                          else
                                                                                                            (_s3119_
                                                                                                               _s2569_) >>= fun w__154 : option ((mword 3 * mword 3 * string)) =>
                                                                                                            (if
                                                                                                               ((match w__154 with
                                                                                                                 | Some
                                                                                                                   ((rsd, rs2, s_)) =>
                                                                                                                    true
                                                                                                                 | _ =>
                                                                                                                    false
                                                                                                                 end))
                                                                                                             then
                                                                                                               (_s3119_
                                                                                                                  _s2569_) >>= fun w__155 : option ((mword 3 * mword 3 * string)) =>
                                                                                                               (match w__155 with
                                                                                                                | Some
                                                                                                                  ((rsd, rs2, s_)) =>
                                                                                                                   returnm ((Some
                                                                                                                               ((C_OR
                                                                                                                                   ((rsd, rs2)), build_ex
                                                                                                                               (projT1
                                                                                                                                (sub_nat
                                                                                                                                   (projT1
                                                                                                                                    (string_length
                                                                                                                                       arg_))
                                                                                                                                   (projT1
                                                                                                                                    (string_length
                                                                                                                                       s_)))))))
                                                                                                                    : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                     0)})))
                                                                                                                | _ =>
                                                                                                                   exit tt
                                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                     0)})))
                                                                                                                end)
                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                 0)})))
                                                                                                             else
                                                                                                               (_s3131_
                                                                                                                  _s2569_) >>= fun w__158 : option ((mword 3 * mword 3 * string)) =>
                                                                                                               (if
                                                                                                                  ((match w__158 with
                                                                                                                    | Some
                                                                                                                      ((rsd, rs2, s_)) =>
                                                                                                                       true
                                                                                                                    | _ =>
                                                                                                                       false
                                                                                                                    end))
                                                                                                                then
                                                                                                                  (_s3131_
                                                                                                                     _s2569_) >>= fun w__159 : option ((mword 3 * mword 3 * string)) =>
                                                                                                                  (match w__159 with
                                                                                                                   | Some
                                                                                                                     ((rsd, rs2, s_)) =>
                                                                                                                      returnm ((Some
                                                                                                                                  ((C_AND
                                                                                                                                      ((rsd, rs2)), build_ex
                                                                                                                                  (projT1
                                                                                                                                   (sub_nat
                                                                                                                                      (projT1
                                                                                                                                       (string_length
                                                                                                                                          arg_))
                                                                                                                                      (projT1
                                                                                                                                       (string_length
                                                                                                                                          s_)))))))
                                                                                                                       : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                        0)})))
                                                                                                                   | _ =>
                                                                                                                      exit tt
                                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                        0)})))
                                                                                                                   end)
                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                    0)})))
                                                                                                                else
                                                                                                                  (_s3143_
                                                                                                                     _s2569_) >>= fun w__162 : option ((mword 3 * mword 3 * string)) =>
                                                                                                                  (if
                                                                                                                     ((match w__162 with
                                                                                                                       | Some
                                                                                                                         ((rsd, rs2, s_)) =>
                                                                                                                          Z.eqb
                                                                                                                            64
                                                                                                                            64
                                                                                                                       | _ =>
                                                                                                                          false
                                                                                                                       end))
                                                                                                                   then
                                                                                                                     (_s3143_
                                                                                                                        _s2569_) >>= fun w__163 : option ((mword 3 * mword 3 * string)) =>
                                                                                                                     (match w__163 with
                                                                                                                      | Some
                                                                                                                        ((rsd, rs2, s_)) =>
                                                                                                                         returnm ((Some
                                                                                                                                     ((C_SUBW
                                                                                                                                         ((rsd, rs2)), build_ex
                                                                                                                                     (projT1
                                                                                                                                      (sub_nat
                                                                                                                                         (projT1
                                                                                                                                          (string_length
                                                                                                                                             arg_))
                                                                                                                                         (projT1
                                                                                                                                          (string_length
                                                                                                                                             s_)))))))
                                                                                                                          : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                           0)})))
                                                                                                                      | _ =>
                                                                                                                         exit tt
                                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                           0)})))
                                                                                                                      end)
                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                       0)})))
                                                                                                                   else
                                                                                                                     (_s3155_
                                                                                                                        _s2569_) >>= fun w__166 : option ((mword 3 * mword 3 * string)) =>
                                                                                                                     (if
                                                                                                                        ((match w__166 with
                                                                                                                          | Some
                                                                                                                            ((rsd, rs2, s_)) =>
                                                                                                                             Z.eqb
                                                                                                                               64
                                                                                                                               64
                                                                                                                          | _ =>
                                                                                                                             false
                                                                                                                          end))
                                                                                                                      then
                                                                                                                        (_s3155_
                                                                                                                           _s2569_) >>= fun w__167 : option ((mword 3 * mword 3 * string)) =>
                                                                                                                        (match w__167 with
                                                                                                                         | Some
                                                                                                                           ((rsd, rs2, s_)) =>
                                                                                                                            returnm ((Some
                                                                                                                                        ((C_ADDW
                                                                                                                                            ((rsd, rs2)), build_ex
                                                                                                                                        (projT1
                                                                                                                                         (sub_nat
                                                                                                                                            (projT1
                                                                                                                                             (string_length
                                                                                                                                                arg_))
                                                                                                                                            (projT1
                                                                                                                                             (string_length
                                                                                                                                                s_)))))))
                                                                                                                             : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                              0)})))
                                                                                                                         | _ =>
                                                                                                                            exit tt
                                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                              0)})))
                                                                                                                         end)
                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                          0)})))
                                                                                                                      else
                                                                                                                        (_s3167_
                                                                                                                           _s2569_) >>= fun w__170 : option ((mword 11 * string)) =>
                                                                                                                        (if
                                                                                                                           ((match w__170 with
                                                                                                                             | Some
                                                                                                                               ((imm, s_)) =>
                                                                                                                                true
                                                                                                                             | _ =>
                                                                                                                                false
                                                                                                                             end))
                                                                                                                         then
                                                                                                                           (_s3167_
                                                                                                                              _s2569_) >>= fun w__171 : option ((mword 11 * string)) =>
                                                                                                                           (match w__171 with
                                                                                                                            | Some
                                                                                                                              ((imm, s_)) =>
                                                                                                                               returnm ((Some
                                                                                                                                           ((C_J
                                                                                                                                               (imm), build_ex
                                                                                                                                           (projT1
                                                                                                                                            (sub_nat
                                                                                                                                               (projT1
                                                                                                                                                (string_length
                                                                                                                                                   arg_))
                                                                                                                                               (projT1
                                                                                                                                                (string_length
                                                                                                                                                   s_)))))))
                                                                                                                                : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                 0)})))
                                                                                                                            | _ =>
                                                                                                                               exit tt
                                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                 0)})))
                                                                                                                            end)
                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                             0)})))
                                                                                                                         else
                                                                                                                           (_s3175_
                                                                                                                              _s2569_) >>= fun w__174 : option ((mword 3 * mword 8 * string)) =>
                                                                                                                           (if
                                                                                                                              ((match w__174 with
                                                                                                                                | Some
                                                                                                                                  ((rs, imm, s_)) =>
                                                                                                                                   true
                                                                                                                                | _ =>
                                                                                                                                   false
                                                                                                                                end))
                                                                                                                            then
                                                                                                                              (_s3175_
                                                                                                                                 _s2569_) >>= fun w__175 : option ((mword 3 * mword 8 * string)) =>
                                                                                                                              (match w__175 with
                                                                                                                               | Some
                                                                                                                                 ((rs, imm, s_)) =>
                                                                                                                                  returnm ((Some
                                                                                                                                              ((C_BEQZ
                                                                                                                                                  ((imm, rs)), build_ex
                                                                                                                                              (projT1
                                                                                                                                               (sub_nat
                                                                                                                                                  (projT1
                                                                                                                                                   (string_length
                                                                                                                                                      arg_))
                                                                                                                                                  (projT1
                                                                                                                                                   (string_length
                                                                                                                                                      s_)))))))
                                                                                                                                   : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                    0)})))
                                                                                                                               | _ =>
                                                                                                                                  exit tt
                                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                    0)})))
                                                                                                                               end)
                                                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                0)})))
                                                                                                                            else
                                                                                                                              (_s3187_
                                                                                                                                 _s2569_) >>= fun w__178 : option ((mword 3 * mword 8 * string)) =>
                                                                                                                              (if
                                                                                                                                 ((match w__178 with
                                                                                                                                   | Some
                                                                                                                                     ((rs, imm, s_)) =>
                                                                                                                                      true
                                                                                                                                   | _ =>
                                                                                                                                      false
                                                                                                                                   end))
                                                                                                                               then
                                                                                                                                 (_s3187_
                                                                                                                                    _s2569_) >>= fun w__179 : option ((mword 3 * mword 8 * string)) =>
                                                                                                                                 (match w__179 with
                                                                                                                                  | Some
                                                                                                                                    ((rs, imm, s_)) =>
                                                                                                                                     returnm ((Some
                                                                                                                                                 ((C_BNEZ
                                                                                                                                                     ((imm, rs)), build_ex
                                                                                                                                                 (projT1
                                                                                                                                                  (sub_nat
                                                                                                                                                     (projT1
                                                                                                                                                      (string_length
                                                                                                                                                         arg_))
                                                                                                                                                     (projT1
                                                                                                                                                      (string_length
                                                                                                                                                         s_)))))))
                                                                                                                                      : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                       0)})))
                                                                                                                                  | _ =>
                                                                                                                                     exit tt
                                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                       0)})))
                                                                                                                                  end)
                                                                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                   0)})))
                                                                                                                               else
                                                                                                                                 (_s3199_
                                                                                                                                    _s2569_) >>= fun w__182 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                 (if
                                                                                                                                    ((match w__182 with
                                                                                                                                      | Some
                                                                                                                                        ((rsd, shamt, s_)) =>
                                                                                                                                         andb
                                                                                                                                           (neq_vec
                                                                                                                                              shamt
                                                                                                                                              (vec_of_bits [B0;B0;B0;B0;B0;B0]
                                                                                                                                                : mword 6))
                                                                                                                                           ((projT1
                                                                                                                                             (neq_int
                                                                                                                                                (projT1
                                                                                                                                                 (regidx_to_regno
                                                                                                                                                    rsd))
                                                                                                                                                (projT1
                                                                                                                                                 (regidx_to_regno
                                                                                                                                                    zreg))))
                                                                                                                                            : bool)
                                                                                                                                      | _ =>
                                                                                                                                         false
                                                                                                                                      end))
                                                                                                                                  then
                                                                                                                                    (_s3199_
                                                                                                                                       _s2569_) >>= fun w__183 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                    (match w__183 with
                                                                                                                                     | Some
                                                                                                                                       ((rsd, shamt, s_)) =>
                                                                                                                                        returnm ((Some
                                                                                                                                                    ((C_SLLI
                                                                                                                                                        ((shamt, rsd)), build_ex
                                                                                                                                                    (projT1
                                                                                                                                                     (sub_nat
                                                                                                                                                        (projT1
                                                                                                                                                         (string_length
                                                                                                                                                            arg_))
                                                                                                                                                        (projT1
                                                                                                                                                         (string_length
                                                                                                                                                            s_)))))))
                                                                                                                                         : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                          0)})))
                                                                                                                                     | _ =>
                                                                                                                                        exit tt
                                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                          0)})))
                                                                                                                                     end)
                                                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                      0)})))
                                                                                                                                  else
                                                                                                                                    (_s3211_
                                                                                                                                       _s2569_) >>= fun w__186 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                    (if
                                                                                                                                       ((match w__186 with
                                                                                                                                         | Some
                                                                                                                                           ((rd, uimm, s_)) =>
                                                                                                                                            projT1
                                                                                                                                            (neq_int
                                                                                                                                               (projT1
                                                                                                                                                (regidx_to_regno
                                                                                                                                                   rd))
                                                                                                                                               (projT1
                                                                                                                                                (regidx_to_regno
                                                                                                                                                   zreg)))
                                                                                                                                         | _ =>
                                                                                                                                            false
                                                                                                                                         end))
                                                                                                                                     then
                                                                                                                                       (_s3211_
                                                                                                                                          _s2569_) >>= fun w__187 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                       (match w__187 with
                                                                                                                                        | Some
                                                                                                                                          ((rd, uimm, s_)) =>
                                                                                                                                           returnm ((Some
                                                                                                                                                       ((C_LWSP
                                                                                                                                                           ((uimm, rd)), build_ex
                                                                                                                                                       (projT1
                                                                                                                                                        (sub_nat
                                                                                                                                                           (projT1
                                                                                                                                                            (string_length
                                                                                                                                                               arg_))
                                                                                                                                                           (projT1
                                                                                                                                                            (string_length
                                                                                                                                                               s_)))))))
                                                                                                                                            : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                             0)})))
                                                                                                                                        | _ =>
                                                                                                                                           exit tt
                                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                             0)})))
                                                                                                                                        end)
                                                                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                         0)})))
                                                                                                                                     else
                                                                                                                                       (_s3223_
                                                                                                                                          _s2569_) >>= fun w__190 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                       (if
                                                                                                                                          ((match w__190 with
                                                                                                                                            | Some
                                                                                                                                              ((rd, uimm, s_)) =>
                                                                                                                                               andb
                                                                                                                                                 (projT1
                                                                                                                                                  (neq_int
                                                                                                                                                     (projT1
                                                                                                                                                      (regidx_to_regno
                                                                                                                                                         rd))
                                                                                                                                                     (projT1
                                                                                                                                                      (regidx_to_regno
                                                                                                                                                         zreg))))
                                                                                                                                                 (Z.eqb
                                                                                                                                                    64
                                                                                                                                                    64)
                                                                                                                                            | _ =>
                                                                                                                                               false
                                                                                                                                            end))
                                                                                                                                        then
                                                                                                                                          (_s3223_
                                                                                                                                             _s2569_) >>= fun w__191 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                          (match w__191 with
                                                                                                                                           | Some
                                                                                                                                             ((rd, uimm, s_)) =>
                                                                                                                                              returnm ((Some
                                                                                                                                                          ((C_LDSP
                                                                                                                                                              ((uimm, rd)), build_ex
                                                                                                                                                          (projT1
                                                                                                                                                           (sub_nat
                                                                                                                                                              (projT1
                                                                                                                                                               (string_length
                                                                                                                                                                  arg_))
                                                                                                                                                              (projT1
                                                                                                                                                               (string_length
                                                                                                                                                                  s_)))))))
                                                                                                                                               : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                0)})))
                                                                                                                                           | _ =>
                                                                                                                                              exit tt
                                                                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                0)})))
                                                                                                                                           end)
                                                                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                            0)})))
                                                                                                                                        else
                                                                                                                                          (_s3235_
                                                                                                                                             _s2569_) >>= fun w__194 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                          (if
                                                                                                                                             ((match w__194 with
                                                                                                                                               | Some
                                                                                                                                                 ((rd, uimm, s_)) =>
                                                                                                                                                  true
                                                                                                                                               | _ =>
                                                                                                                                                  false
                                                                                                                                               end))
                                                                                                                                           then
                                                                                                                                             (_s3235_
                                                                                                                                                _s2569_) >>= fun w__195 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                             (match w__195 with
                                                                                                                                              | Some
                                                                                                                                                ((rd, uimm, s_)) =>
                                                                                                                                                 returnm ((Some
                                                                                                                                                             ((C_SWSP
                                                                                                                                                                 ((uimm, rd)), build_ex
                                                                                                                                                             (projT1
                                                                                                                                                              (sub_nat
                                                                                                                                                                 (projT1
                                                                                                                                                                  (string_length
                                                                                                                                                                     arg_))
                                                                                                                                                                 (projT1
                                                                                                                                                                  (string_length
                                                                                                                                                                     s_)))))))
                                                                                                                                                  : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                   0)})))
                                                                                                                                              | _ =>
                                                                                                                                                 exit tt
                                                                                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                   0)})))
                                                                                                                                              end)
                                                                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                               0)})))
                                                                                                                                           else
                                                                                                                                             (_s3247_
                                                                                                                                                _s2569_) >>= fun w__198 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                             (if
                                                                                                                                                ((match w__198 with
                                                                                                                                                  | Some
                                                                                                                                                    ((rs2, uimm, s_)) =>
                                                                                                                                                     Z.eqb
                                                                                                                                                       64
                                                                                                                                                       64
                                                                                                                                                  | _ =>
                                                                                                                                                     false
                                                                                                                                                  end))
                                                                                                                                              then
                                                                                                                                                (_s3247_
                                                                                                                                                   _s2569_) >>= fun w__199 : option ((mword 5 * mword 6 * string)) =>
                                                                                                                                                (match w__199 with
                                                                                                                                                 | Some
                                                                                                                                                   ((rs2, uimm, s_)) =>
                                                                                                                                                    returnm ((Some
                                                                                                                                                                ((C_SDSP
                                                                                                                                                                    ((uimm, rs2)), build_ex
                                                                                                                                                                (projT1
                                                                                                                                                                 (sub_nat
                                                                                                                                                                    (projT1
                                                                                                                                                                     (string_length
                                                                                                                                                                        arg_))
                                                                                                                                                                    (projT1
                                                                                                                                                                     (string_length
                                                                                                                                                                        s_)))))))
                                                                                                                                                     : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                      0)})))
                                                                                                                                                 | _ =>
                                                                                                                                                    exit tt
                                                                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                      0)})))
                                                                                                                                                 end)
                                                                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                  0)})))
                                                                                                                                              else
                                                                                                                                                (_s3259_
                                                                                                                                                   _s2569_) >>= fun w__202 : option ((mword 5 * string)) =>
                                                                                                                                                (if
                                                                                                                                                   ((match w__202 with
                                                                                                                                                     | Some
                                                                                                                                                       ((rs1, s_)) =>
                                                                                                                                                        projT1
                                                                                                                                                        (neq_int
                                                                                                                                                           (projT1
                                                                                                                                                            (regidx_to_regno
                                                                                                                                                               rs1))
                                                                                                                                                           (projT1
                                                                                                                                                            (regidx_to_regno
                                                                                                                                                               zreg)))
                                                                                                                                                     | _ =>
                                                                                                                                                        false
                                                                                                                                                     end))
                                                                                                                                                 then
                                                                                                                                                   (_s3259_
                                                                                                                                                      _s2569_) >>= fun w__203 : option ((mword 5 * string)) =>
                                                                                                                                                   (match w__203 with
                                                                                                                                                    | Some
                                                                                                                                                      ((rs1, s_)) =>
                                                                                                                                                       returnm ((Some
                                                                                                                                                                   ((C_JR
                                                                                                                                                                       (rs1), build_ex
                                                                                                                                                                   (projT1
                                                                                                                                                                    (sub_nat
                                                                                                                                                                       (projT1
                                                                                                                                                                        (string_length
                                                                                                                                                                           arg_))
                                                                                                                                                                       (projT1
                                                                                                                                                                        (string_length
                                                                                                                                                                           s_)))))))
                                                                                                                                                        : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                         0)})))
                                                                                                                                                    | _ =>
                                                                                                                                                       exit tt
                                                                                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                         0)})))
                                                                                                                                                    end)
                                                                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                     0)})))
                                                                                                                                                 else
                                                                                                                                                   (_s3267_
                                                                                                                                                      _s2569_) >>= fun w__206 : option ((mword 5 * string)) =>
                                                                                                                                                   (if
                                                                                                                                                      ((match w__206 with
                                                                                                                                                        | Some
                                                                                                                                                          ((rs1, s_)) =>
                                                                                                                                                           projT1
                                                                                                                                                           (neq_int
                                                                                                                                                              (projT1
                                                                                                                                                               (regidx_to_regno
                                                                                                                                                                  rs1))
                                                                                                                                                              (projT1
                                                                                                                                                               (regidx_to_regno
                                                                                                                                                                  zreg)))
                                                                                                                                                        | _ =>
                                                                                                                                                           false
                                                                                                                                                        end))
                                                                                                                                                    then
                                                                                                                                                      (_s3267_
                                                                                                                                                         _s2569_) >>= fun w__207 : option ((mword 5 * string)) =>
                                                                                                                                                      (match w__207 with
                                                                                                                                                       | Some
                                                                                                                                                         ((rs1, s_)) =>
                                                                                                                                                          returnm ((Some
                                                                                                                                                                      ((C_JALR
                                                                                                                                                                          (rs1), build_ex
                                                                                                                                                                      (projT1
                                                                                                                                                                       (sub_nat
                                                                                                                                                                          (projT1
                                                                                                                                                                           (string_length
                                                                                                                                                                              arg_))
                                                                                                                                                                          (projT1
                                                                                                                                                                           (string_length
                                                                                                                                                                              s_)))))))
                                                                                                                                                           : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                            0)})))
                                                                                                                                                       | _ =>
                                                                                                                                                          exit tt
                                                                                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                            0)})))
                                                                                                                                                       end)
                                                                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                        0)})))
                                                                                                                                                    else
                                                                                                                                                      (_s3275_
                                                                                                                                                         _s2569_) >>= fun w__210 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                                                      (if
                                                                                                                                                         ((match w__210 with
                                                                                                                                                           | Some
                                                                                                                                                             ((rd, rs2, s_)) =>
                                                                                                                                                              andb
                                                                                                                                                                (projT1
                                                                                                                                                                 (neq_int
                                                                                                                                                                    (projT1
                                                                                                                                                                     (regidx_to_regno
                                                                                                                                                                        rd))
                                                                                                                                                                    (projT1
                                                                                                                                                                     (regidx_to_regno
                                                                                                                                                                        zreg))))
                                                                                                                                                                ((projT1
                                                                                                                                                                  (neq_int
                                                                                                                                                                     (projT1
                                                                                                                                                                      (regidx_to_regno
                                                                                                                                                                         rs2))
                                                                                                                                                                     (projT1
                                                                                                                                                                      (regidx_to_regno
                                                                                                                                                                         zreg))))
                                                                                                                                                                 : bool)
                                                                                                                                                           | _ =>
                                                                                                                                                              false
                                                                                                                                                           end))
                                                                                                                                                       then
                                                                                                                                                         (_s3275_
                                                                                                                                                            _s2569_) >>= fun w__211 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                                                         (match w__211 with
                                                                                                                                                          | Some
                                                                                                                                                            ((rd, rs2, s_)) =>
                                                                                                                                                             returnm ((Some
                                                                                                                                                                         ((C_MV
                                                                                                                                                                             ((rd, rs2)), build_ex
                                                                                                                                                                         (projT1
                                                                                                                                                                          (sub_nat
                                                                                                                                                                             (projT1
                                                                                                                                                                              (string_length
                                                                                                                                                                                 arg_))
                                                                                                                                                                             (projT1
                                                                                                                                                                              (string_length
                                                                                                                                                                                 s_)))))))
                                                                                                                                                              : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                               0)})))
                                                                                                                                                          | _ =>
                                                                                                                                                             exit tt
                                                                                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                               0)})))
                                                                                                                                                          end)
                                                                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                           0)})))
                                                                                                                                                       else if
                                                                                                                                                         ((match (_s3287_
                                                                                                                                                                    _s2569_) with
                                                                                                                                                           | Some
                                                                                                                                                             (s_) =>
                                                                                                                                                              true
                                                                                                                                                           | _ =>
                                                                                                                                                              false
                                                                                                                                                           end))
                                                                                                                                                       then
                                                                                                                                                         (match (_s3287_
                                                                                                                                                                   _s2569_) with
                                                                                                                                                          | Some
                                                                                                                                                            (s_) =>
                                                                                                                                                             returnm ((Some
                                                                                                                                                                         ((C_EBREAK
                                                                                                                                                                             (tt), build_ex
                                                                                                                                                                         (projT1
                                                                                                                                                                          (sub_nat
                                                                                                                                                                             (projT1
                                                                                                                                                                              (string_length
                                                                                                                                                                                 arg_))
                                                                                                                                                                             (projT1
                                                                                                                                                                              (string_length
                                                                                                                                                                                 s_)))))))
                                                                                                                                                              : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                               0)})))
                                                                                                                                                          | _ =>
                                                                                                                                                             exit tt
                                                                                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                               0)})))
                                                                                                                                                          end)
                                                                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                           0)})))
                                                                                                                                                       else
                                                                                                                                                         (_s3291_
                                                                                                                                                            _s2569_) >>= fun w__216 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                                                         (if
                                                                                                                                                            ((match w__216 with
                                                                                                                                                              | Some
                                                                                                                                                                ((rsd, rs2, s_)) =>
                                                                                                                                                                 andb
                                                                                                                                                                   (projT1
                                                                                                                                                                    (neq_int
                                                                                                                                                                       (projT1
                                                                                                                                                                        (regidx_to_regno
                                                                                                                                                                           rsd))
                                                                                                                                                                       (projT1
                                                                                                                                                                        (regidx_to_regno
                                                                                                                                                                           zreg))))
                                                                                                                                                                   ((projT1
                                                                                                                                                                     (neq_int
                                                                                                                                                                        (projT1
                                                                                                                                                                         (regidx_to_regno
                                                                                                                                                                            rs2))
                                                                                                                                                                        (projT1
                                                                                                                                                                         (regidx_to_regno
                                                                                                                                                                            zreg))))
                                                                                                                                                                    : bool)
                                                                                                                                                              | _ =>
                                                                                                                                                                 false
                                                                                                                                                              end))
                                                                                                                                                          then
                                                                                                                                                            (_s3291_
                                                                                                                                                               _s2569_) >>= fun w__217 : option ((mword 5 * mword 5 * string)) =>
                                                                                                                                                            (match w__217 with
                                                                                                                                                             | Some
                                                                                                                                                               ((rsd, rs2, s_)) =>
                                                                                                                                                                returnm ((Some
                                                                                                                                                                            ((C_ADD
                                                                                                                                                                                ((rsd, rs2)), build_ex
                                                                                                                                                                            (projT1
                                                                                                                                                                             (sub_nat
                                                                                                                                                                                (projT1
                                                                                                                                                                                 (string_length
                                                                                                                                                                                    arg_))
                                                                                                                                                                                (projT1
                                                                                                                                                                                 (string_length
                                                                                                                                                                                    s_)))))))
                                                                                                                                                                 : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                  0)})))
                                                                                                                                                             | _ =>
                                                                                                                                                                exit tt
                                                                                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                  0)})))
                                                                                                                                                             end)
                                                                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                              0)})))
                                                                                                                                                          else
                                                                                                                                                            (_s3303_
                                                                                                                                                               _s2569_) >>= fun w__220 : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                            (if
                                                                                                                                                               ((match w__220 with
                                                                                                                                                                 | Some
                                                                                                                                                                   ((high, signed1, signed2, rd, rs1, rs2, s_)) =>
                                                                                                                                                                    true
                                                                                                                                                                 | _ =>
                                                                                                                                                                    false
                                                                                                                                                                 end))
                                                                                                                                                             then
                                                                                                                                                               (_s3303_
                                                                                                                                                                  _s2569_) >>= fun w__221 : option ((bool * bool * bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                               (match w__221 with
                                                                                                                                                                | Some
                                                                                                                                                                  ((high, signed1, signed2, rd, rs1, rs2, s_)) =>
                                                                                                                                                                   returnm ((Some
                                                                                                                                                                               ((MUL
                                                                                                                                                                                   ((rs2, rs1, rd, high, signed1, signed2)), build_ex
                                                                                                                                                                               (projT1
                                                                                                                                                                                (sub_nat
                                                                                                                                                                                   (projT1
                                                                                                                                                                                    (string_length
                                                                                                                                                                                       arg_))
                                                                                                                                                                                   (projT1
                                                                                                                                                                                    (string_length
                                                                                                                                                                                       s_)))))))
                                                                                                                                                                    : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                     0)})))
                                                                                                                                                                | _ =>
                                                                                                                                                                   exit tt
                                                                                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                     0)})))
                                                                                                                                                                end)
                                                                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                 0)})))
                                                                                                                                                             else
                                                                                                                                                               (_s3320_
                                                                                                                                                                  _s2569_) >>= fun w__224 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                               (if
                                                                                                                                                                  ((match w__224 with
                                                                                                                                                                    | Some
                                                                                                                                                                      ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                       true
                                                                                                                                                                    | _ =>
                                                                                                                                                                       false
                                                                                                                                                                    end))
                                                                                                                                                                then
                                                                                                                                                                  (_s3320_
                                                                                                                                                                     _s2569_) >>= fun w__225 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                  (match w__225 with
                                                                                                                                                                   | Some
                                                                                                                                                                     ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                      returnm ((Some
                                                                                                                                                                                  ((DIV
                                                                                                                                                                                      ((rs2, rs1, rd, s)), build_ex
                                                                                                                                                                                  (projT1
                                                                                                                                                                                   (sub_nat
                                                                                                                                                                                      (projT1
                                                                                                                                                                                       (string_length
                                                                                                                                                                                          arg_))
                                                                                                                                                                                      (projT1
                                                                                                                                                                                       (string_length
                                                                                                                                                                                          s_)))))))
                                                                                                                                                                       : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                        0)})))
                                                                                                                                                                   | _ =>
                                                                                                                                                                      exit tt
                                                                                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                        0)})))
                                                                                                                                                                   end)
                                                                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                    0)})))
                                                                                                                                                                else
                                                                                                                                                                  (_s3338_
                                                                                                                                                                     _s2569_) >>= fun w__228 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                  (if
                                                                                                                                                                     ((match w__228 with
                                                                                                                                                                       | Some
                                                                                                                                                                         ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                          true
                                                                                                                                                                       | _ =>
                                                                                                                                                                          false
                                                                                                                                                                       end))
                                                                                                                                                                   then
                                                                                                                                                                     (_s3338_
                                                                                                                                                                        _s2569_) >>= fun w__229 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                     (match w__229 with
                                                                                                                                                                      | Some
                                                                                                                                                                        ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                         returnm ((Some
                                                                                                                                                                                     ((REM
                                                                                                                                                                                         ((rs2, rs1, rd, s)), build_ex
                                                                                                                                                                                     (projT1
                                                                                                                                                                                      (sub_nat
                                                                                                                                                                                         (projT1
                                                                                                                                                                                          (string_length
                                                                                                                                                                                             arg_))
                                                                                                                                                                                         (projT1
                                                                                                                                                                                          (string_length
                                                                                                                                                                                             s_)))))))
                                                                                                                                                                          : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                           0)})))
                                                                                                                                                                      | _ =>
                                                                                                                                                                         exit tt
                                                                                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                           0)})))
                                                                                                                                                                      end)
                                                                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                       0)})))
                                                                                                                                                                   else
                                                                                                                                                                     (_s3356_
                                                                                                                                                                        _s2569_) >>= fun w__232 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                     (if
                                                                                                                                                                        ((match w__232 with
                                                                                                                                                                          | Some
                                                                                                                                                                            ((rd, rs1, rs2, s_)) =>
                                                                                                                                                                             Z.eqb
                                                                                                                                                                               64
                                                                                                                                                                               64
                                                                                                                                                                          | _ =>
                                                                                                                                                                             false
                                                                                                                                                                          end))
                                                                                                                                                                      then
                                                                                                                                                                        (_s3356_
                                                                                                                                                                           _s2569_) >>= fun w__233 : option ((mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                        (match w__233 with
                                                                                                                                                                         | Some
                                                                                                                                                                           ((rd, rs1, rs2, s_)) =>
                                                                                                                                                                            returnm ((Some
                                                                                                                                                                                        ((MULW
                                                                                                                                                                                            ((rs2, rs1, rd)), build_ex
                                                                                                                                                                                        (projT1
                                                                                                                                                                                         (sub_nat
                                                                                                                                                                                            (projT1
                                                                                                                                                                                             (string_length
                                                                                                                                                                                                arg_))
                                                                                                                                                                                            (projT1
                                                                                                                                                                                             (string_length
                                                                                                                                                                                                s_)))))))
                                                                                                                                                                             : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                              0)})))
                                                                                                                                                                         | _ =>
                                                                                                                                                                            exit tt
                                                                                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                              0)})))
                                                                                                                                                                         end)
                                                                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                          0)})))
                                                                                                                                                                      else
                                                                                                                                                                        (_s3372_
                                                                                                                                                                           _s2569_) >>= fun w__236 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                        (if
                                                                                                                                                                           ((match w__236 with
                                                                                                                                                                             | Some
                                                                                                                                                                               ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                                Z.eqb
                                                                                                                                                                                  64
                                                                                                                                                                                  64
                                                                                                                                                                             | _ =>
                                                                                                                                                                                false
                                                                                                                                                                             end))
                                                                                                                                                                         then
                                                                                                                                                                           (_s3372_
                                                                                                                                                                              _s2569_) >>= fun w__237 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                           (match w__237 with
                                                                                                                                                                            | Some
                                                                                                                                                                              ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                               returnm ((Some
                                                                                                                                                                                           ((DIVW
                                                                                                                                                                                               ((rs2, rs1, rd, s)), build_ex
                                                                                                                                                                                           (projT1
                                                                                                                                                                                            (sub_nat
                                                                                                                                                                                               (projT1
                                                                                                                                                                                                (string_length
                                                                                                                                                                                                   arg_))
                                                                                                                                                                                               (projT1
                                                                                                                                                                                                (string_length
                                                                                                                                                                                                   s_)))))))
                                                                                                                                                                                : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                 0)})))
                                                                                                                                                                            | _ =>
                                                                                                                                                                               exit tt
                                                                                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                 0)})))
                                                                                                                                                                            end)
                                                                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                             0)})))
                                                                                                                                                                         else
                                                                                                                                                                           (_s3391_
                                                                                                                                                                              _s2569_) >>= fun w__240 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                           (if
                                                                                                                                                                              ((match w__240 with
                                                                                                                                                                                | Some
                                                                                                                                                                                  ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                                   Z.eqb
                                                                                                                                                                                     64
                                                                                                                                                                                     64
                                                                                                                                                                                | _ =>
                                                                                                                                                                                   false
                                                                                                                                                                                end))
                                                                                                                                                                            then
                                                                                                                                                                              (_s3391_
                                                                                                                                                                                 _s2569_) >>= fun w__241 : option ((bool * mword 5 * mword 5 * mword 5 * string)) =>
                                                                                                                                                                              (match w__241 with
                                                                                                                                                                               | Some
                                                                                                                                                                                 ((s, rd, rs1, rs2, s_)) =>
                                                                                                                                                                                  returnm ((Some
                                                                                                                                                                                              ((REMW
                                                                                                                                                                                                  ((rs2, rs1, rd, s)), build_ex
                                                                                                                                                                                              (projT1
                                                                                                                                                                                               (sub_nat
                                                                                                                                                                                                  (projT1
                                                                                                                                                                                                   (string_length
                                                                                                                                                                                                      arg_))
                                                                                                                                                                                                  (projT1
                                                                                                                                                                                                   (string_length
                                                                                                                                                                                                      s_)))))))
                                                                                                                                                                                   : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                    0)})))
                                                                                                                                                                               | _ =>
                                                                                                                                                                                  exit tt
                                                                                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                    0)})))
                                                                                                                                                                               end)
                                                                                                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                0)})))
                                                                                                                                                                            else
                                                                                                                                                                              (_s3410_
                                                                                                                                                                                 _s2569_) >>= fun w__244 : option ((csrop * mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                                                                                              (if
                                                                                                                                                                                 ((match w__244 with
                                                                                                                                                                                   | Some
                                                                                                                                                                                     ((op, rd, rs1, csr, s_)) =>
                                                                                                                                                                                      true
                                                                                                                                                                                   | _ =>
                                                                                                                                                                                      false
                                                                                                                                                                                   end))
                                                                                                                                                                               then
                                                                                                                                                                                 (_s3410_
                                                                                                                                                                                    _s2569_) >>= fun w__245 : option ((csrop * mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                                                                                                 (match w__245 with
                                                                                                                                                                                  | Some
                                                                                                                                                                                    ((op, rd, rs1, csr, s_)) =>
                                                                                                                                                                                     returnm ((Some
                                                                                                                                                                                                 ((CSR
                                                                                                                                                                                                     ((csr, rs1, rd, true, op)), build_ex
                                                                                                                                                                                                 (projT1
                                                                                                                                                                                                  (sub_nat
                                                                                                                                                                                                     (projT1
                                                                                                                                                                                                      (string_length
                                                                                                                                                                                                         arg_))
                                                                                                                                                                                                     (projT1
                                                                                                                                                                                                      (string_length
                                                                                                                                                                                                         s_)))))))
                                                                                                                                                                                      : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                       0)})))
                                                                                                                                                                                  | _ =>
                                                                                                                                                                                     exit tt
                                                                                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                       0)})))
                                                                                                                                                                                  end)
                                                                                                                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                   0)})))
                                                                                                                                                                               else
                                                                                                                                                                                 (_s3428_
                                                                                                                                                                                    _s2569_) >>= fun w__248 : option ((csrop * mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                                                                                                 (if
                                                                                                                                                                                    ((match w__248 with
                                                                                                                                                                                      | Some
                                                                                                                                                                                        ((op, rd, rs1, csr, s_)) =>
                                                                                                                                                                                         true
                                                                                                                                                                                      | _ =>
                                                                                                                                                                                         false
                                                                                                                                                                                      end))
                                                                                                                                                                                  then
                                                                                                                                                                                    (_s3428_
                                                                                                                                                                                       _s2569_) >>= fun w__249 : option ((csrop * mword 5 * mword 5 * mword 12 * string)) =>
                                                                                                                                                                                    (match w__249 with
                                                                                                                                                                                     | Some
                                                                                                                                                                                       ((op, rd, rs1, csr, s_)) =>
                                                                                                                                                                                        returnm ((Some
                                                                                                                                                                                                    ((CSR
                                                                                                                                                                                                        ((csr, rs1, rd, false, op)), build_ex
                                                                                                                                                                                                    (projT1
                                                                                                                                                                                                     (sub_nat
                                                                                                                                                                                                        (projT1
                                                                                                                                                                                                         (string_length
                                                                                                                                                                                                            arg_))
                                                                                                                                                                                                        (projT1
                                                                                                                                                                                                         (string_length
                                                                                                                                                                                                            s_)))))))
                                                                                                                                                                                         : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                          0)})))
                                                                                                                                                                                     | _ =>
                                                                                                                                                                                        exit tt
                                                                                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                          0)})))
                                                                                                                                                                                     end)
                                                                                                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                      0)})))
                                                                                                                                                                                  else if
                                                                                                                                                                                    ((match (_s3445_
                                                                                                                                                                                               _s2569_) with
                                                                                                                                                                                      | Some
                                                                                                                                                                                        (s_) =>
                                                                                                                                                                                         true
                                                                                                                                                                                      | _ =>
                                                                                                                                                                                         false
                                                                                                                                                                                      end))
                                                                                                                                                                                  then
                                                                                                                                                                                    (match (_s3445_
                                                                                                                                                                                              _s2569_) with
                                                                                                                                                                                     | Some
                                                                                                                                                                                       (s_) =>
                                                                                                                                                                                        returnm ((Some
                                                                                                                                                                                                    ((URET
                                                                                                                                                                                                        (tt), build_ex
                                                                                                                                                                                                    (projT1
                                                                                                                                                                                                     (sub_nat
                                                                                                                                                                                                        (projT1
                                                                                                                                                                                                         (string_length
                                                                                                                                                                                                            arg_))
                                                                                                                                                                                                        (projT1
                                                                                                                                                                                                         (string_length
                                                                                                                                                                                                            s_)))))))
                                                                                                                                                                                         : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                          0)})))
                                                                                                                                                                                     | _ =>
                                                                                                                                                                                        exit tt
                                                                                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                          0)})))
                                                                                                                                                                                     end)
                                                                                                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                      0)})))
                                                                                                                                                                                  else
                                                                                                                                                                                    (_s3449_
                                                                                                                                                                                       _s2569_) >>= fun w__254 : option ((mword 32 * string)) =>
                                                                                                                                                                                    (if
                                                                                                                                                                                       ((match w__254 with
                                                                                                                                                                                         | Some
                                                                                                                                                                                           ((s, s_)) =>
                                                                                                                                                                                            true
                                                                                                                                                                                         | _ =>
                                                                                                                                                                                            false
                                                                                                                                                                                         end))
                                                                                                                                                                                     then
                                                                                                                                                                                       (_s3449_
                                                                                                                                                                                          _s2569_) >>= fun w__255 : option ((mword 32 * string)) =>
                                                                                                                                                                                       (match w__255 with
                                                                                                                                                                                        | Some
                                                                                                                                                                                          ((s, s_)) =>
                                                                                                                                                                                           returnm ((Some
                                                                                                                                                                                                       ((ILLEGAL
                                                                                                                                                                                                           (s), build_ex
                                                                                                                                                                                                       (projT1
                                                                                                                                                                                                        (sub_nat
                                                                                                                                                                                                           (projT1
                                                                                                                                                                                                            (string_length
                                                                                                                                                                                                               arg_))
                                                                                                                                                                                                           (projT1
                                                                                                                                                                                                            (string_length
                                                                                                                                                                                                               s_)))))))
                                                                                                                                                                                            : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                             0)})))
                                                                                                                                                                                        | _ =>
                                                                                                                                                                                           exit tt
                                                                                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                             0)})))
                                                                                                                                                                                        end)
                                                                                                                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                         0)})))
                                                                                                                                                                                     else
                                                                                                                                                                                       (_s3457_
                                                                                                                                                                                          _s2569_) >>= fun w__258 : option ((mword 16 * string)) =>
                                                                                                                                                                                       (if
                                                                                                                                                                                          ((match w__258 with
                                                                                                                                                                                            | Some
                                                                                                                                                                                              ((s, s_)) =>
                                                                                                                                                                                               true
                                                                                                                                                                                            | _ =>
                                                                                                                                                                                               false
                                                                                                                                                                                            end))
                                                                                                                                                                                        then
                                                                                                                                                                                          (_s3457_
                                                                                                                                                                                             _s2569_) >>= fun w__259 : option ((mword 16 * string)) =>
                                                                                                                                                                                          (match w__259 with
                                                                                                                                                                                           | Some
                                                                                                                                                                                             ((s, s_)) =>
                                                                                                                                                                                              returnm ((Some
                                                                                                                                                                                                          ((C_ILLEGAL
                                                                                                                                                                                                              (s), build_ex
                                                                                                                                                                                                          (projT1
                                                                                                                                                                                                           (sub_nat
                                                                                                                                                                                                              (projT1
                                                                                                                                                                                                               (string_length
                                                                                                                                                                                                                  arg_))
                                                                                                                                                                                                              (projT1
                                                                                                                                                                                                               (string_length
                                                                                                                                                                                                                  s_)))))))
                                                                                                                                                                                               : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                                0)})))
                                                                                                                                                                                           | _ =>
                                                                                                                                                                                              exit tt
                                                                                                                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                                0)})))
                                                                                                                                                                                           end)
                                                                                                                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                            0)})))
                                                                                                                                                                                        else
                                                                                                                                                                                          returnm (None
                                                                                                                                                                                           : option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                            0)}))))
                                                                                                                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                         0)}))))
                                                                                                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                      0)}))))
                                                                                                                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                   0)}))))
                                                                                                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                                0)}))))
                                                                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                             0)}))))
                                                                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                          0)}))))
                                                                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                       0)}))))
                                                                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                    0)}))))
                                                                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                                 0)}))))
                                                                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                              0)}))))
                                                                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                           0)}))))
                                                                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                        0)}))))
                                                                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                     0)}))))
                                                                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                                  0)}))))
                                                                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                               0)}))))
                                                                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                            0)}))))
                                                                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                         0)}))))
                                                                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                      0)}))))
                                                                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                   0)}))))
                                                                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                                0)}))))
                                                                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                             0)}))))
                                                                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                          0)}))))
                                                                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                       0)}))))
                                                                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                    0)}))))
                                                                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                                 0)}))))
                                                                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                              0)}))))
                                                                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                           0)}))))
                                                                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                        0)}))))
                                                                                                    : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                     0)}))))
                                                                                                 : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                                  0)}))))
                                                                                              : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                               0)}))))
                                                                                           : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                            0)}))))
                                                                                        : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                         0)}))))
                                                                                     : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                      0)}))))
                                                                                  : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                   0)}))))
                                                                               : M (option ((ast * {n : Z & ArithFact (n >=
                                                                                0)}))))
                                                                            : M (option ((ast * {n : Z & ArithFact (n >=
                                                                             0)}))))
                                                                         : M (option ((ast * {n : Z & ArithFact (n >=
                                                                          0)}))))
                                                                      : M (option ((ast * {n : Z & ArithFact (n >=
                                                                       0)}))))
                                                                   : M (option ((ast * {n : Z & ArithFact (n >=
                                                                    0)}))))
                                                                : M (option ((ast * {n : Z & ArithFact (n >=
                                                                 0)}))))
                                                             : M (option ((ast * {n : Z & ArithFact (n >=
                                                              0)}))))
                                                          : M (option ((ast * {n : Z & ArithFact (n >=
                                                           0)}))))
                                                       : M (option ((ast * {n : Z & ArithFact (n >=
                                                        0)}))))
                                                    : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                                 : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                              : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                           : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                        : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                     : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                                  : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                               : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                            : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                         : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                      : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                   : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
                : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
             : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
          : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
       : M (option ((ast * {n : Z & ArithFact (n >= 0)}))))
    : M (option ((ast * {n : Z & ArithFact (n >= 0)}))).

Definition print_insn (insn : ast)  : M (string) :=  (assembly_forwards insn)  : M (string).

Definition decode (bv : mword 32)  : M (ast) :=  (encdec_backwards bv)  : M (ast).

Definition decodeCompressed (bv : mword 16)  : ast :=  encdec_compressed_backwards bv.

Definition GPRstr : vec string 32 :=
vec_of_list_len ["x31";"x30";"x29";"x28";"x27";"x26";"x25";"x24";"x23";"x22";"x21";"x20";"x19";"x18";"x17";"x16";"x15";"x14";"x13";"x12";"x11";
                 "x10";"x9";"x8";"x7";"x6";"x5";"x4";"x3";"x2";"x1";"x0"].
Hint Unfold GPRstr : sail.
Definition CIA_fp := RFull ("CIA").
Hint Unfold CIA_fp : sail.
Definition NIA_fp := RFull ("NIA").
Hint Unfold NIA_fp : sail.
Definition initial_analysis (instr : ast) 
: M ((list regfp * list regfp * list regfp * list niafp * diafp * instruction_kind)) :=
   
   let iR := []  : regfps in
   let oR := []  : regfps in
   let aR := []  : regfps in
   let ik := (IK_simple (tt))  : instruction_kind in
   let Nias := [NIAFP_successor (tt)]  : niafps in
   let Dia := (DIAFP_none (tt))  : diafp in
   (match instr with
    | EBREAK (tt) => returnm (Nias, aR, iR, ik, oR)
    | UTYPE ((imm, rd, op)) =>
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | RISCV_JAL ((imm, rd)) =>
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       let offset : bits 64 := EXTS 64 imm in
       ((read_reg PC_ref)  : M (mword 64)) >>= fun w__0 : mword 64 =>
       let Nias : list niafp := [NIAFP_concrete_address (add_vec w__0 offset)] in
       let ik : instruction_kind := IK_branch (tt) in
       returnm (Nias, aR, iR, ik, oR)
    | RISCV_JALR ((imm, rs, rd)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       let offset : bits 64 := EXTS 64 imm in
       let Nias : list niafp := [NIAFP_indirect_address (tt)] in
       let ik : instruction_kind := IK_branch (tt) in
       returnm (Nias, aR, iR, ik, oR)
    | BTYPE ((imm, rs2, rs1, op)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs2)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs2)))) :: iR in
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR in
       let ik := (IK_branch (tt))  : instruction_kind in
       let offset : bits 64 := EXTS 64 imm in
       ((read_reg PC_ref)  : M (mword 64)) >>= fun w__1 : mword 64 =>
       let Nias : list niafp := [NIAFP_concrete_address (add_vec w__1 offset);NIAFP_successor (tt)] in
       returnm (Nias, aR, iR, ik, oR)
    | ITYPE ((imm, rs, rd, op)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | SHIFTIOP ((imm, rs, rd, op)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | RTYPE ((rs2, rs1, rd, op)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs2)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs2)))) :: iR in
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | CSR ((csr, rs1, rd, is_imm, op)) =>
       let isWrite : bool :=
         match op with
         | CSRRW => true
         | _ =>
            if sumbool_of_bool (is_imm) then projT1 (neq_int (projT1 (uint rs1)) 0)
            else projT1 (neq_int (projT1 (uint rs1)) 0)
         end in
       let iR : list regfp := (RFull (csr_name csr)) :: iR in
       let iR : list regfp :=
         if sumbool_of_bool ((negb is_imm)) then
           (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR
         else iR in
       let oR : list regfp := if sumbool_of_bool (isWrite) then (RFull (csr_name csr)) :: oR else oR in
       let oR : list regfp := (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | LOAD ((imm, rs, rd, unsign, width, aq, rl)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       let aR := iR  : list regfp in
       (match (aq, rl) with
        | (false, false) => returnm ((IK_mem_read (Read_plain))  : instruction_kind )
        | (true, false) => returnm ((IK_mem_read (Read_RISCV_acquire))  : instruction_kind )
        | (true, true) => returnm ((IK_mem_read (Read_RISCV_strong_acquire))  : instruction_kind )
        | _ =>
           (internal_error "LOAD type not implemented in initial_analysis")  : M (instruction_kind)
        end) >>= fun w__3 : instruction_kind =>
       let ik : instruction_kind := w__3 in
       returnm (Nias, aR, iR, ik, oR)
    | STORE ((imm, rs2, rs1, width, aq, rl)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs2)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs2)))) :: iR in
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR in
       let aR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then aR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: aR in
       (match (aq, rl) with
        | (false, false) => returnm ((IK_mem_write (Write_plain))  : instruction_kind )
        | (false, true) => returnm ((IK_mem_write (Write_RISCV_release))  : instruction_kind )
        | (true, true) => returnm ((IK_mem_write (Write_RISCV_strong_release))  : instruction_kind )
        | _ =>
           (internal_error "STORE type not implemented in initial_analysis")  : M (instruction_kind)
        end) >>= fun w__5 : instruction_kind =>
       let ik : instruction_kind := w__5 in
       returnm (Nias, aR, iR, ik, oR)
    | ADDIW ((imm, rs, rd)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | SHIFTW ((imm, rs, rd, op)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | RTYPEW ((rs2, rs1, rd, op)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs2)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs2)))) :: iR in
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       returnm (Nias, aR, iR, ik, oR)
    | FENCE ((pred, succ)) =>
       (match (pred, succ) with
        | (v__838, v__839) =>
           (if ((andb
                   (eq_vec (subrange_vec_dec v__838 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
                   (eq_vec (subrange_vec_dec v__839 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))))
            then
              returnm ((IK_barrier
                          (Barrier_RISCV_rw_rw
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B1;B1]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_r_rw
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B1;B0]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_r_r
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_rw_w
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_w_w
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B1;B1]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_w_rw
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B1;B0]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_rw_r
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B1;B0]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B0;B1]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_r_w
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B0;B1]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B1;B0]  : mword (1 - 0 + 1))))) then
              returnm ((IK_barrier
                          (Barrier_RISCV_w_r
                             (tt)))
               : instruction_kind )
            else if ((andb
                        (eq_vec (subrange_vec_dec v__838 1 0)
                           (vec_of_bits [B0;B0]  : mword (1 - 0 + 1)))
                        (eq_vec (subrange_vec_dec v__839 1 0)
                           (vec_of_bits [B0;B0]  : mword (1 - 0 + 1))))) then
              returnm ((IK_simple
                          (tt))
               : instruction_kind )
            else
              (internal_error "barrier type not implemented in initial_analysis")
               : M (instruction_kind))
            : M (instruction_kind)
        end) >>= fun w__17 : instruction_kind =>
       let ik : instruction_kind := w__17 in
       returnm (Nias, aR, iR, ik, oR)
    | FENCE_TSO ((pred, succ)) =>
       (match (pred, succ) with
        | (v__878, v__879) =>
           (if ((andb
                   (eq_vec (subrange_vec_dec v__878 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))
                   (eq_vec (subrange_vec_dec v__879 1 0) (vec_of_bits [B1;B1]  : mword (1 - 0 + 1)))))
            then
              returnm ((IK_barrier
                          (Barrier_RISCV_tso
                             (tt)))
               : instruction_kind )
            else
              (internal_error "barrier type not implemented in initial_analysis")
               : M (instruction_kind))
            : M (instruction_kind)
        end) >>= fun w__20 : instruction_kind =>
       let ik : instruction_kind := w__20 in
       returnm (Nias, aR, iR, ik, oR)
    | FENCEI (tt) =>
       let ik : instruction_kind := IK_simple (tt) in
       returnm (Nias, aR, iR, ik, oR)
    | LOADRES ((aq, rl, rs1, width, rd)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       let aR := iR  : list regfp in
       (match (aq, rl) with
        | (false, false) => returnm ((IK_mem_read (Read_RISCV_reserved))  : instruction_kind )
        | (true, false) =>
           returnm ((IK_mem_read (Read_RISCV_reserved_acquire))  : instruction_kind )
        | (true, true) =>
           returnm ((IK_mem_read (Read_RISCV_reserved_strong_acquire))  : instruction_kind )
        | (false, true) =>
           (internal_error "LOADRES type not implemented in initial_analysis")
            : M (instruction_kind)
        end) >>= fun w__22 : instruction_kind =>
       let ik : instruction_kind := w__22 in
       returnm (Nias, aR, iR, ik, oR)
    | STORECON ((aq, rl, rs2, rs1, width, rd)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs2)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs2)))) :: iR in
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR in
       let aR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then aR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: aR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       (match (aq, rl) with
        | (false, false) => returnm ((IK_mem_write (Write_RISCV_conditional))  : instruction_kind )
        | (false, true) =>
           returnm ((IK_mem_write (Write_RISCV_conditional_release))  : instruction_kind )
        | (true, true) =>
           returnm ((IK_mem_write (Write_RISCV_conditional_strong_release))  : instruction_kind )
        | (true, false) =>
           (internal_error "STORECON type not implemented in initial_analysis")
            : M (instruction_kind)
        end) >>= fun w__24 : instruction_kind =>
       let ik : instruction_kind := w__24 in
       returnm (Nias, aR, iR, ik, oR)
    | AMO ((op, aq, rl, rs2, rs1, width, rd)) =>
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs2)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs2)))) :: iR in
       let iR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then iR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: iR in
       let aR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rs1)) 0)) then aR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rs1)))) :: aR in
       let oR : list regfp :=
         if sumbool_of_bool ((Z.eqb (projT1 (regidx_to_regno rd)) 0)) then oR
         else (RFull (vec_access_dec GPRstr (projT1 (regidx_to_regno rd)))) :: oR in
       let ik : instruction_kind :=
         match (aq, rl) with
         | (false, false) => IK_mem_rmw ((Read_RISCV_reserved, Write_RISCV_conditional))
         | (false, true) => IK_mem_rmw ((Read_RISCV_reserved, Write_RISCV_conditional_release))
         | (true, false) => IK_mem_rmw ((Read_RISCV_reserved_acquire, Write_RISCV_conditional))
         | (true, true) =>
            IK_mem_rmw ((Read_RISCV_reserved_acquire, Write_RISCV_conditional_release))
         end in
       returnm (Nias, aR, iR, ik, oR)
    | _ => returnm (Nias, aR, iR, ik, oR)
    end) >>= fun '((Nias, aR, iR, ik, oR)
   : (list niafp * list regfp * list regfp * instruction_kind * list regfp)) =>
   returnm (iR, oR, aR, Nias, Dia, ik).


End Content.
